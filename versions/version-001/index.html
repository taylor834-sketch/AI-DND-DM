<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="D&D Voice Adventure - A comprehensive tabletop RPG companion with voice integration, inspired by Baldur's Gate 3 and Gloomhaven.">
    <meta name="keywords" content="D&D, Dungeons Dragons, RPG, tabletop, voice, adventure, campaign">
    <meta name="author" content="D&D Voice Adventure">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://taylor834-sketch.github.io/AI-DND-DM/">
    <meta property="og:title" content="D&D Voice Adventure">
    <meta property="og:description" content="Experience immersive tabletop RPG adventures with voice integration and atmospheric storytelling.">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://taylor834-sketch.github.io/AI-DND-DM/"
    <meta property="twitter:title" content="D&D Voice Adventure">
    <meta property="twitter:description" content="Experience immersive tabletop RPG adventures with voice integration and atmospheric storytelling.">
    
    <title>D&D Voice Adventure</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="./assets/favicon.ico">
    
    <!-- Preconnect for performance -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Crimson+Text:ital,wght@0,400;0,600;1,400&display=swap" rel="stylesheet">
    
    <!-- Main Stylesheet -->
    <link rel="stylesheet" href="./css/main.css">
    
    <!-- Error Styles -->
    <style>
        .critical-error {
            max-width: 600px;
            margin: 50px auto;
            padding: 30px;
            background: #1a1a1a;
            border: 2px solid #ff4444;
            border-radius: 10px;
            color: white;
            font-family: 'Crimson Text', serif;
        }
        .critical-error h2 {
            color: #ff6666;
            margin-top: 0;
        }
        .error-help {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #4CAF50;
        }
        .error-help h3 {
            color: #4CAF50;
            margin-top: 0;
        }
        .error-help code {
            background: #333;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
        }
        .error-actions {
            margin-top: 20px;
        }
        .error-actions button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            margin-right: 10px;
            cursor: pointer;
            font-size: 14px;
        }
        .error-actions button:hover {
            background: #45a049;
        }
        .error-actions button:nth-child(2) {
            background: #2196F3;
        }
        .error-actions button:nth-child(2):hover {
            background: #1976D2;
        }
    </style>
    
    <!-- Preload critical resources -->
    <link rel="preload" href="./js/core.js" as="script">
    <link rel="preload" href="./css/main.css" as="style">
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading-screen" class="loading-screen">
        <div class="loading-content">
            <div class="dragon-symbol">üêâ</div>
            <h1 class="loading-title">D&D Voice Adventure</h1>
            <div class="loading-bar">
                <div class="loading-progress" id="loading-progress"></div>
            </div>
            <p class="loading-text" id="loading-text">Awakening ancient powers...</p>
        </div>
    </div>

    <!-- Error Container for Critical Errors -->
    <div id="error-container" class="error-container" style="display: none;"></div>

    <!-- Main Application Container -->
    <div id="app" class="app-container">
        <!-- Main Menu Screen -->
        <div id="mainMenu-screen" class="screen main-menu-screen active">
            <!-- Background Elements -->
            <div class="background-overlay"></div>
            <div class="particle-container" id="particle-container"></div>
            
            <!-- Header -->
            <header class="main-header">
                <div class="title-container">
                    <h1 class="main-title">
                        <span class="title-primary">D&D Voice</span>
                        <span class="title-secondary">Adventure</span>
                    </h1>
                    <p class="subtitle">Embark on Epic Journeys</p>
                </div>
            </header>

            <!-- Main Menu Navigation -->
            <nav class="main-menu">
                <div class="menu-container">
                    <button id="create-campaign-btn" class="menu-button primary-button">
                        <span class="button-icon">‚öîÔ∏è</span>
                        <span class="button-text">Create New Campaign</span>
                        <span class="button-description">Begin a fresh adventure</span>
                    </button>

                    <button id="continue-campaign-btn" class="menu-button secondary-button">
                        <span class="button-icon">üìñ</span>
                        <span class="button-text">Continue Campaign</span>
                        <span class="button-description">Resume your journey</span>
                    </button>

                    <button id="load-github-btn" class="menu-button secondary-button">
                        <span class="button-icon">‚òÅÔ∏è</span>
                        <span class="button-text">Load from GitHub</span>
                        <span class="button-description">Sync your adventures</span>
                    </button>

                    <button id="world-browser-btn" class="menu-button secondary-button">
                        <span class="button-icon">üåç</span>
                        <span class="button-text">World Browser</span>
                        <span class="button-description">Explore NPCs, locations, and lore</span>
                    </button>

                    <button id="settings-btn" class="menu-button tertiary-button">
                        <span class="button-icon">‚öôÔ∏è</span>
                        <span class="button-text">Settings</span>
                        <span class="button-description">Configure your experience</span>
                    </button>
                </div>
            </nav>

            <!-- Footer -->
            <footer class="main-footer">
                <div class="footer-content">
                    <p class="version-info">Version <span id="app-version">1.0.0</span></p>
                    <p class="github-link">
                        <a href="https://github.com/taylor834-sketch/AI-DND-DM" target="_blank" rel="noopener noreferrer">
                            View on GitHub
                        </a>
                    </p>
                </div>
            </footer>
        </div>

        <!-- Settings Screen -->
        <div id="settings-screen" class="screen settings-screen">
            <div class="settings-container">
                <header class="screen-header">
                    <h2>Settings</h2>
                    <button class="close-button" onclick="promptToSave('mainMenu')">‚úï</button>
                </header>
                
                <div class="settings-content">
                    <div class="settings-section">
                        <h3>Audio</h3>
                        <div class="setting-item">
                            <label>
                                <input type="checkbox" id="enable-audio"> Enable Audio Effects
                            </label>
                        </div>
                        <div class="setting-item">
                            <label>
                                Master Volume
                                <input type="range" id="master-volume" min="0" max="100" value="70">
                            </label>
                        </div>
                    </div>
                    
                    <div class="settings-section">
                        <h3>Display</h3>
                        <div class="setting-item">
                            <label>
                                <select id="theme-select">
                                    <option value="dark">Dark Theme</option>
                                    <option value="light">Light Theme</option>
                                    <option value="auto">Auto (System)</option>
                                </select>
                                Theme
                            </label>
                        </div>
                        <div class="setting-item">
                            <label>
                                <input type="checkbox" id="enable-particles" checked> Enable Particles
                            </label>
                        </div>
                    </div>
                    
                    <div class="settings-section">
                        <h3>GitHub Integration</h3>
                        <div class="setting-item">
                            <label>
                                GitHub Token
                                <input type="password" id="github-token" placeholder="ghp_xxxxxxxxxxxx">
                            </label>
                        </div>
                        <div class="setting-item">
                            <label>
                                Repository
                                <input type="text" id="github-repo" placeholder="username/dnd-campaigns">
                            </label>
                        </div>
                        <button id="test-github-connection" class="secondary-button">Test Connection</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Campaign List Screen -->
        <div id="campaignList-screen" class="screen campaign-list-screen">
            <div class="screen-header">
                <h2>Continue Campaign</h2>
                <button class="back-button" onclick="promptToSave('mainMenu')">‚Üê Back</button>
            </div>
            <div class="campaign-list-container">
                <div id="campaign-list-content">
                    <!-- Campaigns will be populated here -->
                </div>
            </div>
        </div>

        <!-- Campaign Creation Screen -->
        <div id="campaignCreation-screen" class="screen campaign-creation-screen">
            <div class="campaign-creation-container">
                <header class="screen-header">
                    <h2>Create New Campaign</h2>
                    <button class="close-button" onclick="promptToSave('mainMenu')">‚úï</button>
                </header>
                
                <form id="campaign-creation-form" class="campaign-form" onsubmit="createCampaign(event); return false;">
                    <div class="form-section">
                        <h3>Campaign Details</h3>
                        
                        <div class="form-group">
                            <label for="campaign-name">Campaign Name *</label>
                            <input type="text" id="campaign-name" name="campaignName" required 
                                   placeholder="The Shattered Crown" maxlength="50">
                            <small>Give your adventure a memorable name</small>
                        </div>

                        <div class="form-group">
                            <label for="world-seed">World Seed</label>
                            <input type="text" id="world-seed" name="worldSeed" 
                                   placeholder="mystical_forests_47291" maxlength="30">
                            <small>Optional: Custom seed for world generation (leave blank for random)</small>
                        </div>
                    </div>

                    <div class="form-section">
                        <h3>Campaign Style</h3>
                        
                        <div class="form-group">
                            <label for="moral-complexity">Moral Complexity</label>
                            <select id="moral-complexity" name="moralComplexity" required>
                                <option value="simple">Simple - Clear good vs evil</option>
                                <option value="nuanced" selected>Nuanced - Shades of gray with clear consequences</option>
                                <option value="morally_gray">Morally Gray - Complex choices with no clear right answer</option>
                            </select>
                            <small>How complex should moral decisions be in your campaign?</small>
                        </div>

                        <div class="form-group">
                            <label for="starting-region">Starting Region</label>
                            <select id="starting-region" name="startingRegion" required>
                                <option value="sword_coast">Sword Coast - Classic D&D adventure region</option>
                                <option value="underdark">Underdark - Dark underground realm</option>
                                <option value="feywild">Feywild - Magical fey realm</option>
                                <option value="shadowfell">Shadowfell - Dark reflection of the material plane</option>
                                <option value="elemental_planes">Elemental Planes - Raw elemental forces</option>
                                <option value="custom">Custom Region</option>
                            </select>
                            <small>Choose the starting location for your adventure</small>
                        </div>

                        <div class="form-group" id="custom-region-group" style="display: none;">
                            <label for="custom-region-name">Custom Region Name</label>
                            <input type="text" id="custom-region-name" name="customRegionName" 
                                   placeholder="The Forgotten Realms" maxlength="40">
                            <small>Name your custom starting region</small>
                        </div>
                    </div>

                    <div class="form-section">
                        <h3>Starting Scenario</h3>
                        <div class="scenario-selection">
                            <div class="scenario-option selected" data-scenario="mysterious_caravan" onclick="selectScenario('mysterious_caravan')">
                                <div class="scenario-header">
                                    <h4>üöö The Mysterious Caravan</h4>
                                    <span class="scenario-difficulty">Beginner</span>
                                </div>
                                <p>A merchant caravan has gone missing on the trade routes. Investigate their disappearance and uncover a web of intrigue.</p>
                                <div class="scenario-features">
                                    <span class="feature">Investigation</span>
                                    <span class="feature">Social Encounters</span>
                                    <span class="feature">Mystery</span>
                                </div>
                            </div>

                            <div class="scenario-option" data-scenario="goblin_raids" onclick="selectScenario('goblin_raids')">
                                <div class="scenario-header">
                                    <h4>‚öîÔ∏è Goblin Raids</h4>
                                    <span class="scenario-difficulty">Beginner</span>
                                </div>
                                <p>Goblin raiders threaten a peaceful village. Rally the townsfolk and drive back the goblin menace.</p>
                                <div class="scenario-features">
                                    <span class="feature">Combat</span>
                                    <span class="feature">Tactics</span>
                                    <span class="feature">Community</span>
                                </div>
                            </div>

                            <div class="scenario-option" data-scenario="ancient_ruins" onclick="selectScenario('ancient_ruins')">
                                <div class="scenario-header">
                                    <h4>üèõÔ∏è The Ancient Ruins</h4>
                                    <span class="scenario-difficulty">Intermediate</span>
                                </div>
                                <p>Explore forgotten ruins filled with traps, puzzles, and ancient guardians protecting lost treasures.</p>
                                <div class="scenario-features">
                                    <span class="feature">Exploration</span>
                                    <span class="feature">Puzzles</span>
                                    <span class="feature">Treasure</span>
                                </div>
                            </div>

                            <div class="scenario-option" data-scenario="political_intrigue" onclick="selectScenario('political_intrigue')">
                                <div class="scenario-header">
                                    <h4>üëë Court of Shadows</h4>
                                    <span class="scenario-difficulty">Advanced</span>
                                </div>
                                <p>Navigate the dangerous waters of noble court politics, where words are weapons and alliances shift like shadows.</p>
                                <div class="scenario-features">
                                    <span class="feature">Roleplay</span>
                                    <span class="feature">Intrigue</span>
                                    <span class="feature">Politics</span>
                                </div>
                            </div>
                        </div>
                        <input type="hidden" id="selected-scenario" name="startingScenario" value="mysterious_caravan">
                    </div>

                    <div class="form-actions">
                        <button type="button" class="secondary-button" onclick="promptToSave('mainMenu')">
                            Cancel
                        </button>
                        <button type="submit" class="primary-button">
                            <span class="button-icon">‚ú®</span>
                            Create Campaign
                        </button>
                    </div>
                </form>
            </div>
        </div>

        <!-- API Configuration Screen -->
        <div id="apiSetup-screen" class="screen api-setup-screen">
            <div class="api-setup-container">
                <header class="screen-header">
                    <h2>üîß API Configuration</h2>
                    <p>Configure your AI services for the best D&D experience</p>
                </header>

                <div class="api-setup-content">
                    <!-- OpenAI Configuration -->
                    <div class="api-section">
                        <div class="api-header">
                            <h3>ü§ñ OpenAI (AI Dungeon Master)</h3>
                            <span class="api-status" id="openai-status">Not Configured</span>
                        </div>
                        <div class="api-description">
                            <p>Powers intelligent DM responses and story continuation. Recommended for the best experience.</p>
                            <a href="https://platform.openai.com/api-keys" target="_blank">Get your API key ‚Üí</a>
                        </div>
                        <div class="form-group">
                            <label for="setup-openai-key">API Key:</label>
                            <div class="form-row">
                                <input type="password" id="setup-openai-key" placeholder="sk-..." 
                                       value="" class="api-key-input">
                                <button type="button" onclick="testOpenAISetup()" class="test-button">Test</button>
                            </div>
                        </div>
                        <div id="openai-test-result" class="test-result"></div>
                        
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="setup-openai-enabled" checked>
                                Enable OpenAI (recommended)
                            </label>
                        </div>
                    </div>

                    <!-- ElevenLabs Configuration -->
                    <div class="api-section">
                        <div class="api-header">
                            <h3>üéµ ElevenLabs (Voice Synthesis)</h3>
                            <span class="api-status" id="elevenlabs-status">Not Configured</span>
                        </div>
                        <div class="api-description">
                            <p>High-quality AI voice for DM narration. Optional but adds immersion.</p>
                            <a href="https://elevenlabs.io/app/speech-synthesis" target="_blank">Get your API key ‚Üí</a>
                        </div>
                        <div class="form-group">
                            <label for="setup-elevenlabs-key">API Key:</label>
                            <div class="form-row">
                                <input type="password" id="setup-elevenlabs-key" placeholder="Enter your ElevenLabs API key" 
                                       value="" class="api-key-input">
                                <button type="button" onclick="testElevenLabsSetup()" class="test-button">Test</button>
                            </div>
                        </div>
                        <div id="elevenlabs-test-result" class="test-result"></div>
                        
                        <div class="form-group">
                            <label for="setup-elevenlabs-voice">Voice:</label>
                            <select id="setup-elevenlabs-voice">
                                <option value="">Test API key first</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="setup-elevenlabs-enabled">
                                Enable ElevenLabs voice (optional)
                            </label>
                        </div>
                    </div>

                    <!-- API Skip Option -->
                    <div class="api-section skip-section">
                        <div class="api-header">
                            <h3>‚ö° Quick Start</h3>
                        </div>
                        <div class="api-description">
                            <p>You can skip API setup and use basic features. APIs can be configured later in settings.</p>
                        </div>
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="skip-api-setup">
                                Skip API setup for now (use template responses)
                            </label>
                        </div>
                    </div>
                </div>

                <div class="screen-actions">
                    <button onclick="goBackToCampaignList()" class="secondary-button">‚Üê Back to Campaigns</button>
                    <button onclick="continueToCharacterSetup()" class="primary-button" id="continue-to-character-setup">
                        Continue to Character Setup ‚Üí
                    </button>
                </div>
            </div>
        </div>

        <!-- Character Setup Screen -->
        <div id="characterSetup-screen" class="screen character-setup-screen">
            <div class="character-setup-container">
                <header class="screen-header">
                    <h2>Character Setup</h2>
                    <div class="header-actions">
                        <button id="import-character-btn" class="secondary-button">Import from D&D Beyond</button>
                        <button class="close-button" onclick="promptToSave('mainMenu')">‚úï</button>
                    </div>
                </header>

                <!-- Import Character Modal -->
                <div id="import-modal" class="modal" style="display: none;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3>Import D&D Beyond Character</h3>
                            <button class="modal-close" onclick="this.closest('.modal').style.display='none'">‚úï</button>
                        </div>
                        <div class="modal-body">
                            <p>Copy and paste your character sheet text from D&D Beyond:</p>
                            <textarea id="character-import-text" placeholder="Paste your D&D Beyond character sheet here..." rows="10"></textarea>
                        </div>
                        <div class="modal-footer">
                            <button class="secondary-button" onclick="this.closest('.modal').style.display='none'">Cancel</button>
                            <button id="parse-character-btn" class="primary-button">Parse Character</button>
                        </div>
                    </div>
                </div>

                <!-- Party Management -->
                <div class="party-management">
                    <h3>Party Members</h3>
                    <div id="party-list" class="party-list">
                        <div class="empty-party">
                            <p>No characters in party. Import or create characters to get started.</p>
                            <button class="primary-button" onclick="document.getElementById('import-modal').style.display='flex'">
                                <span class="button-icon">üë•</span>
                                Add First Character
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Character Actions -->
                <div class="character-actions" id="character-actions" style="display: none;">
                    <button id="continue-to-game-btn" class="primary-button">
                        <span class="button-icon">üéÆ</span>
                        Continue to Game
                    </button>
                </div>
            </div>
        </div>

        <!-- Character Sheet Screen -->
        <div id="characterSheet-screen" class="screen character-sheet-screen">
            <div class="character-sheet-container">
                <header class="character-sheet-header">
                    <div class="character-name-section">
                        <h2 id="character-name">Character Name</h2>
                        <div class="character-basics">
                            <span id="character-class-level">Class Level</span>
                            <span id="character-race">Race</span>
                        </div>
                    </div>
                    <div class="party-switcher">
                        <select id="character-switcher">
                            <option>Select Character</option>
                        </select>
                    </div>
                    <div class="header-actions">
                        <button id="save-character-btn" class="secondary-button">Save</button>
                        <button class="close-button" onclick="promptToSave('mainMenu')">‚úï</button>
                    </div>
                </header>

                <!-- Character Sheet Tabs -->
                <div class="character-tabs">
                    <button class="tab-button active" data-tab="overview">Overview</button>
                    <button class="tab-button" data-tab="abilities">Abilities</button>
                    <button class="tab-button" data-tab="skills">Skills</button>
                    <button class="tab-button" data-tab="inventory">Inventory</button>
                    <button class="tab-button" data-tab="spells">Spells</button>
                    <button class="tab-button" data-tab="features">Features</button>
                    <button class="tab-button" data-tab="relationships">Relationships</button>
                </div>

                <!-- Tab Content -->
                <div class="tab-content">
                    <!-- Overview Tab -->
                    <div id="overview-tab" class="tab-panel active">
                        <div class="overview-grid">
                            <div class="vital-stats">
                                <h3>Vital Stats</h3>
                                <div class="stat-row">
                                    <label>Armor Class</label>
                                    <span id="ac-value">10</span>
                                </div>
                                <div class="stat-row">
                                    <label>Hit Points</label>
                                    <div class="hp-section">
                                        <input type="number" id="current-hp" min="0">
                                        <span>/</span>
                                        <span id="max-hp">1</span>
                                    </div>
                                </div>
                                <div class="stat-row">
                                    <label>Speed</label>
                                    <span id="speed-value">30 ft</span>
                                </div>
                                <div class="stat-row">
                                    <label>Proficiency Bonus</label>
                                    <span id="prof-bonus">+2</span>
                                </div>
                            </div>

                            <div class="ability-overview">
                                <h3>Ability Scores</h3>
                                <div class="ability-grid">
                                    <div class="ability-score">
                                        <div class="ability-name">STR</div>
                                        <div class="ability-value" id="str-score">10</div>
                                        <div class="ability-modifier" id="str-mod">+0</div>
                                    </div>
                                    <div class="ability-score">
                                        <div class="ability-name">DEX</div>
                                        <div class="ability-value" id="dex-score">10</div>
                                        <div class="ability-modifier" id="dex-mod">+0</div>
                                    </div>
                                    <div class="ability-score">
                                        <div class="ability-name">CON</div>
                                        <div class="ability-value" id="con-score">10</div>
                                        <div class="ability-modifier" id="con-mod">+0</div>
                                    </div>
                                    <div class="ability-score">
                                        <div class="ability-name">INT</div>
                                        <div class="ability-value" id="int-score">10</div>
                                        <div class="ability-modifier" id="int-mod">+0</div>
                                    </div>
                                    <div class="ability-score">
                                        <div class="ability-name">WIS</div>
                                        <div class="ability-value" id="wis-score">10</div>
                                        <div class="ability-modifier" id="wis-mod">+0</div>
                                    </div>
                                    <div class="ability-score">
                                        <div class="ability-name">CHA</div>
                                        <div class="ability-value" id="cha-score">10</div>
                                        <div class="ability-modifier" id="cha-mod">+0</div>
                                    </div>
                                </div>
                            </div>

                            <div class="character-info">
                                <h3>Character Information</h3>
                                <div class="info-row">
                                    <label>Background:</label>
                                    <span id="character-background">Unknown</span>
                                </div>
                                <div class="info-row">
                                    <label>Alignment:</label>
                                    <span id="character-alignment">Unknown</span>
                                </div>
                                <div class="info-row">
                                    <label>Experience:</label>
                                    <span id="character-xp">0 XP</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Abilities Tab -->
                    <div id="abilities-tab" class="tab-panel">
                        <div class="abilities-content">
                            <div class="saving-throws">
                                <h3>Saving Throws</h3>
                                <div id="saving-throws-list" class="saves-list">
                                    <!-- Populated by JavaScript -->
                                </div>
                            </div>
                            <div class="ability-details">
                                <h3>Ability Score Details</h3>
                                <div id="ability-details-list" class="ability-list">
                                    <!-- Populated by JavaScript -->
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Skills Tab -->
                    <div id="skills-tab" class="tab-panel">
                        <h3>Skills</h3>
                        <div id="skills-list" class="skills-list">
                            <!-- Populated by JavaScript -->
                        </div>
                    </div>

                    <!-- Inventory Tab -->
                    <div id="inventory-tab" class="tab-panel">
                        <div class="inventory-content">
                            <div class="weapons-section">
                                <h3>Weapons</h3>
                                <div id="weapons-list" class="equipment-list">
                                    <!-- Populated by JavaScript -->
                                </div>
                            </div>
                            <div class="armor-section">
                                <h3>Armor</h3>
                                <div id="armor-list" class="equipment-list">
                                    <!-- Populated by JavaScript -->
                                </div>
                            </div>
                            <div class="items-section">
                                <h3>Items</h3>
                                <div id="items-list" class="equipment-list">
                                    <!-- Populated by JavaScript -->
                                </div>
                            </div>
                            <div class="currency-section">
                                <h3>Currency</h3>
                                <div class="currency-grid">
                                    <div class="coin"><span class="coin-type">CP</span><span id="cp-amount">0</span></div>
                                    <div class="coin"><span class="coin-type">SP</span><span id="sp-amount">0</span></div>
                                    <div class="coin"><span class="coin-type">EP</span><span id="ep-amount">0</span></div>
                                    <div class="coin"><span class="coin-type">GP</span><span id="gp-amount">0</span></div>
                                    <div class="coin"><span class="coin-type">PP</span><span id="pp-amount">0</span></div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Spells Tab -->
                    <div id="spells-tab" class="tab-panel">
                        <div class="spells-content">
                            <div class="spellcasting-info">
                                <h3>Spellcasting</h3>
                                <div class="spell-stats">
                                    <div class="spell-stat">
                                        <label>Spellcasting Ability</label>
                                        <span id="spellcasting-ability">None</span>
                                    </div>
                                    <div class="spell-stat">
                                        <label>Spell Save DC</label>
                                        <span id="spell-save-dc">8</span>
                                    </div>
                                    <div class="spell-stat">
                                        <label>Spell Attack Bonus</label>
                                        <span id="spell-attack-bonus">+0</span>
                                    </div>
                                </div>
                            </div>
                            <div class="spell-slots">
                                <h3>Spell Slots</h3>
                                <div id="spell-slots-list" class="slots-list">
                                    <!-- Populated by JavaScript -->
                                </div>
                            </div>
                            <div class="spells-known">
                                <h3>Spells Known</h3>
                                <div id="spells-list" class="spells-list">
                                    <!-- Populated by JavaScript -->
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Features Tab -->
                    <div id="features-tab" class="tab-panel">
                        <h3>Features & Traits</h3>
                        <div id="features-list" class="features-list">
                            <!-- Populated by JavaScript -->
                        </div>
                    </div>

                    <!-- Relationships Tab -->
                    <div id="relationships-tab" class="tab-panel">
                        <div class="relationships-content">
                            <div class="backstory-section">
                                <h3>Backstory</h3>
                                <div class="backstory-item">
                                    <label>Personality Traits:</label>
                                    <div id="personality-traits" class="trait-list"></div>
                                </div>
                                <div class="backstory-item">
                                    <label>Ideals:</label>
                                    <div id="ideals" class="trait-list"></div>
                                </div>
                                <div class="backstory-item">
                                    <label>Bonds:</label>
                                    <div id="bonds" class="trait-list"></div>
                                </div>
                                <div class="backstory-item">
                                    <label>Flaws:</label>
                                    <div id="flaws" class="trait-list"></div>
                                </div>
                            </div>
                            <div class="notes-section">
                                <h3>Notes</h3>
                                <textarea id="character-notes" placeholder="Character notes and relationships..."></textarea>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- World Browser Screen -->
        <div id="worldBrowser-screen" class="screen world-browser-screen">
            <div class="world-browser-container">
                <header class="screen-header">
                    <h2>World Browser</h2>
                    <button class="close-button" onclick="promptToSave('mainMenu')">‚úï</button>
                </header>

                <!-- Search and Filters -->
                <div class="world-browser-filters">
                    <div class="search-section">
                        <input type="text" id="world-search" placeholder="Search NPCs, locations, factions, events..." class="search-input">
                        <button id="search-btn" class="search-button">üîç</button>
                    </div>
                    
                    <div class="filter-section">
                        <div class="filter-group">
                            <label>Category:</label>
                            <select id="category-filter">
                                <option value="all">All</option>
                                <option value="npcs">NPCs</option>
                                <option value="locations">Locations</option>
                                <option value="factions">Factions</option>
                                <option value="events">Events</option>
                            </select>
                        </div>
                        
                        <div class="filter-group">
                            <label>Region:</label>
                            <select id="region-filter">
                                <option value="all">All Regions</option>
                            </select>
                        </div>
                        
                        <div class="filter-group">
                            <label>Status:</label>
                            <select id="status-filter">
                                <option value="all">All</option>
                                <option value="active">Active</option>
                                <option value="inactive">Inactive</option>
                                <option value="hostile">Hostile</option>
                                <option value="friendly">Friendly</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- World Browser Tabs -->
                <div class="world-browser-tabs">
                    <button class="world-tab-button active" data-tab="all">All</button>
                    <button class="world-tab-button" data-tab="npcs">NPCs</button>
                    <button class="world-tab-button" data-tab="locations">Locations</button>
                    <button class="world-tab-button" data-tab="factions">Factions</button>
                    <button class="world-tab-button" data-tab="events">Events</button>
                    <button class="world-tab-button" data-tab="timeline">Timeline</button>
                    <button class="world-tab-button" data-tab="relationships">Relationships</button>
                </div>

                <!-- Tab Content -->
                <div class="world-tab-content">
                    <!-- All Tab -->
                    <div id="all-world-tab" class="world-tab-panel active">
                        <div id="all-results" class="world-results-grid">
                            <!-- Populated by JavaScript -->
                        </div>
                    </div>

                    <!-- NPCs Tab -->
                    <div id="npcs-world-tab" class="world-tab-panel">
                        <div class="npc-section">
                            <div class="section-header">
                                <h3>Non-Player Characters</h3>
                                <button id="add-npc-btn" class="add-button">+ Add NPC</button>
                            </div>
                            <div id="npc-results" class="npc-grid">
                                <!-- Populated by JavaScript -->
                            </div>
                        </div>
                    </div>

                    <!-- Locations Tab -->
                    <div id="locations-world-tab" class="world-tab-panel">
                        <div class="location-section">
                            <div class="section-header">
                                <h3>Locations</h3>
                                <button id="add-location-btn" class="add-button">+ Add Location</button>
                            </div>
                            <div id="location-results" class="location-grid">
                                <!-- Populated by JavaScript -->
                            </div>
                        </div>
                    </div>

                    <!-- Factions Tab -->
                    <div id="factions-world-tab" class="world-tab-panel">
                        <div class="faction-section">
                            <div class="section-header">
                                <h3>Factions</h3>
                                <button id="add-faction-btn" class="add-button">+ Add Faction</button>
                            </div>
                            <div id="faction-results" class="faction-grid">
                                <!-- Populated by JavaScript -->
                            </div>
                        </div>
                    </div>

                    <!-- Events Tab -->
                    <div id="events-world-tab" class="world-tab-panel">
                        <div class="event-section">
                            <div class="section-header">
                                <h3>Events</h3>
                                <button id="add-event-btn" class="add-button">+ Add Event</button>
                            </div>
                            <div id="event-results" class="event-list">
                                <!-- Populated by JavaScript -->
                            </div>
                        </div>
                    </div>

                    <!-- Timeline Tab -->
                    <div id="timeline-world-tab" class="world-tab-panel">
                        <div class="timeline-section">
                            <h3>Campaign Timeline</h3>
                            <div class="timeline-controls">
                                <button id="timeline-filter-major" class="timeline-filter">Major Events</button>
                                <button id="timeline-filter-all" class="timeline-filter active">All Events</button>
                                <select id="timeline-date-range">
                                    <option value="all">All Time</option>
                                    <option value="recent">Last 30 Days</option>
                                    <option value="session">Current Session</option>
                                </select>
                            </div>
                            <div id="timeline-results" class="timeline-container">
                                <!-- Populated by JavaScript -->
                            </div>
                        </div>
                    </div>

                    <!-- Relationships Tab -->
                    <div id="relationships-world-tab" class="world-tab-panel">
                        <div class="relationships-section">
                            <h3>Relationship Map</h3>
                            <div class="relationship-controls">
                                <select id="relationship-focus">
                                    <option value="all">Show All Relationships</option>
                                    <option value="party">Party Connections</option>
                                    <option value="factions">Faction Networks</option>
                                    <option value="locations">Location Connections</option>
                                </select>
                                <button id="relationship-reset" class="secondary-button">Reset View</button>
                            </div>
                            <div id="relationship-map" class="relationship-map">
                                <!-- Populated by JavaScript with visual relationship mapping -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- World Entity Detail Modal -->
        <div id="world-detail-modal" class="modal" style="display: none;">
            <div class="modal-content world-detail-content">
                <div class="modal-header">
                    <h3 id="detail-title">Entity Details</h3>
                    <button class="modal-close" onclick="this.closest('.modal').style.display='none'">‚úï</button>
                </div>
                <div class="modal-body" id="detail-body">
                    <!-- Populated by JavaScript based on entity type -->
                </div>
                <div class="modal-footer">
                    <button id="edit-entity-btn" class="secondary-button">Edit</button>
                    <button class="primary-button" onclick="this.closest('.modal').style.display='none'">Close</button>
                </div>
            </div>
        </div>

        <!-- Add/Edit Entity Modal -->
        <div id="entity-form-modal" class="modal" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">
                    <h3 id="entity-form-title">Add Entity</h3>
                    <button class="modal-close" onclick="this.closest('.modal').style.display='none'">‚úï</button>
                </div>
                <div class="modal-body">
                    <form id="entity-form">
                        <div id="entity-form-fields">
                            <!-- Populated dynamically based on entity type -->
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button class="secondary-button" onclick="this.closest('.modal').style.display='none'">Cancel</button>
                    <button id="save-entity-btn" class="primary-button">Save</button>
                </div>
            </div>
        </div>
        
        <!-- Game Screen -->
        <div id="game-screen" class="screen game-screen">
            <div class="game-container">
                <header class="game-header">
                    <h2>D&D Adventure</h2>
                    <div class="game-controls">
                        <button class="secondary-button" onclick="switchScreen('characterSheet')">üìÑ Character Sheet</button>
                        <button class="secondary-button" onclick="switchScreen('worldBrowser')">üåç World Browser</button>
                        <button class="secondary-button" onclick="openGameSettings()">‚öôÔ∏è Settings</button>
                        <button class="secondary-button" onclick="promptToSave('mainMenu')">üè† Main Menu</button>
                    </div>
                </header>
                
                <div class="game-content">
                    <!-- AI DM Conversation Interface -->
                    <div class="dm-conversation">
                        <div class="conversation-header">
                            <h3>üé≤ Adventure Story</h3>
                        </div>
                        
                        <div id="conversation-history" class="conversation-history">
                            <!-- Conversation history will be populated here -->
                        </div>
                        
                        <div class="player-input-section">
                            <div class="voice-controls">
                                <div class="voice-status">
                                    <div id="voice-status-indicator" class="voice-indicator">
                                        <span id="voice-status-text">Ready to listen</span>
                                        <div id="voice-animation" class="voice-animation"></div>
                                    </div>
                                </div>
                                
                                <div class="voice-buttons">
                                    <button id="start-listening-btn" class="voice-button primary-button" onclick="startListening()">
                                        üé§ Speak Action
                                    </button>
                                    <button id="stop-listening-btn" class="voice-button secondary-button" onclick="stopListening()" style="display: none;">
                                        ‚èπÔ∏è Stop
                                    </button>
                                    <button class="voice-button secondary-button" onclick="toggleDMVoice()">
                                        <span id="dm-voice-toggle">üîä DM Voice: ON</span>
                                    </button>
                                </div>
                            </div>
                            
                            <div class="text-fallback">
                                <details>
                                    <summary>Or type your action (fallback)</summary>
                                    <div class="input-group">
                                        <textarea id="player-input" placeholder="What do you do? Describe your actions..." rows="2"></textarea>
                                        <div class="input-actions">
                                            <button class="secondary-button" onclick="sendPlayerAction()">Send Text</button>
                                            <button class="secondary-button" onclick="rollDice()">üé≤ Roll Dice</button>
                                        </div>
                                    </div>
                                </details>
                            </div>
                        </div>
                    </div>
                    
                    <div class="game-sidebar">
                        <div class="party-status">
                            <h4>Party Status</h4>
                            <div id="game-party-list" class="game-party-list">
                                <!-- Party members will be populated here -->
                            </div>
                        </div>
                        
                        <div class="quick-actions">
                            <h4>Quick Actions</h4>
                            <div class="action-buttons">
                                <button class="action-btn" onclick="initiateAction('combat')">‚öîÔ∏è Combat</button>
                                <button class="action-btn" onclick="initiateAction('explore')">üó∫Ô∏è Explore</button>
                                <button class="action-btn" onclick="initiateAction('rest')">üèïÔ∏è Rest</button>
                                <button class="action-btn" onclick="initiateAction('inventory')">üéí Inventory</button>
                            </div>
                        </div>
                        
                        <div class="game-state">
                            <h4>Current Status</h4>
                            <div id="game-status" class="status-info">
                                <p><strong>Location:</strong> <span id="current-location">Starting Region</span></p>
                                <p><strong>Time:</strong> <span id="current-time">Morning</span></p>
                                <p><strong>Weather:</strong> <span id="current-weather">Clear</span></p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Combat System -->
        <div id="combat-screen" class="screen combat-screen" style="display: none;">
            <div class="combat-container">
                <header class="combat-header">
                    <h2>‚öîÔ∏è Combat Encounter</h2>
                    <div class="combat-controls">
                        <button class="secondary-button" onclick="endCombat()">End Combat</button>
                        <button class="secondary-button" onclick="switchScreen('game')">Back to Game</button>
                    </div>
                </header>
                
                <div class="combat-content">
                    <!-- Initiative Tracker -->
                    <div class="combat-sidebar">
                        <div class="initiative-tracker">
                            <h3>üé≤ Initiative Order</h3>
                            <div id="initiative-list" class="initiative-list">
                                <!-- Initiative entries will be populated here -->
                            </div>
                            <div class="combat-controls-bottom">
                                <button class="primary-button" onclick="nextTurn()">Next Turn</button>
                                <button class="secondary-button" onclick="rollInitiative()">Re-roll Initiative</button>
                            </div>
                        </div>
                        
                        <div class="turn-actions">
                            <h3>Current Turn Actions</h3>
                            <div id="turn-actions" class="action-economy">
                                <div class="action-slot">
                                    <span class="action-label">Action:</span>
                                    <span id="action-status" class="available">Available</span>
                                </div>
                                <div class="action-slot">
                                    <span class="action-label">Bonus Action:</span>
                                    <span id="bonus-action-status" class="available">Available</span>
                                </div>
                                <div class="action-slot">
                                    <span class="action-label">Movement:</span>
                                    <span id="movement-status" class="available">30 ft</span>
                                </div>
                                <div class="action-slot">
                                    <span class="action-label">Reaction:</span>
                                    <span id="reaction-status" class="available">Available</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="combat-actions">
                            <h3>Combat Actions</h3>
                            <div class="action-buttons">
                                <button class="action-btn attack" onclick="combatAction('attack')">‚öîÔ∏è Attack</button>
                                <button class="action-btn" onclick="combatAction('dodge')">üõ°Ô∏è Dodge</button>
                                <button class="action-btn" onclick="combatAction('dash')">üèÉ Dash</button>
                                <button class="action-btn" onclick="combatAction('help')">ü§ù Help</button>
                                <button class="action-btn" onclick="combatAction('hide')">üë§ Hide</button>
                                <button class="action-btn" onclick="combatAction('ready')">‚è≥ Ready</button>
                                <button class="action-btn" onclick="combatAction('disengage')">üèÉ‚Äç‚ôÇÔ∏è Disengage</button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Battle Map -->
                    <div class="battle-map-container">
                        <div class="battle-map-header">
                            <h3>üó∫Ô∏è Battle Map</h3>
                            <div class="map-controls">
                                <button class="secondary-button" onclick="zoomMap('in')">üîç+</button>
                                <button class="secondary-button" onclick="zoomMap('out')">üîç-</button>
                                <button class="secondary-button" onclick="centerMap()">üéØ Center</button>
                            </div>
                        </div>
                        <div id="battle-map" class="battle-map">
                            <div class="grid-overlay" id="grid-overlay"></div>
                            <div class="combatants-layer" id="combatants-layer"></div>
                        </div>
                        <div class="map-legend">
                            <div class="legend-item">
                                <div class="legend-icon player"></div>
                                <span>Player Characters</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-icon ally"></div>
                                <span>Allies</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-icon enemy"></div>
                                <span>Enemies</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-icon current-turn"></div>
                                <span>Current Turn</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Combat Log -->
                <div class="combat-log">
                    <h3>üìú Combat Log</h3>
                    <div id="combat-messages" class="combat-messages">
                        <!-- Combat messages will appear here -->
                    </div>
                </div>
            </div>
        </div>
        
        <!-- AI DM Settings Modal -->
        <div id="ai-dm-settings-modal" class="modal" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>ü§ñ AI Dungeon Master Settings</h3>
                    <button class="modal-close" onclick="this.closest('.modal').style.display='none'">‚úï</button>
                </div>
                <div class="modal-body">
                    <div class="ai-engine-selection">
                        <h4>AI Engine</h4>
                        <div class="radio-group">
                            <label>
                                <input type="radio" name="aiEngine" value="templates" checked>
                                Template-Based (Free, Basic)
                            </label>
                            <label>
                                <input type="radio" name="aiEngine" value="openai">
                                OpenAI GPT (Premium, Dynamic)
                            </label>
                        </div>
                    </div>
                    
                    <div id="openai-settings" style="display: none;">
                        <div class="form-group">
                            <label for="openai-api-key">OpenAI API Key</label>
                            <input type="password" id="openai-api-key" placeholder="sk-...">
                            <small>Get your API key from <a href="https://platform.openai.com/api-keys" target="_blank">OpenAI Platform</a></small>
                        </div>
                        
                        <div class="form-group">
                            <label for="openai-model">Model</label>
                            <select id="openai-model">
                                <option value="gpt-3.5-turbo">GPT-3.5 Turbo (Fast, Economical)</option>
                                <option value="gpt-4">GPT-4 (Best Quality)</option>
                                <option value="gpt-4-turbo-preview">GPT-4 Turbo (Fast, High Quality)</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label for="ai-creativity">Creativity Level</label>
                            <input type="range" id="ai-creativity" min="0" max="100" value="70">
                            <span id="ai-creativity-display">70%</span>
                            <small>Higher = more creative/unpredictable responses</small>
                        </div>
                        
                        <div class="form-group">
                            <label for="ai-response-length">Response Length</label>
                            <select id="ai-response-length">
                                <option value="brief">Brief (1-2 sentences)</option>
                                <option value="normal" selected>Normal (2-4 sentences)</option>
                                <option value="detailed">Detailed (4-6 sentences)</option>
                                <option value="verbose">Verbose (6+ sentences)</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="ai-use-campaign-context" checked>
                                Use Campaign Context (scenario, party, history)
                            </label>
                        </div>
                        
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="ai-use-reference-data" checked>
                                Use D&D Reference Data (monsters, rules, items)
                            </label>
                        </div>
                        
                        <button class="secondary-button" onclick="testOpenAIConnection()">Test Connection</button>
                        <div id="openai-test-result"></div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="secondary-button" onclick="this.closest('.modal').style.display='none'">Cancel</button>
                    <button class="primary-button" onclick="saveAIDMSettings()">Save Settings</button>
                </div>
            </div>
        </div>
        
        <!-- Voice Settings Modal -->
        <div id="voice-settings-modal" class="modal" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>üé§ Voice Settings</h3>
                    <button class="modal-close" onclick="this.closest('.modal').style.display='none'">‚úï</button>
                </div>
                <div class="modal-body">
                    <div class="voice-engine-selection">
                        <h4>Voice Engine</h4>
                        <div class="radio-group">
                            <label>
                                <input type="radio" name="voiceEngine" value="browser" checked>
                                Browser TTS (Free, Basic Quality)
                            </label>
                            <label>
                                <input type="radio" name="voiceEngine" value="elevenlabs">
                                ElevenLabs (Premium, High Quality)
                            </label>
                        </div>
                    </div>
                    
                    <div id="elevenlabs-settings" class="elevenlabs-settings" style="display: none;">
                        <h4>ElevenLabs Configuration</h4>
                        <div class="form-group">
                            <label for="elevenlabs-api-key">API Key:</label>
                            <input type="password" id="elevenlabs-api-key" placeholder="Enter your ElevenLabs API key" 
                                   value="${localStorage.getItem('elevenlabs_api_key') || ''}">
                            <button type="button" onclick="testElevenLabsAPI()" class="secondary-button">Test API Key</button>
                            <small>Your API key is stored locally and never sent to our servers</small>
                            <div id="elevenlabs-test-result"></div>
                        </div>
                        
                        <div class="form-group">
                            <label for="elevenlabs-voice-id">DM Voice:</label>
                            <select id="elevenlabs-voice-id">
                                <option value="">Loading voices...</option>
                            </select>
                            <button type="button" onclick="loadElevenLabsVoices()" class="secondary-button">Refresh Voices</button>
                        </div>
                        
                        <div class="form-group">
                            <label for="voice-stability">Stability (0-1):</label>
                            <input type="range" id="voice-stability" min="0" max="1" step="0.1" value="0.5">
                            <span id="stability-value">0.5</span>
                        </div>
                        
                        <div class="form-group">
                            <label for="voice-clarity">Clarity & Similarity (0-1):</label>
                            <input type="range" id="voice-clarity" min="0" max="1" step="0.1" value="0.75">
                            <span id="clarity-value">0.75</span>
                        </div>
                        
                        <div class="form-group">
                            <button type="button" onclick="testElevenLabsVoice()" class="primary-button">Test Voice</button>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="secondary-button" onclick="this.closest('.modal').style.display='none'">Cancel</button>
                    <button class="primary-button" onclick="saveVoiceSettings()">Save Settings</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Notification Container -->
    <div id="notification-container" class="notification-container"></div>

    <!-- Simple button handlers that work immediately -->
    <script>
        // Simple screen switching function that works without modules
        // Get current active screen
        function getCurrentScreen() {
            const activeScreen = document.querySelector('.screen.active');
            if (activeScreen) {
                return activeScreen.id.replace('-screen', '');
            }
            return null;
        }
        
        function switchScreen(screenName) {
            console.log('Switching to screen:', screenName);
            
            // Track navigation history (but don't duplicate consecutive entries)
            const currentScreen = getCurrentScreen();
            if (currentScreen && currentScreen !== screenName) {
                // Keep navigation history limited to last 5 screens to avoid memory issues
                if (window.navigationHistory.length >= 5) {
                    window.navigationHistory.shift();
                }
                window.navigationHistory.push(currentScreen);
                console.log('Navigation history:', window.navigationHistory);
            }
            
            // Hide all screens
            const screens = document.querySelectorAll('.screen');
            screens.forEach(screen => {
                screen.style.display = 'none';
                screen.classList.remove('active');
            });
            
            // Show the target screen
            const targetScreen = document.getElementById(screenName + '-screen');
            if (targetScreen) {
                targetScreen.style.display = 'block';
                targetScreen.classList.add('active');
                console.log('Screen shown:', screenName);
                
                // Initialize screen-specific functionality
                if (screenName === 'characterSheet') {
                    // Initialize character sheet tabs when switching to character sheet
                    setTimeout(() => {
                        initializeCharacterSheetTabs();
                        
                        // If no specific character is being viewed, show first party member
                        if (window.partyCharacters && window.partyCharacters.length > 0) {
                            populateCharacterSheet(window.partyCharacters[0]);
                        }
                    }, 100);
                }
            } else {
                console.error('Screen not found:', screenName);
            }
        }
        
        // Add click handlers when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Setting up button handlers...');
            
            // Create New Campaign button
            const createBtn = document.getElementById('create-campaign-btn');
            if (createBtn) {
                createBtn.onclick = function() {
                    console.log('Create Campaign clicked');
                    switchScreen('campaignCreation');
                };
                console.log('Create Campaign button handler attached');
            }
            
            // Continue Campaign button
            const continueBtn = document.getElementById('continue-campaign-btn');
            if (continueBtn) {
                continueBtn.onclick = function() {
                    console.log('Continue Campaign clicked');
                    showCampaignList();
                };
                console.log('Continue Campaign button handler attached');
            }
            
            // Load from GitHub button
            const githubBtn = document.getElementById('load-github-btn');
            if (githubBtn) {
                githubBtn.onclick = function() {
                    console.log('Load from GitHub clicked');
                    alert('GitHub integration will be available soon!');
                };
                console.log('GitHub button handler attached');
            }
            
            // World Browser button
            const worldBtn = document.getElementById('world-browser-btn');
            if (worldBtn) {
                worldBtn.onclick = function() {
                    console.log('World Browser clicked');
                    switchScreen('worldBrowser');
                };
                console.log('World Browser button handler attached');
            }
            
            // Settings button
            const settingsBtn = document.getElementById('settings-btn');
            if (settingsBtn) {
                settingsBtn.onclick = function() {
                    console.log('Settings clicked');
                    switchScreen('settings');
                };
                console.log('Settings button handler attached');
            }
            
            console.log('All button handlers set up');
        });
        
        // Scenario selection function
        function selectScenario(scenarioId) {
            console.log('Selecting scenario:', scenarioId);
            
            // Remove selected class from all scenarios
            const scenarios = document.querySelectorAll('.scenario-option');
            scenarios.forEach(scenario => {
                scenario.classList.remove('selected');
            });
            
            // Add selected class to clicked scenario
            const selectedScenario = document.querySelector(`[data-scenario="${scenarioId}"]`);
            if (selectedScenario) {
                selectedScenario.classList.add('selected');
                
                // Update hidden input value
                const hiddenInput = document.getElementById('selected-scenario');
                if (hiddenInput) {
                    hiddenInput.value = scenarioId;
                }
                
                console.log('Scenario selected:', scenarioId);
            }
        }
        
        // Campaign creation function
        function createCampaign(event) {
            event.preventDefault(); // Prevent form submission
            console.log('Creating campaign...');
            
            // Get form data
            const form = document.getElementById('campaign-creation-form');
            const formData = new FormData(form);
            const campaignData = {
                id: 'campaign_' + Date.now(),
                name: formData.get('campaignName'),
                worldSeed: formData.get('worldSeed'),
                moralComplexity: formData.get('moralComplexity'),
                startingRegion: formData.get('startingRegion'),
                startingScenario: formData.get('startingScenario'),
                createdDate: new Date().toISOString(),
                lastPlayed: new Date().toISOString(),
                characters: [],
                gameState: {
                    currentLocation: 'Starting Region',
                    storyProgress: 0,
                    completedQuests: [],
                    activeQuests: []
                }
            };
            
            console.log('Campaign data:', campaignData);
            
            // Save campaign to localStorage
            saveCampaign(campaignData);
            
            // Set as current campaign
            window.currentCampaign = campaignData;
            
            // Show API setup screen first for new campaigns
            switchScreen('apiSetup');
            setTimeout(() => {
                loadAPISettingsForSetup(null); // Load from localStorage since it's a new campaign
            }, 100);
            
            // Show success message
            alert('Campaign "' + campaignData.name + '" created successfully!');
        }
        
        // Save campaign to localStorage
        function saveCampaign(campaignData) {
            try {
                // Get existing campaigns
                let campaigns = JSON.parse(localStorage.getItem('dnd_campaigns')) || [];
                
                // Find existing campaign or add new one
                const existingIndex = campaigns.findIndex(c => c.id === campaignData.id);
                if (existingIndex >= 0) {
                    campaigns[existingIndex] = campaignData;
                    console.log('Updated existing campaign:', campaignData.name);
                } else {
                    campaigns.push(campaignData);
                    console.log('Added new campaign:', campaignData.name);
                }
                
                // Save to localStorage
                localStorage.setItem('dnd_campaigns', JSON.stringify(campaigns));
                console.log('Campaign saved to localStorage');
                
                return true;
            } catch (error) {
                console.error('Error saving campaign:', error);
                return false;
            }
        }
        
        // Load campaigns from localStorage
        function loadCampaigns() {
            try {
                return JSON.parse(localStorage.getItem('dnd_campaigns')) || [];
            } catch (error) {
                console.error('Error loading campaigns:', error);
                return [];
            }
        }
        
        // Save comprehensive campaign session data
        function saveCurrentCampaignData() {
            if (window.currentCampaign) {
                // Update campaign with current party data
                if (window.partyCharacters) {
                    window.currentCampaign.characters = window.partyCharacters;
                }
                
                // Save API configurations with campaign
                window.currentCampaign.apiConfig = {
                    openai: {
                        enabled: openAIConfig.enabled,
                        apiKey: openAIConfig.apiKey,
                        model: openAIConfig.model,
                        creativity: openAIConfig.creativity,
                        responseLength: openAIConfig.responseLength
                    },
                    elevenlabs: {
                        enabled: elevenLabsConfig.enabled,
                        apiKey: elevenLabsConfig.apiKey,
                        voiceId: elevenLabsConfig.voiceId,
                        stability: elevenLabsConfig.stability,
                        clarity: elevenLabsConfig.clarity
                    }
                };
                
                // Save complete game state
                window.currentCampaign.gameState = {
                    // DM state
                    dmState: {
                        currentLocation: DM_STATE.currentLocation,
                        currentScene: DM_STATE.currentScene,
                        combatActive: DM_STATE.combatActive,
                        npcsNearby: DM_STATE.npcsNearby,
                        activeNPCs: Array.from(DM_STATE.activeNPCs.entries()), // Convert Map to array
                        recentEvents: DM_STATE.recentEvents,
                        conversationHistory: DM_STATE.conversationHistory,
                        tensionLevel: DM_STATE.tensionLevel,
                        lastPlayerAction: DM_STATE.lastPlayerAction
                    },
                    // Story state  
                    storyState: {
                        currentChapter: STORY_STATE.currentChapter,
                        plotThreads: STORY_STATE.plotThreads,
                        activeQuests: STORY_STATE.activeQuests,
                        completedEvents: STORY_STATE.completedEvents,
                        worldState: STORY_STATE.worldState,
                        narrativeTension: STORY_STATE.narrativeTension,
                        storyBeats: STORY_STATE.storyBeats
                    },
                    // Conversation history from UI
                    conversationLog: getConversationHistory(),
                    // Session metadata
                    sessionData: {
                        playTime: Date.now() - (window.sessionStartTime || Date.now()),
                        actionsCount: DM_STATE.conversationHistory.length,
                        lastSaveTime: Date.now()
                    }
                };
                
                // Update last played timestamp
                window.currentCampaign.lastPlayed = new Date().toISOString();
                
                // Save to localStorage
                const success = saveCampaign(window.currentCampaign);
                if (success) {
                    console.log('Comprehensive campaign session saved');
                    return true;
                } else {
                    console.error('Failed to save campaign session');
                    return false;
                }
            }
            return false;
        }

        // ===============================
        // AUTO-SAVE SYSTEM
        // ===============================
        
        // Auto-save interval (5 minutes = 300000ms)
        const AUTO_SAVE_INTERVAL = 5 * 60 * 1000; // 5 minutes
        let autoSaveTimer = null;
        let isAutoSaveEnabled = true;
        
        // Start auto-save timer
        function startAutoSave() {
            // Clear any existing timer
            stopAutoSave();
            
            if (!isAutoSaveEnabled) {
                console.log('Auto-save is disabled');
                return;
            }
            
            console.log('Starting auto-save timer (every 5 minutes)');
            
            autoSaveTimer = setInterval(() => {
                if (window.currentCampaign) {
                    console.log('üîÑ Auto-saving campaign...');
                    const saved = saveCurrentCampaignData();
                    if (saved) {
                        console.log('‚úÖ Auto-save completed successfully');
                        // Show brief notification
                        showNotification('Campaign auto-saved', 'success', 2000);
                    } else {
                        console.error('‚ùå Auto-save failed');
                        showNotification('Auto-save failed', 'error', 3000);
                    }
                } else {
                    console.log('No active campaign to auto-save');
                }
            }, AUTO_SAVE_INTERVAL);
        }
        
        // Stop auto-save timer
        function stopAutoSave() {
            if (autoSaveTimer) {
                clearInterval(autoSaveTimer);
                autoSaveTimer = null;
                console.log('Auto-save timer stopped');
            }
        }
        
        // Enable/disable auto-save
        function setAutoSave(enabled) {
            isAutoSaveEnabled = enabled;
            if (enabled) {
                startAutoSave();
            } else {
                stopAutoSave();
            }
            console.log(`Auto-save ${enabled ? 'enabled' : 'disabled'}`);
        }
        
        // Initialize session tracking
        function initializeSession() {
            if (!window.sessionStartTime) {
                window.sessionStartTime = Date.now();
                console.log('Session started at:', new Date(window.sessionStartTime));
            }
            
            // Start auto-save when session begins
            startAutoSave();
        }
        
        // Show brief notification to user
        function showNotification(message, type = 'info', duration = 3000) {
            console.log(`[${type.toUpperCase()}] ${message}`);
            
            // Create notification element
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.textContent = message;
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${type === 'success' ? '#2e7d32' : type === 'error' ? '#c62828' : '#1565c0'};
                color: white;
                padding: 12px 24px;
                border-radius: 4px;
                box-shadow: 0 4px 8px rgba(0,0,0,0.3);
                z-index: 10000;
                font-size: 14px;
                max-width: 300px;
                opacity: 0;
                transform: translateX(100%);
                transition: all 0.3s ease;
            `;
            
            document.body.appendChild(notification);
            
            // Animate in
            setTimeout(() => {
                notification.style.opacity = '1';
                notification.style.transform = 'translateX(0)';
            }, 10);
            
            // Auto-remove after duration
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    if (notification.parentNode) {
                        document.body.removeChild(notification);
                    }
                }, 300);
            }, duration);
        }

        // Get conversation history from the UI
        function getConversationHistory() {
            const historyDiv = document.getElementById('conversation-history');
            if (!historyDiv) return [];
            
            const messages = historyDiv.querySelectorAll('.player-message, .dm-message');
            const conversationLog = [];
            
            messages.forEach((message, index) => {
                const isDM = message.classList.contains('dm-message');
                const content = message.querySelector('.message-content')?.textContent?.trim() || '';
                const timestamp = message.querySelector('.timestamp')?.textContent || new Date().toLocaleTimeString();
                
                conversationLog.push({
                    id: index,
                    type: isDM ? 'dm' : 'player',
                    content: content,
                    timestamp: timestamp,
                    html: message.outerHTML // Save full HTML for restoration
                });
            });
            
            return conversationLog;
        }

        // Load and restore campaign session state
        function loadCampaignSession(campaign) {
            if (campaign.gameState) {
                const gameState = campaign.gameState;
                
                // Restore DM state
                if (gameState.dmState) {
                    DM_STATE.currentLocation = gameState.dmState.currentLocation || 'village';
                    DM_STATE.currentScene = gameState.dmState.currentScene || 'quest_start';
                    DM_STATE.combatActive = gameState.dmState.combatActive || false;
                    DM_STATE.npcsNearby = gameState.dmState.npcsNearby || [];
                    DM_STATE.recentEvents = gameState.dmState.recentEvents || [];
                    DM_STATE.conversationHistory = gameState.dmState.conversationHistory || [];
                    DM_STATE.tensionLevel = gameState.dmState.tensionLevel || 1;
                    DM_STATE.lastPlayerAction = gameState.dmState.lastPlayerAction || '';
                    
                    // Restore activeNPCs Map from saved array
                    DM_STATE.activeNPCs.clear();
                    if (gameState.dmState.activeNPCs) {
                        gameState.dmState.activeNPCs.forEach(([key, value]) => {
                            DM_STATE.activeNPCs.set(key, value);
                        });
                    }
                }
                
                // Restore story state
                if (gameState.storyState) {
                    STORY_STATE.currentChapter = gameState.storyState.currentChapter || 'adventure_start';
                    STORY_STATE.plotThreads = gameState.storyState.plotThreads || [];
                    STORY_STATE.activeQuests = gameState.storyState.activeQuests || [];
                    STORY_STATE.completedEvents = gameState.storyState.completedEvents || [];
                    STORY_STATE.worldState = gameState.storyState.worldState || {};
                    STORY_STATE.narrativeTension = gameState.storyState.narrativeTension || 1;
                    STORY_STATE.storyBeats = gameState.storyState.storyBeats || [];
                }
                
                // Restore conversation history to UI
                if (gameState.conversationLog && gameState.conversationLog.length > 0) {
                    restoreConversationHistory(gameState.conversationLog);
                }
                
                console.log('Campaign session state restored');
                return true;
            }
            
            console.log('No saved session state found - starting fresh');
            return false;
        }

        // Restore conversation history to the UI
        function restoreConversationHistory(conversationLog) {
            const historyDiv = document.getElementById('conversation-history');
            if (!historyDiv) return;
            
            // Clear existing conversation
            historyDiv.innerHTML = '';
            
            // Restore each message
            conversationLog.forEach(logEntry => {
                const messageDiv = document.createElement('div');
                messageDiv.innerHTML = logEntry.html;
                historyDiv.appendChild(messageDiv.firstElementChild);
            });
            
            // Scroll to bottom
            historyDiv.scrollTop = historyDiv.scrollHeight;
            console.log(`Restored ${conversationLog.length} conversation messages`);
        }

        // Generate session recap using AI or template
        async function generateSessionRecap(campaign) {
            if (!campaign.gameState || !campaign.gameState.conversationLog) {
                return null;
            }
            
            const conversationLog = campaign.gameState.conversationLog;
            const lastSession = conversationLog.slice(-10); // Last 10 messages
            
            if (lastSession.length === 0) {
                return null;
            }
            
            // Try to use OpenAI for recap if available
            if (openAIConfig.enabled && openAIConfig.apiKey) {
                try {
                    const summary = lastSession.map(msg => 
                        `${msg.type === 'dm' ? 'DM' : 'Player'}: ${msg.content}`
                    ).join('\n');
                    
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${openAIConfig.apiKey}`
                        },
                        body: JSON.stringify({
                            model: 'gpt-3.5-turbo',
                            messages: [
                                {
                                    role: 'system',
                                    content: 'You are a D&D Dungeon Master. Provide a brief 2-3 sentence recap of what happened in the last session based on the conversation log. Be engaging and set up for continuing the adventure.'
                                },
                                {
                                    role: 'user',
                                    content: `Last session conversation:\n${summary}`
                                }
                            ],
                            max_tokens: 150,
                            temperature: 0.7
                        })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        return data.choices[0].message.content;
                    }
                } catch (error) {
                    console.error('Failed to generate AI recap:', error);
                }
            }
            
            // Fallback to template recap
            const dmState = campaign.gameState.dmState;
            const location = dmState?.currentLocation || 'unknown location';
            const npcs = dmState?.npcsNearby?.length > 0 ? ` You were interacting with ${dmState.npcsNearby.join(', ')}.` : '';
            const lastAction = dmState?.lastPlayerAction ? ` Your last action was: "${dmState.lastPlayerAction}".` : '';
            
            return `Welcome back, adventurers! Last session, you were in ${location}.${npcs}${lastAction} The adventure continues from where you left off. What do you do?`;
        }
        
        // Display session recap to player
        function displaySessionRecap(recap) {
            if (!recap) {
                console.log('No recap to display');
                return;
            }
            
            console.log('Displaying session recap:', recap);
            
            // Create recap message and add to conversation
            const recapHTML = `
                <div class="message dm-message session-recap">
                    <div class="message-header">
                        <span class="speaker">Dungeon Master</span>
                        <span class="timestamp">${new Date().toLocaleTimeString()}</span>
                    </div>
                    <div class="message-content">
                        <div class="recap-header">
                            <strong>üìú Session Recap</strong>
                        </div>
                        <div class="recap-content">
                            ${recap}
                        </div>
                    </div>
                    ${getDMActionButtons()}
                </div>
            `;
            
            // Add recap to conversation history
            appendToConversation(recapHTML);
            
            // Play TTS if available
            if (window.isTTSEnabled && recap) {
                speakText(recap);
            }
            
            // Add to DM conversation history for continuity
            addToConversationHistory('dm_response', recap);
            
            console.log('Session recap displayed successfully');
        }
        
        // Restore API configuration from campaign
        function restoreAPIConfiguration(campaign) {
            if (campaign.apiConfig) {
                console.log('üîß Restoring API configuration from campaign:', campaign.apiConfig);
                
                // Restore OpenAI config
                if (campaign.apiConfig.openai) {
                    openAIConfig.enabled = campaign.apiConfig.openai.enabled || false;
                    openAIConfig.apiKey = campaign.apiConfig.openai.apiKey || '';
                    openAIConfig.model = campaign.apiConfig.openai.model || 'gpt-3.5-turbo';
                    openAIConfig.creativity = campaign.apiConfig.openai.creativity || 0.7;
                    openAIConfig.responseLength = campaign.apiConfig.openai.responseLength || 150;
                    
                    // Update localStorage
                    if (openAIConfig.apiKey) {
                        localStorage.setItem('openai_api_key', openAIConfig.apiKey);
                        localStorage.setItem('openai_enabled', openAIConfig.enabled);
                    }
                    
                    console.log('‚úÖ OpenAI config restored:', openAIConfig.enabled);
                }
                
                // Restore ElevenLabs config
                if (campaign.apiConfig.elevenlabs) {
                    elevenLabsConfig.enabled = campaign.apiConfig.elevenlabs.enabled || false;
                    elevenLabsConfig.apiKey = campaign.apiConfig.elevenlabs.apiKey || '';
                    elevenLabsConfig.voiceId = campaign.apiConfig.elevenlabs.voiceId || '';
                    elevenLabsConfig.stability = campaign.apiConfig.elevenlabs.stability || 0.5;
                    elevenLabsConfig.clarity = campaign.apiConfig.elevenlabs.clarity || 0.75;
                    
                    // Update localStorage
                    if (elevenLabsConfig.apiKey) {
                        localStorage.setItem('elevenlabs_api_key', elevenLabsConfig.apiKey);
                        localStorage.setItem('elevenlabs_voice_id', elevenLabsConfig.voiceId);
                        localStorage.setItem('voice_engine', elevenLabsConfig.enabled ? 'elevenlabs' : 'browser');
                    }
                    
                    console.log('‚úÖ ElevenLabs config restored:', elevenLabsConfig.enabled);
                }
            } else {
                console.log('No API config found in campaign, using localStorage defaults');
            }
        }
        
        // Navigation context tracking
        window.navigationHistory = [];
        
        // Function to determine appropriate return screen for character sheet
        function getCharacterSheetReturnScreen() {
            // If we have a current campaign and came from the game screen, return to game
            if (window.currentCampaign && window.navigationHistory.length > 0) {
                const previousScreen = window.navigationHistory[window.navigationHistory.length - 1];
                if (previousScreen === 'game') {
                    return 'game';
                }
            }
            
            // Default to main menu
            return 'mainMenu';
        }
        
        // Prompt to save before navigating away
        function promptToSave(targetScreen) {
            // Special handling for character sheet exit
            if (targetScreen === 'mainMenu' && getCurrentScreen() === 'characterSheet') {
                const returnScreen = getCharacterSheetReturnScreen();
                if (returnScreen === 'game') {
                    // Return to game screen instead of main menu
                    switchScreen('game');
                    return;
                }
            }
            
            if (window.currentCampaign && targetScreen === 'mainMenu') {
                const shouldSave = confirm('Do you want to save your current campaign progress before returning to the main menu?');
                if (shouldSave) {
                    const saved = saveCurrentCampaignData();
                    if (saved) {
                        alert('Campaign saved successfully!');
                    } else {
                        alert('Failed to save campaign. Please try again.');
                        return; // Don't navigate if save failed
                    }
                }
                
                // Stop auto-save and clear current campaign when going to main menu
                stopAutoSave();
                window.currentCampaign = null;
                window.partyCharacters = [];
            }
            
            // Proceed with navigation
            switchScreen(targetScreen);
        }
        
        // Character parsing function
        function parseCharacterSheet() {
            const textarea = document.getElementById('character-import-text');
            const text = textarea.value.trim();
            
            if (!text) {
                alert('Please paste character sheet data first!');
                return;
            }
            
            console.log('Parsing character sheet...');
            
            try {
                const character = parseCharacterData(text);
                console.log('Parsed character:', character);
                
                // Add character to party
                addCharacterToParty(character);
                
                // Close the modal
                document.getElementById('import-modal').style.display = 'none';
                
                // Clear the textarea
                textarea.value = '';
                
                alert('Character "' + character.name + '" imported successfully!');
                
            } catch (error) {
                console.error('Error parsing character:', error);
                alert('Error parsing character sheet. Please check the format.');
            }
        }
        
        // Parse the character data from the text format
        function parseCharacterData(text) {
            const lines = text.split('\n');
            const character = {
                // Basic info
                name: '',
                class: '',
                level: 1,
                species: '',
                background: '',
                alignment: '',
                
                // Ability scores
                abilities: {
                    strength: 10, dexterity: 10, constitution: 10,
                    intelligence: 10, wisdom: 10, charisma: 10
                },
                
                // Combat stats
                combat: {
                    armorClass: 10,
                    hitPoints: { current: 1, max: 1 },
                    initiative: 0,
                    speed: 30,
                    proficiencyBonus: 2
                },
                
                // Skills and saves
                savingThrows: {},
                skills: {},
                
                // Equipment and weapons
                weapons: [],
                equipment: {},
                
                // Features and traits
                features: [],
                
                // Other data
                proficiencies: {
                    armor: '', weapons: '', tools: '', languages: ''
                },
                personality: {
                    traits: '', ideals: '', bonds: '', flaws: ''
                },
                currency: {
                    cp: 0, sp: 0, ep: 0, gp: 0, pp: 0
                }
            };
            
            let currentSection = '';
            
            for (let line of lines) {
                line = line.trim();
                
                // Skip comments and empty lines
                if (line.startsWith('#') || !line) continue;
                
                // Check for section headers
                if (line.startsWith('[') && line.endsWith(']')) {
                    currentSection = line.slice(1, -1);
                    continue;
                }
                
                // Parse key=value pairs
                if (line.includes('=')) {
                    const [key, value] = line.split('=', 2);
                    const cleanKey = key.trim();
                    const cleanValue = value.trim();
                    
                    switch (currentSection) {
                        case 'CHARACTER_INFO':
                            if (cleanKey === 'name') character.name = cleanValue;
                            else if (cleanKey === 'class') character.class = cleanValue;
                            else if (cleanKey === 'level') character.level = parseInt(cleanValue);
                            else if (cleanKey === 'species') character.species = cleanValue;
                            else if (cleanKey === 'background') character.background = cleanValue;
                            else if (cleanKey === 'alignment') character.alignment = cleanValue;
                            break;
                            
                        case 'ABILITY_SCORES':
                            if (cleanKey in character.abilities) {
                                character.abilities[cleanKey] = parseInt(cleanValue);
                            }
                            break;
                            
                        case 'COMBAT_STATS':
                            if (cleanKey === 'armor_class') character.combat.armorClass = parseInt(cleanValue);
                            else if (cleanKey === 'hit_points_max') character.combat.hitPoints.max = parseInt(cleanValue);
                            else if (cleanKey === 'hit_points_current') character.combat.hitPoints.current = parseInt(cleanValue);
                            else if (cleanKey === 'initiative') character.combat.initiative = cleanValue;
                            else if (cleanKey === 'speed') character.combat.speed = parseInt(cleanValue);
                            else if (cleanKey === 'proficiency_bonus') character.combat.proficiencyBonus = cleanValue;
                            break;
                            
                        case 'SAVING_THROWS':
                            character.savingThrows[cleanKey] = cleanValue;
                            break;
                            
                        case 'SKILLS':
                            character.skills[cleanKey] = cleanValue;
                            break;
                            
                        case 'WEAPONS':
                            if (cleanKey.startsWith('weapon_')) {
                                const weaponData = cleanValue.split(',');
                                if (weaponData.length >= 3) {
                                    character.weapons.push({
                                        name: weaponData[0],
                                        attackBonus: weaponData[1],
                                        damage: weaponData[2],
                                        properties: weaponData[3] || ''
                                    });
                                }
                            }
                            break;
                            
                        case 'EQUIPMENT':
                            if (!cleanKey.includes('_qty') && !cleanKey.includes('total_') && !cleanKey.includes('encumbered') && !cleanKey.includes('max_carry')) {
                                const equipData = cleanValue.split(',');
                                character.equipment[cleanKey] = {
                                    quantity: parseInt(equipData[0]) || 1,
                                    weight: parseInt(equipData[1]) || 0
                                };
                            }
                            break;
                            
                        case 'PROFICIENCIES':
                            if (cleanKey === 'armor') character.proficiencies.armor = cleanValue;
                            else if (cleanKey === 'weapons') character.proficiencies.weapons = cleanValue;
                            else if (cleanKey === 'tools') character.proficiencies.tools = cleanValue;
                            else if (cleanKey === 'languages') character.proficiencies.languages = cleanValue;
                            break;
                            
                        case 'PERSONALITY':
                            if (cleanKey === 'personality_traits') character.personality.traits = cleanValue;
                            else if (cleanKey === 'ideals') character.personality.ideals = cleanValue;
                            else if (cleanKey === 'bonds') character.personality.bonds = cleanValue;
                            else if (cleanKey === 'flaws') character.personality.flaws = cleanValue;
                            break;
                            
                        case 'CURRENCY':
                            if (cleanKey === 'copper_pieces') character.currency.cp = parseInt(cleanValue);
                            else if (cleanKey === 'silver_pieces') character.currency.sp = parseInt(cleanValue);
                            else if (cleanKey === 'electrum_pieces') character.currency.ep = parseInt(cleanValue);
                            else if (cleanKey === 'gold_pieces') character.currency.gp = parseInt(cleanValue);
                            else if (cleanKey === 'platinum_pieces') character.currency.pp = parseInt(cleanValue);
                            break;
                            
                        case 'FEATURES_TRAITS':
                            if (cleanValue && !cleanValue.startsWith('#')) {
                                character.features.push({
                                    name: cleanKey.replace(/_/g, ' '),
                                    description: cleanValue
                                });
                            }
                            break;
                    }
                }
            }
            
            return character;
        }
        
        // Add character to the party display
        function addCharacterToParty(character) {
            const partyList = document.getElementById('party-list');
            const emptyParty = partyList.querySelector('.empty-party');
            
            // Remove empty party message
            if (emptyParty) {
                emptyParty.remove();
            }
            
            // Remove existing "Add Another Character" button if it exists
            const existingAddBtn = partyList.querySelector('.add-another-character');
            if (existingAddBtn) {
                existingAddBtn.remove();
            }
            
            // Create character card
            const characterCard = document.createElement('div');
            characterCard.className = 'character-card';
            characterCard.innerHTML = `
                <div class="character-info">
                    <h4>${character.name}</h4>
                    <p>Level ${character.level} ${character.species} ${character.class}</p>
                    <p>AC: ${character.combat.armorClass} | HP: ${character.combat.hitPoints.current}/${character.combat.hitPoints.max}</p>
                </div>
                <div class="character-actions">
                    <button class="secondary-button" onclick="editCharacter('${character.name}')">Edit</button>
                    <button class="secondary-button" onclick="viewCharacterSheet('${character.name}')">View Sheet</button>
                    <button class="danger-button" onclick="removeCharacter('${character.name}')">Remove</button>
                </div>
            `;
            
            partyList.appendChild(characterCard);
            
            // Add "Add Another Character" button after all characters
            const addAnotherBtn = document.createElement('div');
            addAnotherBtn.className = 'add-another-character';
            addAnotherBtn.innerHTML = `
                <button class="secondary-button" onclick="document.getElementById('import-modal').style.display='flex'">
                    <span class="button-icon">‚ûï</span>
                    Add Another Character
                </button>
            `;
            partyList.appendChild(addAnotherBtn);
            
            // Show character actions section
            document.getElementById('character-actions').style.display = 'block';
            
            // Store character data (in a real app this would go to a database)
            if (!window.partyCharacters) window.partyCharacters = [];
            window.partyCharacters.push(character);
        }
        
        // Remove character from party
        function removeCharacter(characterName) {
            if (confirm(`Remove ${characterName} from the party?`)) {
                // Remove from party array
                if (window.partyCharacters) {
                    window.partyCharacters = window.partyCharacters.filter(c => c.name !== characterName);
                }
                
                // Remove from DOM
                const partyList = document.getElementById('party-list');
                const characterCards = partyList.querySelectorAll('.character-card');
                
                characterCards.forEach(card => {
                    const nameElement = card.querySelector('h4');
                    if (nameElement && nameElement.textContent === characterName) {
                        card.remove();
                    }
                });
                
                // If no characters left, show empty party message
                if (!window.partyCharacters || window.partyCharacters.length === 0) {
                    const addAnotherBtn = partyList.querySelector('.add-another-character');
                    if (addAnotherBtn) {
                        addAnotherBtn.remove();
                    }
                    
                    const emptyParty = document.createElement('div');
                    emptyParty.className = 'empty-party';
                    emptyParty.innerHTML = `
                        <p>No characters in party. Import or create characters to get started.</p>
                        <button class="primary-button" onclick="document.getElementById('import-modal').style.display='flex'">
                            <span class="button-icon">üë•</span>
                            Add First Character
                        </button>
                    `;
                    partyList.appendChild(emptyParty);
                    
                    // Hide character actions
                    document.getElementById('character-actions').style.display = 'none';
                }
            }
        }
        
        // View character sheet function
        function viewCharacterSheet(characterName) {
            const character = window.partyCharacters?.find(c => c.name === characterName);
            if (!character) {
                alert('Character not found!');
                return;
            }
            
            // Populate character sheet fields
            populateCharacterSheet(character);
            
            // Switch to character sheet screen
            switchScreen('characterSheet');
            
            // Initialize tab functionality
            setTimeout(() => {
                initializeCharacterSheetTabs();
            }, 100);
        }
        
        // ===============================
        // CHARACTER SHEET TAB SYSTEM
        // ===============================
        
        // Initialize character sheet tabs
        function initializeCharacterSheetTabs() {
            const tabButtons = document.querySelectorAll('.character-tabs .tab-button');
            
            tabButtons.forEach(button => {
                button.addEventListener('click', function() {
                    const tabName = this.getAttribute('data-tab');
                    switchCharacterTab(tabName);
                });
            });
            
            console.log('Character sheet tabs initialized');
        }
        
        // Switch character sheet tab
        function switchCharacterTab(tabName) {
            // Remove active class from all tab buttons
            const tabButtons = document.querySelectorAll('.character-tabs .tab-button');
            tabButtons.forEach(button => {
                button.classList.remove('active');
            });
            
            // Add active class to clicked tab button
            const activeButton = document.querySelector(`.character-tabs .tab-button[data-tab="${tabName}"]`);
            if (activeButton) {
                activeButton.classList.add('active');
            }
            
            // Hide all tab panels
            const tabPanels = document.querySelectorAll('.tab-panel');
            tabPanels.forEach(panel => {
                panel.classList.remove('active');
            });
            
            // Show selected tab panel
            const activePanel = document.getElementById(tabName + '-tab');
            if (activePanel) {
                activePanel.classList.add('active');
            }
            
            console.log('Switched to character sheet tab:', tabName);
        }
        
        // Populate character sheet with character data
        function populateCharacterSheet(character) {
            // Basic info
            document.getElementById('character-name').textContent = character.name;
            document.getElementById('character-class-level').textContent = `Level ${character.level} ${character.class}`;
            document.getElementById('character-race').textContent = character.species;
            
            // Combat stats
            document.getElementById('ac-value').textContent = character.combat.armorClass;
            document.getElementById('max-hp').textContent = character.combat.hitPoints.max;
            document.getElementById('current-hp').value = character.combat.hitPoints.current;
            document.getElementById('speed-value').textContent = character.combat.speed + ' ft';
            document.getElementById('prof-bonus').textContent = character.combat.proficiencyBonus;
            
            // Ability scores
            for (const [ability, score] of Object.entries(character.abilities)) {
                const modifier = Math.floor((score - 10) / 2);
                const modifierStr = modifier >= 0 ? `+${modifier}` : `${modifier}`;
                
                document.getElementById(`${ability.substring(0, 3)}-score`).textContent = score;
                document.getElementById(`${ability.substring(0, 3)}-mod`).textContent = modifierStr;
            }
            
            // Add character to switcher dropdown
            const switcher = document.getElementById('character-switcher');
            if (switcher && !Array.from(switcher.options).some(opt => opt.value === character.name)) {
                const option = document.createElement('option');
                option.value = character.name;
                option.textContent = character.name;
                option.selected = true;
                switcher.appendChild(option);
            }
            
            console.log('Character sheet populated for:', character.name);
        }
        
        // Edit character function (placeholder)
        function editCharacter(characterName) {
            alert('Edit character functionality will be available soon!');
        }
        
        // Load and display saved campaigns
        function showCampaignList() {
            const campaigns = loadCampaigns();
            const contentDiv = document.getElementById('campaign-list-content');
            
            if (campaigns.length === 0) {
                contentDiv.innerHTML = `
                    <div class="empty-state">
                        <p>No saved campaigns found.</p>
                        <button class="primary-button" onclick="switchScreen('campaignCreation')">Create New Campaign</button>
                    </div>
                `;
            } else {
                let campaignsHTML = '<div class="campaigns-grid">';
                
                campaigns.forEach(campaign => {
                    const lastPlayed = new Date(campaign.lastPlayed).toLocaleDateString();
                    const characterCount = campaign.characters ? campaign.characters.length : 0;
                    
                    campaignsHTML += `
                        <div class="campaign-card">
                            <div class="campaign-info">
                                <h3>${campaign.name}</h3>
                                <p><strong>Region:</strong> ${campaign.startingRegion}</p>
                                <p><strong>Characters:</strong> ${characterCount}</p>
                                <p><strong>Last Played:</strong> ${lastPlayed}</p>
                            </div>
                            <div class="campaign-actions">
                                <button class="primary-button" onclick="loadCampaign('${campaign.id}')">Continue</button>
                                <button class="secondary-button" onclick="deleteCampaign('${campaign.id}')">Delete</button>
                            </div>
                        </div>
                    `;
                });
                
                campaignsHTML += '</div>';
                campaignsHTML += `
                    <div class="campaign-list-actions">
                        <button class="primary-button" onclick="switchScreen('campaignCreation')">Create New Campaign</button>
                    </div>
                `;
                
                contentDiv.innerHTML = campaignsHTML;
            }
            
            switchScreen('campaignList');
        }
        
        // Load a specific campaign
        function loadCampaign(campaignId) {
            const campaigns = loadCampaigns();
            const campaign = campaigns.find(c => c.id === campaignId);
            
            if (campaign) {
                console.log('Loading campaign:', campaign.name);
                
                // Set as current campaign
                window.currentCampaign = campaign;
                
                // Restore API configuration from campaign
                restoreAPIConfiguration(campaign);
                
                // Load characters into party
                if (campaign.characters && campaign.characters.length > 0) {
                    window.partyCharacters = campaign.characters;
                    
                    // Check if this campaign has a saved session
                    if (campaign.gameState && campaign.gameState.conversationLog && campaign.gameState.conversationLog.length > 0) {
                        console.log('Found existing session data - loading saved game state');
                        
                        // Restore complete session
                        loadCampaignSession(campaign);
                        
                        // Go directly to game 
                        populateGameScreen();
                        switchScreen('game');
                        
                        // Generate and display session recap instead of starting fresh
                        setTimeout(async () => {
                            const recap = await generateSessionRecap(campaign.gameState);
                            displaySessionRecap(recap);
                        }, 500);
                    } else {
                        console.log('No session data found but has characters - show API setup before continuing');
                        
                        // Show API setup screen to confirm/update API settings
                        switchScreen('apiSetup');
                        setTimeout(() => {
                            loadAPISettingsForSetup(campaign);
                        }, 100);
                    }
                } else {
                    console.log('No characters found - show API setup first');
                    
                    // Show API setup screen before character setup
                    switchScreen('apiSetup');
                    setTimeout(() => {
                        loadAPISettingsForSetup(campaign);
                    }, 100);
                }
                
                alert('Loaded campaign: ' + campaign.name);
            } else {
                alert('Campaign not found!');
            }
        }
        
        // Delete a campaign
        function deleteCampaign(campaignId) {
            if (confirm('Are you sure you want to delete this campaign? This action cannot be undone.')) {
                let campaigns = loadCampaigns();
                campaigns = campaigns.filter(c => c.id !== campaignId);
                localStorage.setItem('dnd_campaigns', JSON.stringify(campaigns));
                
                // Refresh the campaign list
                showCampaignList();
                
                alert('Campaign deleted successfully.');
            }
        }
        
        // Continue to game function
        function continueToGame() {
            console.log('Continuing to game...');
            
            // Initialize session tracking and auto-save
            initializeSession();
            
            // Save current party to campaign
            if (window.currentCampaign) {
                saveCurrentCampaignData();
            }
            
            // Populate game screen with party data
            populateGameScreen();
            
            // Switch to game screen
            switchScreen('game');
            
            // Check if campaign has existing session data
            const campaign = window.currentCampaign;
            if (campaign && campaign.gameState && campaign.gameState.conversationLog && campaign.gameState.conversationLog.length > 0) {
                console.log('Continuing existing session...');
                
                // Restore session and show recap
                setTimeout(async () => {
                    loadCampaignSession(campaign);
                    const recap = await generateSessionRecap(campaign.gameState);
                    displaySessionRecap(recap);
                }, 500);
            } else {
                console.log('Starting new session...');
                
                // Start the adventure with opening narration for new campaigns
                setTimeout(() => {
                    startAdventureNarration();
                }, 500);
            }
        }
        
        // Populate game screen with party data
        function populateGameScreen() {
            const gamePartyList = document.getElementById('game-party-list');
            if (gamePartyList && window.partyCharacters && window.partyCharacters.length > 0) {
                gamePartyList.innerHTML = '';
                window.partyCharacters.forEach(character => {
                    const partyMember = document.createElement('div');
                    partyMember.className = 'party-member';
                    partyMember.innerHTML = `
                        <div class="member-info">
                            <strong>${character.name}</strong>
                            <span>Level ${character.level} ${character.species} ${character.class}</span>
                        </div>
                        <div class="member-stats">
                            <span>AC: ${character.combat.armorClass}</span>
                            <span>HP: ${character.combat.hitPoints.current}/${character.combat.hitPoints.max}</span>
                        </div>
                    `;
                    gamePartyList.appendChild(partyMember);
                });
            }
            
            // Initialize the adventure conversation when game screen loads
            setTimeout(() => {
                initializeVoiceSystem();
                initializeAdventure();
            }, 500);
        }
        
        // Add event listeners when DOM loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Setting up additional button handlers...');
            
            // Parse character button
            const parseBtn = document.getElementById('parse-character-btn');
            if (parseBtn) {
                parseBtn.onclick = parseCharacterSheet;
                console.log('Parse character button handler attached');
            }
            
            // Continue to game button
            const continueBtn = document.getElementById('continue-to-game-btn');
            if (continueBtn) {
                continueBtn.onclick = continueToGame;
                console.log('Continue to game button handler attached');
            }
            
            // Import character button (opens modal)
            const importBtn = document.getElementById('import-character-btn');
            if (importBtn) {
                importBtn.onclick = function() {
                    document.getElementById('import-modal').style.display = 'flex';
                };
                console.log('Import character button handler attached');
            }
            
            // Test GitHub connection button
            const testGitHubBtn = document.getElementById('test-github-connection');
            if (testGitHubBtn) {
                testGitHubBtn.onclick = function() {
                    alert('GitHub connection test - feature coming soon!');
                };
                console.log('Test GitHub connection button handler attached');
            }
            
            // Save character button
            const saveCharBtn = document.getElementById('save-character-btn');
            if (saveCharBtn) {
                saveCharBtn.onclick = function() {
                    alert('Character saved successfully!');
                };
                console.log('Save character button handler attached');
            }
            
            // World browser buttons
            const searchBtn = document.getElementById('search-btn');
            if (searchBtn) {
                searchBtn.onclick = function() {
                    const searchInput = document.getElementById('world-search');
                    alert('Searching for: ' + searchInput.value);
                };
                console.log('World search button handler attached');
            }
            
            // Add entity buttons (placeholder functionality)
            const addButtons = [
                'add-npc-btn', 'add-location-btn', 'add-faction-btn', 'add-event-btn'
            ];
            
            addButtons.forEach(btnId => {
                const btn = document.getElementById(btnId);
                if (btn) {
                    btn.onclick = function() {
                        alert('Add ' + btnId.replace('add-', '').replace('-btn', '') + ' feature coming soon!');
                    };
                    console.log(`${btnId} handler attached`);
                }
            });
            
            console.log('All additional button handlers set up');
        });
        
        // ===============================
        // VOICE SYSTEM VARIABLES
        // ===============================
        
        let voiceRecognition = null;
        let voiceSynthesis = window.speechSynthesis;
        let isDMVoiceEnabled = true;
        let isListening = false;
        let dmVoice = null;
        
        // ElevenLabs configuration
        let elevenLabsConfig = {
            apiKey: localStorage.getItem('elevenlabs_api_key') || '',
            voiceId: localStorage.getItem('elevenlabs_voice_id') || '',
            stability: parseFloat(localStorage.getItem('elevenlabs_stability')) || 0.5,
            clarity: parseFloat(localStorage.getItem('elevenlabs_clarity')) || 0.75,
            enabled: localStorage.getItem('voice_engine') === 'elevenlabs'
        };
        
        // Initialize voice system
        function initializeVoiceSystem() {
            console.log('Initializing voice system...');
            
            // Check if speech recognition is supported
            if ('speechRecognition' in window || 'webkitSpeechRecognition' in window) {
                voiceRecognition = new (window.speechRecognition || window.webkitSpeechRecognition)();
                setupSpeechRecognition();
            } else {
                console.warn('Speech recognition not supported in this browser');
                document.getElementById('start-listening-btn').disabled = true;
                document.getElementById('voice-status-text').textContent = 'Voice not supported';
            }
            
            // Setup speech synthesis voice for DM
            if (voiceSynthesis.getVoices().length === 0) {
                voiceSynthesis.addEventListener('voiceschanged', setupDMVoice);
            } else {
                setupDMVoice();
            }
        }
        
        // Setup speech recognition
        function setupSpeechRecognition() {
            voiceRecognition.continuous = false;
            voiceRecognition.interimResults = true;
            voiceRecognition.lang = 'en-US';
            
            voiceRecognition.onstart = function() {
                console.log('Voice recognition started');
                isListening = true;
                updateVoiceStatus('Listening... speak now', 'listening');
                document.getElementById('start-listening-btn').style.display = 'none';
                document.getElementById('stop-listening-btn').style.display = 'inline-block';
            };
            
            voiceRecognition.onresult = function(event) {
                let interimTranscript = '';
                let finalTranscript = '';
                
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript;
                    } else {
                        interimTranscript += transcript;
                    }
                }
                
                // Update status with interim results
                if (interimTranscript) {
                    updateVoiceStatus('Hearing: "' + interimTranscript + '"', 'processing');
                }
                
                // Process final result
                if (finalTranscript) {
                    console.log('Voice recognition result:', finalTranscript);
                    processVoiceInput(finalTranscript);
                }
            };
            
            voiceRecognition.onerror = function(event) {
                console.error('Voice recognition error:', event.error);
                updateVoiceStatus('Voice error: ' + event.error, 'error');
                resetVoiceControls();
            };
            
            voiceRecognition.onend = function() {
                console.log('Voice recognition ended');
                isListening = false;
                resetVoiceControls();
            };
        }
        
        // Setup DM voice
        function setupDMVoice() {
            const voices = voiceSynthesis.getVoices();
            
            // Prefer a good narrative voice (look for specific voices)
            dmVoice = voices.find(voice => 
                voice.name.includes('Natural') || 
                voice.name.includes('Neural') ||
                voice.name.includes('Premium') ||
                (voice.lang.startsWith('en') && voice.name.includes('Male'))
            ) || voices.find(voice => voice.lang.startsWith('en')) || voices[0];
            
            console.log('DM Voice selected:', dmVoice?.name);
        }
        
        // Voice control functions
        function startListening() {
            if (voiceRecognition && !isListening) {
                try {
                    voiceRecognition.start();
                } catch (error) {
                    console.error('Error starting voice recognition:', error);
                    updateVoiceStatus('Error starting microphone', 'error');
                }
            }
        }
        
        function stopListening() {
            if (voiceRecognition && isListening) {
                voiceRecognition.stop();
            }
        }
        
        function toggleDMVoice() {
            isDMVoiceEnabled = !isDMVoiceEnabled;
            const toggle = document.getElementById('dm-voice-toggle');
            toggle.textContent = isDMVoiceEnabled ? 'üîä DM Voice: ON' : 'üîá DM Voice: OFF';
            
            if (!isDMVoiceEnabled) {
                voiceSynthesis.cancel(); // Stop any current speech
            }
        }
        
        function updateVoiceStatus(text, status = 'ready') {
            const statusText = document.getElementById('voice-status-text');
            const indicator = document.getElementById('voice-status-indicator');
            
            statusText.textContent = text;
            indicator.className = `voice-indicator ${status}`;
        }
        
        function resetVoiceControls() {
            document.getElementById('start-listening-btn').style.display = 'inline-block';
            document.getElementById('stop-listening-btn').style.display = 'none';
            updateVoiceStatus('Ready to listen', 'ready');
        }
        
        // Process voice input from player
        function processVoiceInput(transcript) {
            console.log('Processing voice input:', transcript);
            
            // Add player message to conversation
            const playerMessage = `
                <div class="player-message voice-message">
                    <div class="message-header">
                        <strong>üé≠ ${getActiveCharacterName()}</strong>
                        <span class="voice-indicator-small">üé§</span>
                        <span class="timestamp">${new Date().toLocaleTimeString()}</span>
                    </div>
                    <div class="message-content">
                        <p>"${transcript}"</p>
                    </div>
                </div>
            `;
            
            appendToConversation(playerMessage);
            updateVoiceStatus('Processing your action...', 'processing');
            
            // Generate AI DM response
            setTimeout(() => {
                generateVoiceDMResponse(transcript);
            }, 1000);
        }
        
        // Speak text using DM voice
        function speakAsDM(text) {
            if (!isDMVoiceEnabled) return;
            
            // Use ElevenLabs if configured, otherwise fall back to browser TTS
            if (elevenLabsConfig.enabled && elevenLabsConfig.apiKey && elevenLabsConfig.voiceId) {
                generateElevenLabsSpeech(text);
            } else {
                speakAsDMBrowser(text);
            }
        }
        
        // ===============================
        // ELEVENLABS INTEGRATION
        // ===============================
        
        // Open voice settings modal
        function openVoiceSettings() {
            const modal = document.getElementById('voice-settings-modal');
            
            // Load current settings
            const engineRadios = document.querySelectorAll('input[name="voiceEngine"]');
            engineRadios.forEach(radio => {
                radio.checked = radio.value === (elevenLabsConfig.enabled ? 'elevenlabs' : 'browser');
            });
            
            // Update UI
            toggleElevenLabsSettings();
            updateSliderDisplays();
            
            // Show modal
            modal.style.display = 'flex';
            
            // Load voices if ElevenLabs is selected and API key exists
            if (elevenLabsConfig.enabled && elevenLabsConfig.apiKey) {
                loadElevenLabsVoices();
            }
        }
        
        // Toggle ElevenLabs settings visibility
        function toggleElevenLabsSettings() {
            const elevenLabsRadio = document.querySelector('input[value="elevenlabs"]');
            const elevenLabsSettings = document.getElementById('elevenlabs-settings');
            
            if (elevenLabsRadio.checked) {
                elevenLabsSettings.style.display = 'block';
            } else {
                elevenLabsSettings.style.display = 'none';
            }
        }
        
        // Update slider display values
        function updateSliderDisplays() {
            const stabilitySlider = document.getElementById('voice-stability');
            const claritySlider = document.getElementById('voice-clarity');
            
            stabilitySlider.value = elevenLabsConfig.stability;
            claritySlider.value = elevenLabsConfig.clarity;
            
            document.getElementById('stability-value').textContent = elevenLabsConfig.stability;
            document.getElementById('clarity-value').textContent = elevenLabsConfig.clarity;
            
            // Add event listeners for real-time updates
            stabilitySlider.oninput = function() {
                document.getElementById('stability-value').textContent = this.value;
            };
            claritySlider.oninput = function() {
                document.getElementById('clarity-value').textContent = this.value;
            };
        }
        
        // Load available ElevenLabs voices
        async function loadElevenLabsVoices() {
            const apiKeyInput = document.getElementById('elevenlabs-api-key');
            const apiKey = apiKeyInput ? apiKeyInput.value.trim() : elevenLabsConfig.apiKey;
            const voiceSelect = document.getElementById('elevenlabs-voice-id');
            
            if (!voiceSelect) {
                console.error('Voice select element not found');
                return;
            }
            
            if (!apiKey || apiKey.length < 10) {
                voiceSelect.innerHTML = '<option value="">Enter valid API key first</option>';
                return;
            }
            
            console.log('üéµ Loading ElevenLabs voices with API key:', apiKey.substring(0, 12) + '...');
            
            try {
                voiceSelect.innerHTML = '<option value="">Loading voices...</option>';
                
                console.log('üì° Making request to ElevenLabs voices endpoint...');
                const response = await fetch('https://api.elevenlabs.io/v1/voices', {
                    method: 'GET',
                    headers: {
                        'xi-api-key': apiKey,
                        'Accept': 'application/json'
                    }
                });
                
                console.log('üì® ElevenLabs voices API response:', response.status, response.statusText);
                console.log('üìã Response headers:', [...response.headers.entries()]);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('‚ùå ElevenLabs voices API error:', response.status, errorText);
                    throw new Error(`API Error ${response.status}: ${errorText}`);
                }
                
                const data = await response.json();
                console.log('‚úÖ ElevenLabs voices response data:', data);
                
                if (!data.voices || !Array.isArray(data.voices)) {
                    console.error('‚ùå Invalid response format:', data);
                    throw new Error('Invalid response format - no voices array found');
                }
                
                voiceSelect.innerHTML = '<option value="">Select a voice...</option>';
                
                data.voices.forEach(voice => {
                    const option = document.createElement('option');
                    option.value = voice.voice_id;
                    option.textContent = `${voice.name} (${voice.category || 'Custom'})`;
                    if (voice.voice_id === elevenLabsConfig.voiceId) {
                        option.selected = true;
                    }
                    voiceSelect.appendChild(option);
                });
                
                console.log('Successfully loaded', data.voices.length, 'ElevenLabs voices');
                
            } catch (error) {
                console.error('Error loading ElevenLabs voices:', error);
                voiceSelect.innerHTML = '<option value="">Error loading voices - check console</option>';
                
                // Show more helpful error messages
                if (error.message.includes('401')) {
                    alert('Invalid API key. Please check your ElevenLabs API key.');
                } else if (error.message.includes('403')) {
                    alert('Access forbidden. Please check your ElevenLabs subscription.');
                } else if (error.message.includes('429')) {
                    alert('Rate limit exceeded. Please wait and try again.');
                } else if (error.message.includes('CORS')) {
                    alert('CORS error - ElevenLabs API may not be accessible from this domain.');
                } else {
                    alert(`Error loading voices: ${error.message}`);
                }
            }
        }

        // Test ElevenLabs API key specifically
        async function testElevenLabsAPI() {
            const apiKeyInput = document.getElementById('elevenlabs-api-key');
            const apiKey = apiKeyInput ? apiKeyInput.value.trim() : '';
            const resultDiv = document.getElementById('elevenlabs-test-result');
            
            if (!apiKey) {
                resultDiv.innerHTML = '<span style="color: red;">Please enter an API key first</span>';
                return;
            }
            
            console.log('üîç Testing ElevenLabs API key:', apiKey.substring(0, 12) + '...');
            resultDiv.innerHTML = '<span style="color: blue;">üîÑ Testing API key...</span>';
            
            try {
                console.log('üì° Making request to ElevenLabs user endpoint...');
                const response = await fetch('https://api.elevenlabs.io/v1/user', {
                    method: 'GET',
                    headers: {
                        'xi-api-key': apiKey,
                        'Accept': 'application/json'
                    }
                });
                
                console.log('üì® ElevenLabs API response:', response.status, response.statusText);
                console.log('üìã Response headers:', [...response.headers.entries()]);
                
                if (response.ok) {
                    const userData = await response.json();
                    console.log('‚úÖ ElevenLabs user data:', userData);
                    resultDiv.innerHTML = '<span style="color: green;">‚úÖ API key valid! Loading voices...</span>';
                    
                    // Store the working API key
                    localStorage.setItem('elevenlabs_api_key', apiKey);
                    elevenLabsConfig.apiKey = apiKey;
                    
                    // Automatically load voices after successful API test
                    setTimeout(() => {
                        loadElevenLabsVoices();
                    }, 1000);
                    
                } else {
                    const errorText = await response.text();
                    console.error('‚ùå ElevenLabs API test error:', response.status, errorText);
                    
                    let errorMessage;
                    if (response.status === 401) {
                        errorMessage = '‚ùå Invalid API key - Double check your key from ElevenLabs dashboard';
                    } else if (response.status === 403) {
                        errorMessage = '‚ùå Access forbidden - Check your subscription or billing status';
                    } else if (response.status === 429) {
                        errorMessage = '‚ùå Rate limit exceeded - Wait a moment and try again';
                    } else if (response.status >= 500) {
                        errorMessage = '‚ùå ElevenLabs server error - Try again later';
                    } else {
                        errorMessage = `‚ùå API Error ${response.status}: ${errorText.substring(0, 100)}`;
                    }
                    
                    resultDiv.innerHTML = `<span style="color: red;">${errorMessage}</span>`;
                }
            } catch (error) {
                console.error('üö® API key test failed:', error);
                console.log('üîç Error details:', {
                    name: error.name,
                    message: error.message,
                    type: typeof error
                });
                
                let errorMessage;
                if (error.name === 'TypeError' && error.message.includes('Failed to fetch')) {
                    errorMessage = '‚ùå Network error - Check internet connection or try refreshing';
                } else if (error.message.includes('CORS')) {
                    errorMessage = '‚ùå CORS error - ElevenLabs may block browser requests. Try using file:// protocol';
                } else {
                    errorMessage = `‚ùå Connection failed: ${error.message}`;
                }
                
                resultDiv.innerHTML = `<span style="color: red;">${errorMessage}</span>`;
                
                // Show additional help
                if (window.location.protocol === 'file:') {
                    resultDiv.innerHTML += '<br><small style="color: orange;">üí° Try serving from localhost instead of file:// protocol</small>';
                }
            }
        }
        
        // Test ElevenLabs voice
        async function testElevenLabsVoice() {
            const apiKey = document.getElementById('elevenlabs-api-key').value;
            const voiceId = document.getElementById('elevenlabs-voice-id').value;
            
            if (!apiKey || !voiceId) {
                alert('Please enter API key and select a voice first.');
                return;
            }
            
            const testText = "Greetings, brave adventurers! I am your Dungeon Master, ready to guide you through epic tales of magic and mystery.";
            
            try {
                await generateElevenLabsSpeech(testText, apiKey, voiceId);
            } catch (error) {
                console.error('Error testing voice:', error);
                alert('Error testing voice: ' + error.message);
            }
        }
        
        // ===============================
        // VOICE GENERATION OPTIMIZATIONS
        // ===============================
        
        // Voice cache for frequently used phrases
        const voiceCache = new Map();
        const CACHE_MAX_SIZE = 50; // Limit cache size
        const MAX_CHUNK_LENGTH = 500; // Characters per chunk for long texts
        
        // Clear old cache entries when cache gets too large
        function cleanVoiceCache() {
            if (voiceCache.size > CACHE_MAX_SIZE) {
                const entries = Array.from(voiceCache.entries());
                // Remove oldest 10 entries
                for (let i = 0; i < 10; i++) {
                    const [key] = entries[i];
                    voiceCache.delete(key);
                }
                console.log('Voice cache cleaned, size:', voiceCache.size);
            }
        }
        
        // Generate cache key for text
        function getVoiceCacheKey(text, voice, stability, clarity) {
            return `${voice}_${stability}_${clarity}_${text.substring(0, 100)}`;
        }
        
        // Split long text into chunks for faster processing
        function chunkText(text, maxLength = MAX_CHUNK_LENGTH) {
            if (text.length <= maxLength) return [text];
            
            const chunks = [];
            const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
            let currentChunk = '';
            
            for (const sentence of sentences) {
                const trimmedSentence = sentence.trim();
                if (currentChunk.length + trimmedSentence.length + 1 <= maxLength) {
                    currentChunk += (currentChunk ? '. ' : '') + trimmedSentence;
                } else {
                    if (currentChunk) {
                        chunks.push(currentChunk + '.');
                        currentChunk = trimmedSentence;
                    } else {
                        // Single sentence too long, force split
                        chunks.push(trimmedSentence + '.');
                    }
                }
            }
            
            if (currentChunk) {
                chunks.push(currentChunk + '.');
            }
            
            return chunks;
        }
        
        // Generate speech using ElevenLabs API with optimizations
        async function generateElevenLabsSpeech(text, apiKey = null, voiceId = null) {
            const key = apiKey || elevenLabsConfig.apiKey;
            const voice = voiceId || elevenLabsConfig.voiceId;
            
            if (!key || !voice) {
                console.warn('ElevenLabs not configured, falling back to browser TTS');
                speakAsDMBrowser(text);
                return;
            }
            
            // Clean text for processing
            const cleanText = text.trim();
            if (!cleanText) return;
            
            try {
                updateVoiceStatus('Generating AI voice...', 'processing');
                
                // Check cache first
                const cacheKey = getVoiceCacheKey(cleanText, voice, elevenLabsConfig.stability, elevenLabsConfig.clarity);
                if (voiceCache.has(cacheKey)) {
                    console.log('üöÄ Using cached voice for:', cleanText.substring(0, 50) + '...');
                    const audioUrl = voiceCache.get(cacheKey);
                    await playAudioUrl(audioUrl);
                    return;
                }
                
                // For long texts, use chunking for faster initial playback
                if (cleanText.length > MAX_CHUNK_LENGTH) {
                    console.log('üìù Text is long, using chunked processing');
                    await generateChunkedSpeech(cleanText, key, voice);
                } else {
                    await generateSingleSpeech(cleanText, key, voice, cacheKey);
                }
                
            } catch (error) {
                console.error('ElevenLabs TTS Error:', error);
                updateVoiceStatus('Voice error, using fallback', 'error');
                
                // Fallback to browser TTS
                speakAsDMBrowser(text);
            }
        }
        
        // Generate speech for a single chunk
        async function generateSingleSpeech(text, key, voice, cacheKey) {
            const response = await fetch(`https://api.elevenlabs.io/v1/text-to-speech/${voice}`, {
                method: 'POST',
                headers: {
                    'Accept': 'audio/mpeg',
                    'Content-Type': 'application/json',
                    'xi-api-key': key
                },
                body: JSON.stringify({
                    text: text,
                    model_id: 'eleven_turbo_v2', // Use faster turbo model
                    voice_settings: {
                        stability: elevenLabsConfig.stability,
                        similarity_boost: elevenLabsConfig.clarity,
                        style: 0.0,
                        use_speaker_boost: true
                    },
                    optimize_streaming_latency: 3, // Optimize for speed
                    output_format: "mp3_44100_128" // Lower quality for speed
                })
            });
            
            if (!response.ok) {
                throw new Error(`ElevenLabs API Error: ${response.status}`);
            }
            
            const audioBlob = await response.blob();
            const audioUrl = URL.createObjectURL(audioBlob);
            
            // Cache the audio URL for reuse
            voiceCache.set(cacheKey, audioUrl);
            cleanVoiceCache();
            
            await playAudioUrl(audioUrl);
        }
        
        // Generate speech for chunked text (play chunks sequentially)
        async function generateChunkedSpeech(text, key, voice) {
            const chunks = chunkText(text);
            console.log(`üîä Processing ${chunks.length} chunks for faster playback`);
            
            for (let i = 0; i < chunks.length; i++) {
                const chunk = chunks[i];
                const chunkCacheKey = getVoiceCacheKey(chunk, voice, elevenLabsConfig.stability, elevenLabsConfig.clarity);
                
                try {
                    if (voiceCache.has(chunkCacheKey)) {
                        console.log(`üöÄ Using cached chunk ${i + 1}/${chunks.length}`);
                        const audioUrl = voiceCache.get(chunkCacheKey);
                        await playAudioUrl(audioUrl);
                    } else {
                        console.log(`üéµ Generating chunk ${i + 1}/${chunks.length}`);
                        await generateSingleSpeech(chunk, key, voice, chunkCacheKey);
                    }
                } catch (error) {
                    console.error(`Error processing chunk ${i + 1}:`, error);
                    // Continue with next chunk or fallback
                    speakAsDMBrowser(chunk);
                }
            }
        }
        
        // Play audio from URL with proper cleanup
        async function playAudioUrl(audioUrl) {
            return new Promise((resolve, reject) => {
                const audio = new Audio(audioUrl);
                
                audio.onplay = () => {
                    updateVoiceStatus('DM is speaking...', 'speaking');
                };
                
                audio.onended = () => {
                    updateVoiceStatus('Ready to listen', 'ready');
                    resolve();
                };
                
                audio.onerror = (error) => {
                    console.error('Audio playback error:', error);
                    updateVoiceStatus('Audio error', 'error');
                    reject(error);
                };
                
                audio.play().catch(reject);
            });
        }
        
        // Browser TTS fallback (rename existing function)
        function speakAsDMBrowser(text) {
            if (!voiceSynthesis) return;
            
            voiceSynthesis.cancel();
            const utterance = new SpeechSynthesisUtterance(text);
            
            if (dmVoice) {
                utterance.voice = dmVoice;
            }
            
            utterance.rate = 0.85;
            utterance.pitch = 0.8;
            utterance.volume = 0.8;
            
            utterance.onstart = () => updateVoiceStatus('DM is speaking...', 'speaking');
            utterance.onend = () => updateVoiceStatus('Ready to listen', 'ready');
            utterance.onerror = () => updateVoiceStatus('Ready to listen', 'ready');
            
            voiceSynthesis.speak(utterance);
        }
        
        // Save voice settings
        function saveVoiceSettings() {
            // Get selected engine
            const selectedEngine = document.querySelector('input[name="voiceEngine"]:checked').value;
            
            // Save to config and localStorage
            elevenLabsConfig.enabled = selectedEngine === 'elevenlabs';
            localStorage.setItem('voice_engine', selectedEngine);
            
            if (elevenLabsConfig.enabled) {
                // Save ElevenLabs settings
                elevenLabsConfig.apiKey = document.getElementById('elevenlabs-api-key').value;
                elevenLabsConfig.voiceId = document.getElementById('elevenlabs-voice-id').value;
                elevenLabsConfig.stability = parseFloat(document.getElementById('voice-stability').value);
                elevenLabsConfig.clarity = parseFloat(document.getElementById('voice-clarity').value);
                
                localStorage.setItem('elevenlabs_api_key', elevenLabsConfig.apiKey);
                localStorage.setItem('elevenlabs_voice_id', elevenLabsConfig.voiceId);
                localStorage.setItem('elevenlabs_stability', elevenLabsConfig.stability);
                localStorage.setItem('elevenlabs_clarity', elevenLabsConfig.clarity);
            }
            
            // Close modal
            document.getElementById('voice-settings-modal').style.display = 'none';
            
            // Update voice toggle display
            const toggle = document.getElementById('dm-voice-toggle');
            toggle.innerHTML = elevenLabsConfig.enabled 
                ? 'üîä DM Voice: ElevenLabs' 
                : 'üîä DM Voice: Browser';
            
            alert('Voice settings saved!');
        }
        
        // Add event listeners for voice engine radio buttons
        document.addEventListener('DOMContentLoaded', function() {
            const radioButtons = document.querySelectorAll('input[name="voiceEngine"]');
            radioButtons.forEach(radio => {
                radio.addEventListener('change', toggleElevenLabsSettings);
            });
        });
        
        // ===============================
        // API SETUP SYSTEM
        // ===============================
        
        // Test OpenAI API during setup
        async function testOpenAISetup() {
            const apiKeyInput = document.getElementById('setup-openai-key');
            const apiKey = apiKeyInput ? apiKeyInput.value.trim() : '';
            const resultDiv = document.getElementById('openai-test-result');
            const statusSpan = document.getElementById('openai-status');
            
            if (!apiKey) {
                resultDiv.innerHTML = '<span style="color: red;">Please enter an API key first</span>';
                return;
            }
            
            console.log('üîç Testing OpenAI API key during setup:', apiKey.substring(0, 12) + '...');
            resultDiv.innerHTML = '<span style="color: blue;">üîÑ Testing API key...</span>';
            statusSpan.textContent = 'Testing...';
            statusSpan.className = 'api-status testing';
            
            try {
                const response = await fetch('https://api.openai.com/v1/models', {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Accept': 'application/json'
                    }
                });
                
                console.log('üì® OpenAI models API response:', response.status, response.statusText);
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('‚úÖ OpenAI models data:', data);
                    resultDiv.innerHTML = '<span style="color: green;">‚úÖ API key valid! OpenAI is ready.</span>';
                    statusSpan.textContent = 'Configured';
                    statusSpan.className = 'api-status configured';
                    
                    // Store the working API key
                    localStorage.setItem('openai_api_key', apiKey);
                    openAIConfig.apiKey = apiKey;
                    openAIConfig.enabled = document.getElementById('setup-openai-enabled').checked;
                    localStorage.setItem('openai_enabled', openAIConfig.enabled);
                    
                } else {
                    const errorText = await response.text();
                    console.error('‚ùå OpenAI API test error:', response.status, errorText);
                    
                    let errorMessage;
                    if (response.status === 401) {
                        errorMessage = '‚ùå Invalid API key - Check your OpenAI dashboard';
                    } else if (response.status === 403) {
                        errorMessage = '‚ùå Access forbidden - Check billing or usage limits';
                    } else if (response.status === 429) {
                        errorMessage = '‚ùå Rate limit exceeded - Wait and try again';
                    } else {
                        errorMessage = `‚ùå API Error ${response.status}: ${errorText.substring(0, 100)}`;
                    }
                    
                    resultDiv.innerHTML = `<span style="color: red;">${errorMessage}</span>`;
                    statusSpan.textContent = 'Failed';
                    statusSpan.className = 'api-status';
                }
            } catch (error) {
                console.error('üö® OpenAI API test failed:', error);
                resultDiv.innerHTML = `<span style="color: red;">‚ùå Connection failed: ${error.message}</span>`;
                statusSpan.textContent = 'Failed';
                statusSpan.className = 'api-status';
            }
        }
        
        // Test ElevenLabs API during setup
        async function testElevenLabsSetup() {
            const apiKeyInput = document.getElementById('setup-elevenlabs-key');
            const apiKey = apiKeyInput ? apiKeyInput.value.trim() : '';
            const resultDiv = document.getElementById('elevenlabs-test-result');
            const statusSpan = document.getElementById('elevenlabs-status');
            const voiceSelect = document.getElementById('setup-elevenlabs-voice');
            
            if (!apiKey) {
                resultDiv.innerHTML = '<span style="color: red;">Please enter an API key first</span>';
                return;
            }
            
            console.log('üîç Testing ElevenLabs API key during setup:', apiKey.substring(0, 12) + '...');
            resultDiv.innerHTML = '<span style="color: blue;">üîÑ Testing API key...</span>';
            statusSpan.textContent = 'Testing...';
            statusSpan.className = 'api-status testing';
            
            try {
                const response = await fetch('https://api.elevenlabs.io/v1/user', {
                    method: 'GET',
                    headers: {
                        'xi-api-key': apiKey,
                        'Accept': 'application/json'
                    }
                });
                
                console.log('üì® ElevenLabs user API response:', response.status, response.statusText);
                
                if (response.ok) {
                    const userData = await response.json();
                    console.log('‚úÖ ElevenLabs user data:', userData);
                    resultDiv.innerHTML = '<span style="color: green;">‚úÖ API key valid! Loading voices...</span>';
                    statusSpan.textContent = 'Configured';
                    statusSpan.className = 'api-status configured';
                    
                    // Store the working API key
                    localStorage.setItem('elevenlabs_api_key', apiKey);
                    elevenLabsConfig.apiKey = apiKey;
                    elevenLabsConfig.enabled = document.getElementById('setup-elevenlabs-enabled').checked;
                    localStorage.setItem('voice_engine', elevenLabsConfig.enabled ? 'elevenlabs' : 'browser');
                    
                    // Load voices for selection
                    await loadVoicesForSetup(apiKey, voiceSelect);
                    
                } else {
                    const errorText = await response.text();
                    console.error('‚ùå ElevenLabs API test error:', response.status, errorText);
                    
                    let errorMessage;
                    if (response.status === 401) {
                        errorMessage = '‚ùå Invalid API key - Check your ElevenLabs dashboard';
                    } else if (response.status === 403) {
                        errorMessage = '‚ùå Access forbidden - Check subscription or billing';
                    } else if (response.status === 429) {
                        errorMessage = '‚ùå Rate limit exceeded - Wait and try again';
                    } else {
                        errorMessage = `‚ùå API Error ${response.status}: ${errorText.substring(0, 100)}`;
                    }
                    
                    resultDiv.innerHTML = `<span style="color: red;">${errorMessage}</span>`;
                    statusSpan.textContent = 'Failed';
                    statusSpan.className = 'api-status';
                }
            } catch (error) {
                console.error('üö® ElevenLabs API test failed:', error);
                resultDiv.innerHTML = `<span style="color: red;">‚ùå Connection failed: ${error.message}</span>`;
                statusSpan.textContent = 'Failed';
                statusSpan.className = 'api-status';
            }
        }
        
        // Load voices for setup screen
        async function loadVoicesForSetup(apiKey, voiceSelect) {
            try {
                console.log('üéµ Loading voices for setup...');
                
                const response = await fetch('https://api.elevenlabs.io/v1/voices', {
                    method: 'GET',
                    headers: {
                        'xi-api-key': apiKey,
                        'Accept': 'application/json'
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('‚úÖ Loaded voices for setup:', data.voices?.length);
                    
                    voiceSelect.innerHTML = '<option value="">Select a voice...</option>';
                    
                    if (data.voices && Array.isArray(data.voices)) {
                        data.voices.forEach(voice => {
                            const option = document.createElement('option');
                            option.value = voice.voice_id;
                            option.textContent = `${voice.name} (${voice.category || 'Unknown'})`;
                            voiceSelect.appendChild(option);
                        });
                        
                        // Select a good default voice for DM
                        const defaultVoice = data.voices.find(v => 
                            v.name.toLowerCase().includes('adam') || 
                            v.name.toLowerCase().includes('brian') ||
                            v.name.toLowerCase().includes('daniel')
                        );
                        if (defaultVoice) {
                            voiceSelect.value = defaultVoice.voice_id;
                        }
                    }
                } else {
                    voiceSelect.innerHTML = '<option value="">Failed to load voices</option>';
                }
            } catch (error) {
                console.error('Error loading voices for setup:', error);
                voiceSelect.innerHTML = '<option value="">Error loading voices</option>';
            }
        }
        
        // Continue to character setup with API validation
        function continueToCharacterSetup() {
            const skipSetup = document.getElementById('skip-api-setup').checked;
            const openaiEnabled = document.getElementById('setup-openai-enabled').checked;
            const elevenLabsEnabled = document.getElementById('setup-elevenlabs-enabled').checked;
            
            if (!skipSetup) {
                // Save API configurations
                if (openaiEnabled) {
                    const apiKey = document.getElementById('setup-openai-key').value.trim();
                    if (apiKey) {
                        openAIConfig.apiKey = apiKey;
                        openAIConfig.enabled = true;
                        localStorage.setItem('openai_api_key', apiKey);
                        localStorage.setItem('openai_enabled', 'true');
                    }
                }
                
                if (elevenLabsEnabled) {
                    const apiKey = document.getElementById('setup-elevenlabs-key').value.trim();
                    const voiceId = document.getElementById('setup-elevenlabs-voice').value;
                    if (apiKey) {
                        elevenLabsConfig.apiKey = apiKey;
                        elevenLabsConfig.voiceId = voiceId;
                        elevenLabsConfig.enabled = true;
                        localStorage.setItem('elevenlabs_api_key', apiKey);
                        localStorage.setItem('elevenlabs_voice_id', voiceId);
                        localStorage.setItem('voice_engine', 'elevenlabs');
                    }
                }
                
                console.log('‚úÖ API configuration saved:', {
                    openai: openAIConfig.enabled,
                    elevenlabs: elevenLabsConfig.enabled
                });
            }
            
            // Save API config to current campaign if one exists
            if (window.currentCampaign) {
                saveCurrentCampaignData();
            }
            
            // Check if campaign already has characters (returning from API setup)
            if (window.currentCampaign && window.partyCharacters && window.partyCharacters.length > 0) {
                console.log('Campaign has characters, proceeding to game...');
                // Skip character setup and go straight to game
                continueToGame();
            } else {
                console.log('No characters found, proceeding to character setup...');
                // Continue to character setup
                switchScreen('characterSetup');
            }
        }
        
        // Go back to campaign list
        function goBackToCampaignList() {
            switchScreen('campaignList');
        }
        
        // Load API settings from campaign or localStorage
        function loadAPISettingsForSetup(campaign = null) {
            // Load from campaign first, then fallback to localStorage
            if (campaign && campaign.apiConfig) {
                console.log('Loading API config from campaign:', campaign.apiConfig);
                
                // OpenAI
                if (campaign.apiConfig.openai) {
                    document.getElementById('setup-openai-key').value = campaign.apiConfig.openai.apiKey || '';
                    document.getElementById('setup-openai-enabled').checked = campaign.apiConfig.openai.enabled || false;
                    
                    if (campaign.apiConfig.openai.apiKey) {
                        document.getElementById('openai-status').textContent = 'Configured';
                        document.getElementById('openai-status').className = 'api-status configured';
                    }
                }
                
                // ElevenLabs
                if (campaign.apiConfig.elevenlabs) {
                    document.getElementById('setup-elevenlabs-key').value = campaign.apiConfig.elevenlabs.apiKey || '';
                    document.getElementById('setup-elevenlabs-voice').value = campaign.apiConfig.elevenlabs.voiceId || '';
                    document.getElementById('setup-elevenlabs-enabled').checked = campaign.apiConfig.elevenlabs.enabled || false;
                    
                    if (campaign.apiConfig.elevenlabs.apiKey) {
                        document.getElementById('elevenlabs-status').textContent = 'Configured';
                        document.getElementById('elevenlabs-status').className = 'api-status configured';
                    }
                }
            } else {
                // Load from localStorage
                console.log('Loading API config from localStorage');
                
                // OpenAI
                const openaiKey = localStorage.getItem('openai_api_key') || '';
                const openaiEnabled = localStorage.getItem('openai_enabled') === 'true';
                document.getElementById('setup-openai-key').value = openaiKey;
                document.getElementById('setup-openai-enabled').checked = openaiEnabled;
                
                if (openaiKey) {
                    document.getElementById('openai-status').textContent = 'Configured';
                    document.getElementById('openai-status').className = 'api-status configured';
                }
                
                // ElevenLabs
                const elevenLabsKey = localStorage.getItem('elevenlabs_api_key') || '';
                const elevenLabsVoice = localStorage.getItem('elevenlabs_voice_id') || '';
                const elevenLabsEnabled = localStorage.getItem('voice_engine') === 'elevenlabs';
                document.getElementById('setup-elevenlabs-key').value = elevenLabsKey;
                document.getElementById('setup-elevenlabs-voice').value = elevenLabsVoice;
                document.getElementById('setup-elevenlabs-enabled').checked = elevenLabsEnabled;
                
                if (elevenLabsKey) {
                    document.getElementById('elevenlabs-status').textContent = 'Configured';
                    document.getElementById('elevenlabs-status').className = 'api-status configured';
                }
            }
        }

        // ===============================
        // GAME SETTINGS SYSTEM
        // ===============================
        
        // Open game settings modal
        function openGameSettings() {
            const modal = document.getElementById('game-settings-modal');
            
            // Load current settings into the modal
            loadGameSettings();
            
            // Show modal
            modal.style.display = 'flex';
            
            // Show first tab by default
            showSettingsTab('ai-settings');
        }
        
        // Show specific settings tab
        function showSettingsTab(tabName) {
            // Hide all tabs
            const tabs = document.querySelectorAll('.settings-tab');
            tabs.forEach(tab => tab.classList.remove('active'));
            
            // Remove active class from all buttons
            const buttons = document.querySelectorAll('.tab-button');
            buttons.forEach(button => button.classList.remove('active'));
            
            // Show selected tab
            const selectedTab = document.getElementById(tabName + '-tab');
            if (selectedTab) {
                selectedTab.classList.add('active');
            }
            
            // Mark button as active
            const selectedButton = document.querySelector(`[onclick="showSettingsTab('${tabName}')"]`);
            if (selectedButton) {
                selectedButton.classList.add('active');
            }
            
            // Handle tab-specific logic
            if (tabName === 'voice-settings') {
                loadBrowserVoices();
            }
        }
        
        // Load current settings into the game settings modal
        function loadGameSettings() {
            console.log('Loading current settings into game settings modal');
            
            // AI Settings
            const aiEngine = openAIConfig.enabled ? 'openai' : 'template';
            document.querySelector(`input[name="gameAiEngine"][value="${aiEngine}"]`).checked = true;
            document.getElementById('game-openai-api-key').value = openAIConfig.apiKey || '';
            document.getElementById('game-ai-model').value = openAIConfig.model || 'gpt-3.5-turbo';
            document.getElementById('game-ai-creativity').value = (openAIConfig.creativity * 100) || 70;
            document.getElementById('game-ai-creativity-display').textContent = ((openAIConfig.creativity * 100) || 70) + '%';
            document.getElementById('game-ai-response-length').value = openAIConfig.responseLength || 'normal';
            
            // Show/hide OpenAI settings
            toggleGameOpenAISettings();
            
            // Voice Settings
            const voiceEngine = elevenLabsConfig.enabled ? 'elevenlabs' : 'browser';
            document.querySelector(`input[name="gameVoiceEngine"][value="${voiceEngine}"]`).checked = true;
            document.getElementById('game-elevenlabs-api-key').value = elevenLabsConfig.apiKey || '';
            document.getElementById('game-elevenlabs-voice-id').value = elevenLabsConfig.voiceId || '';
            document.getElementById('game-voice-stability').value = (elevenLabsConfig.stability * 100) || 50;
            document.getElementById('game-voice-stability-display').textContent = ((elevenLabsConfig.stability * 100) || 50) + '%';
            document.getElementById('game-voice-clarity').value = (elevenLabsConfig.clarity * 100) || 75;
            document.getElementById('game-voice-clarity-display').textContent = ((elevenLabsConfig.clarity * 100) || 75) + '%';
            
            // Show/hide voice engine settings
            toggleGameVoiceSettings();
            
            // Game Preferences
            document.getElementById('game-auto-save-enabled').checked = isAutoSaveEnabled;
            document.getElementById('game-use-campaign-context').checked = openAIConfig.useCampaignContext !== false;
            document.getElementById('game-use-reference-data').checked = openAIConfig.useReferenceData !== false;
            document.getElementById('game-show-timestamps').checked = true; // Default for now
            
            // Set up event listeners for radio buttons
            setupGameSettingsEventListeners();
        }
        
        // Set up event listeners for game settings
        function setupGameSettingsEventListeners() {
            // AI Engine radio buttons
            const aiRadios = document.querySelectorAll('input[name="gameAiEngine"]');
            aiRadios.forEach(radio => {
                radio.addEventListener('change', toggleGameOpenAISettings);
            });
            
            // Voice Engine radio buttons  
            const voiceRadios = document.querySelectorAll('input[name="gameVoiceEngine"]');
            voiceRadios.forEach(radio => {
                radio.addEventListener('change', toggleGameVoiceSettings);
            });
            
            // Range sliders
            document.getElementById('game-ai-creativity').addEventListener('input', function() {
                document.getElementById('game-ai-creativity-display').textContent = this.value + '%';
            });
            
            document.getElementById('game-voice-stability').addEventListener('input', function() {
                document.getElementById('game-voice-stability-display').textContent = this.value + '%';
            });
            
            document.getElementById('game-voice-clarity').addEventListener('input', function() {
                document.getElementById('game-voice-clarity-display').textContent = this.value + '%';
            });
            
            document.getElementById('game-voice-rate').addEventListener('input', function() {
                document.getElementById('game-voice-rate-display').textContent = this.value + 'x';
            });
            
            document.getElementById('game-voice-pitch').addEventListener('input', function() {
                document.getElementById('game-voice-pitch-display').textContent = this.value + 'x';
            });
        }
        
        // Toggle OpenAI settings visibility in game settings
        function toggleGameOpenAISettings() {
            const openaiRadio = document.querySelector('input[name="gameAiEngine"][value="openai"]');
            const openaiSettings = document.getElementById('game-openai-settings');
            
            if (openaiRadio && openaiRadio.checked) {
                openaiSettings.style.display = 'block';
            } else {
                openaiSettings.style.display = 'none';
            }
        }
        
        // Toggle voice settings visibility in game settings
        function toggleGameVoiceSettings() {
            const elevenLabsRadio = document.querySelector('input[name="gameVoiceEngine"][value="elevenlabs"]');
            const elevenLabsSettings = document.getElementById('game-elevenlabs-settings');
            const browserSettings = document.getElementById('game-browser-tts-settings');
            
            if (elevenLabsRadio && elevenLabsRadio.checked) {
                elevenLabsSettings.style.display = 'block';
                browserSettings.style.display = 'none';
            } else {
                elevenLabsSettings.style.display = 'none';
                browserSettings.style.display = 'block';
            }
        }
        
        // Load browser voices for game settings
        function loadBrowserVoices() {
            const voiceSelect = document.getElementById('game-browser-voice');
            if (!voiceSelect) return;
            
            const voices = speechSynthesis.getVoices();
            voiceSelect.innerHTML = '<option value="">Default System Voice</option>';
            
            voices.forEach(voice => {
                const option = document.createElement('option');
                option.value = voice.name;
                option.textContent = `${voice.name} (${voice.lang})`;
                voiceSelect.appendChild(option);
            });
        }
        
        // Test OpenAI in game settings
        async function testOpenAIInSettings() {
            const apiKeyInput = document.getElementById('game-openai-api-key');
            const resultDiv = document.getElementById('game-openai-test-result');
            
            // Use existing testOpenAISetup logic
            await testOpenAIAPI(apiKeyInput.value.trim(), resultDiv);
        }
        
        // Test ElevenLabs in game settings
        async function testElevenLabsInSettings() {
            const apiKeyInput = document.getElementById('game-elevenlabs-api-key');
            const resultDiv = document.getElementById('game-elevenlabs-test-result');
            
            // Use existing testElevenLabsSetup logic
            await testElevenLabsAPI(apiKeyInput.value.trim(), resultDiv);
        }
        
        // Load ElevenLabs voices in game settings
        async function loadElevenLabsVoicesInSettings() {
            const apiKey = document.getElementById('game-elevenlabs-api-key').value.trim();
            const voiceSelect = document.getElementById('game-elevenlabs-voice-id');
            
            if (!apiKey) {
                voiceSelect.innerHTML = '<option value="">Enter API key first</option>';
                return;
            }
            
            await loadVoicesForSetup(apiKey, voiceSelect);
        }
        
        // Test ElevenLabs voice in game settings
        async function testElevenLabsVoiceInSettings() {
            const apiKey = document.getElementById('game-elevenlabs-api-key').value.trim();
            const voiceId = document.getElementById('game-elevenlabs-voice-id').value;
            
            if (!apiKey || !voiceId) {
                alert('Please enter API key and select a voice first.');
                return;
            }
            
            const testText = "Greetings, adventurers! Welcome to your epic quest!";
            
            try {
                await generateElevenLabsSpeech(testText, apiKey, voiceId);
            } catch (error) {
                console.error('Error testing voice:', error);
                alert('Error testing voice: ' + error.message);
            }
        }
        
        // Helper function to test OpenAI API
        async function testOpenAIAPI(apiKey, resultDiv) {
            if (!apiKey) {
                resultDiv.innerHTML = '<span style="color: red;">Please enter an API key first</span>';
                return;
            }
            
            resultDiv.innerHTML = '<span style="color: blue;">üîÑ Testing API key...</span>';
            
            try {
                const response = await fetch('https://api.openai.com/v1/models', {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Accept': 'application/json'
                    }
                });
                
                if (response.ok) {
                    resultDiv.innerHTML = '<span style="color: green;">‚úÖ API key valid!</span>';
                } else {
                    const errorText = await response.text();
                    resultDiv.innerHTML = `<span style="color: red;">‚ùå API Error ${response.status}: ${errorText.substring(0, 100)}</span>`;
                }
            } catch (error) {
                resultDiv.innerHTML = `<span style="color: red;">‚ùå Connection failed: ${error.message}</span>`;
            }
        }
        
        // Helper function to test ElevenLabs API
        async function testElevenLabsAPI(apiKey, resultDiv) {
            if (!apiKey) {
                resultDiv.innerHTML = '<span style="color: red;">Please enter an API key first</span>';
                return;
            }
            
            resultDiv.innerHTML = '<span style="color: blue;">üîÑ Testing API key...</span>';
            
            try {
                const response = await fetch('https://api.elevenlabs.io/v1/user', {
                    method: 'GET',
                    headers: {
                        'xi-api-key': apiKey,
                        'Accept': 'application/json'
                    }
                });
                
                if (response.ok) {
                    resultDiv.innerHTML = '<span style="color: green;">‚úÖ API key valid! Loading voices...</span>';
                    
                    // Auto-load voices after successful test
                    setTimeout(async () => {
                        const voiceSelect = document.getElementById('game-elevenlabs-voice-id');
                        await loadVoicesForSetup(apiKey, voiceSelect);
                    }, 1000);
                    
                } else {
                    const errorText = await response.text();
                    resultDiv.innerHTML = `<span style="color: red;">‚ùå API Error ${response.status}: ${errorText.substring(0, 100)}</span>`;
                }
            } catch (error) {
                resultDiv.innerHTML = `<span style="color: red;">‚ùå Connection failed: ${error.message}</span>`;
            }
        }
        
        // Save game settings
        function saveGameSettings() {
            console.log('Saving game settings...');
            
            // AI Settings
            const aiEngine = document.querySelector('input[name="gameAiEngine"]:checked').value;
            openAIConfig.enabled = aiEngine === 'openai';
            
            if (openAIConfig.enabled) {
                openAIConfig.apiKey = document.getElementById('game-openai-api-key').value.trim();
                openAIConfig.model = document.getElementById('game-ai-model').value;
                openAIConfig.creativity = parseFloat(document.getElementById('game-ai-creativity').value) / 100;
                openAIConfig.responseLength = document.getElementById('game-ai-response-length').value;
                
                // Save to localStorage
                localStorage.setItem('openai_api_key', openAIConfig.apiKey);
                localStorage.setItem('openai_model', openAIConfig.model);
                localStorage.setItem('openai_creativity', openAIConfig.creativity);
                localStorage.setItem('openai_response_length', openAIConfig.responseLength);
                localStorage.setItem('openai_enabled', 'true');
            } else {
                localStorage.setItem('openai_enabled', 'false');
            }
            
            // Voice Settings
            const voiceEngine = document.querySelector('input[name="gameVoiceEngine"]:checked').value;
            elevenLabsConfig.enabled = voiceEngine === 'elevenlabs';
            
            if (elevenLabsConfig.enabled) {
                elevenLabsConfig.apiKey = document.getElementById('game-elevenlabs-api-key').value.trim();
                elevenLabsConfig.voiceId = document.getElementById('game-elevenlabs-voice-id').value;
                elevenLabsConfig.stability = parseFloat(document.getElementById('game-voice-stability').value) / 100;
                elevenLabsConfig.clarity = parseFloat(document.getElementById('game-voice-clarity').value) / 100;
                
                // Save to localStorage
                localStorage.setItem('elevenlabs_api_key', elevenLabsConfig.apiKey);
                localStorage.setItem('elevenlabs_voice_id', elevenLabsConfig.voiceId);
                localStorage.setItem('elevenlabs_stability', elevenLabsConfig.stability);
                localStorage.setItem('elevenlabs_clarity', elevenLabsConfig.clarity);
                localStorage.setItem('voice_engine', 'elevenlabs');
            } else {
                localStorage.setItem('voice_engine', 'browser');
            }
            
            // Game Preferences
            const autoSaveEnabled = document.getElementById('game-auto-save-enabled').checked;
            setAutoSave(autoSaveEnabled);
            
            openAIConfig.useCampaignContext = document.getElementById('game-use-campaign-context').checked;
            openAIConfig.useReferenceData = document.getElementById('game-use-reference-data').checked;
            localStorage.setItem('openai_use_context', openAIConfig.useCampaignContext);
            localStorage.setItem('openai_use_reference', openAIConfig.useReferenceData);
            
            // Save to current campaign
            if (window.currentCampaign) {
                saveCurrentCampaignData();
            }
            
            // Update UI elements
            updateDMVoiceToggle();
            
            // Close modal
            document.getElementById('game-settings-modal').style.display = 'none';
            
            // Show success message
            showNotification('Settings saved successfully!', 'success', 3000);
            
            console.log('‚úÖ Game settings saved:', {
                openai: openAIConfig.enabled,
                elevenlabs: elevenLabsConfig.enabled,
                autoSave: autoSaveEnabled
            });
        }
        
        // Update DM Voice toggle button text
        function updateDMVoiceToggle() {
            const toggle = document.getElementById('dm-voice-toggle');
            if (toggle) {
                if (elevenLabsConfig.enabled && elevenLabsConfig.apiKey) {
                    toggle.textContent = 'üîä DM Voice: ElevenLabs';
                } else {
                    toggle.textContent = 'üîä DM Voice: Browser';
                }
            }
        }

        // ===============================
        // AI DM CONVERSATION SYSTEM
        // ===============================
        
        // Initialize conversation when game starts
        function initializeAdventure() {
            console.log('Initializing adventure...');
            
            // Clear any existing conversation
            const history = document.getElementById('conversation-history');
            if (history) {
                history.innerHTML = '';
            }
            
            // Start with the initial story beat
            startInitialStory();
        }
        
        // Get scenario-specific opening based on selected scenario
        function getScenarioOpening(scenario) {
            const scenarioOpenings = {
                mysterious_caravan: {
                    setting: "at the last known location of a missing merchant caravan",
                    description: "Wagon tracks lead off the main road into dense woods, and scattered coins glint in the mud. The silence is unsettling.",
                    hook: "You must discover what happened to the caravan and its valuable cargo."
                },
                goblin_raids: {
                    setting: "on the outskirts of Millhaven village",
                    description: "Smoke rises from burned farms, and frightened villagers huddle behind hastily built barricades. Goblin war cries echo in the distance.",
                    hook: "The villagers desperately need your help to drive back the goblin raiders."
                },
                ancient_ruins: {
                    setting: "before the entrance to long-forgotten ruins",
                    description: "Ancient stone archways covered in mysterious runes loom before you. Strange magical energies pulse from within the depths.",
                    hook: "Legend speaks of powerful artifacts hidden within these dangerous ruins."
                },
                political_intrigue: {
                    setting: "in the grand halls of the royal palace",
                    description: "Nobles in fine clothing whisper in shadowy corners, their words dripping with hidden meanings. Trust is a luxury you cannot afford.",
                    hook: "You must navigate the treacherous waters of court politics to uncover a conspiracy."
                }
            };
            
            return scenarioOpenings[scenario] || scenarioOpenings.mysterious_caravan;
        }
        
        // Start the initial story
        function startInitialStory() {
            const campaign = window.currentCampaign;
            const characters = window.partyCharacters || [];
            const scenarioInfo = getScenarioOpening(campaign?.startingScenario || 'mysterious_caravan');
            
            // Create spoken version (cleaner for voice)
            const spokenIntro = `Welcome, brave adventurers, to ${campaign?.name || 'your epic adventure'}! 
                You find yourselves in the ${campaign?.startingRegion || 'Sword Coast'}, ${scenarioInfo.setting}. 
                ${scenarioInfo.description} 
                ${characters.length > 0 ? `Your party consists of ${characters.map(c => `${c.name}, a level ${c.level} ${c.species} ${c.class}`).join(', ')}.` : 'Your character stands ready to begin this journey.'}
                ${scenarioInfo.hook} What do you choose to do?`;
            
            let initialStory = `
                <div class="dm-message voice-message">
                    <div class="message-header">
                        <strong>üé≠ Dungeon Master</strong>
                        <span class="voice-indicator-small">üîä</span>
                        <span class="timestamp">${new Date().toLocaleTimeString()}</span>
                    </div>
                    <div class="message-content">
                        <p>Welcome, brave adventurers, to <strong>${campaign?.name || 'your epic adventure'}</strong>!</p>
                        
                        <p>You find yourselves in the <strong>${campaign?.startingRegion || 'Sword Coast'}</strong>, ${scenarioInfo.setting}.</p>
                        
                        <p>${scenarioInfo.description}</p>
                        
                        ${characters.length > 0 ? `<p>Your party consists of:</p><ul>${characters.map(c => `<li><strong>${c.name}</strong> - Level ${c.level} ${c.species} ${c.class}</li>`).join('')}</ul>` : '<p>Your character stands ready to begin this journey.</p>'}
                        
                        <p><strong>${scenarioInfo.hook}</strong></p>
                        
                        <p class="dm-prompt"><em>What do you choose to do?</em></p>
                    </div>
                </div>
            `;
            
            appendToConversation(initialStory);
            
            // Speak the introduction
            setTimeout(() => {
                speakAsDM(spokenIntro);
            }, 1000);
            
            // Update game status
            updateGameStatus(campaign?.startingRegion || 'Ancient Forest', 'Morning', 'Clear skies');
        }
        
        
        // Send player action
        function sendPlayerAction() {
            const input = document.getElementById('player-input');
            const action = input.value.trim();
            
            if (!action) {
                alert('Please enter an action first!');
                return;
            }
            
            // Add player message to conversation
            const playerMessage = `
                <div class="player-message">
                    <div class="message-header">
                        <strong>üé≠ ${getActiveCharacterName()}</strong>
                        <span class="timestamp">${new Date().toLocaleTimeString()}</span>
                    </div>
                    <div class="message-content">
                        <p>${action}</p>
                    </div>
                </div>
            `;
            
            appendToConversation(playerMessage);
            
            // Clear input
            input.value = '';
            
            // Generate AI DM response
            setTimeout(() => {
                generateDMResponse(action);
            }, 1000);
        }
        
        // Enhanced DM personality and game state
        const DM_STATE = {
            combatActive: false,
            currentLocation: 'tavern', // Track current scene location
            currentScene: 'social_interaction', // Track scene type
            npcsNearby: [], // Track active NPCs
            activeNPCs: new Map(), // Detailed NPC tracking with names and context
            recentEvents: [],
            conversationHistory: [], // Track recent conversation for continuity
            lastPlayerAction: '', // Remember what player just did
            tensionLevel: 1,
            reference: null // Will hold the DM reference data
        };

        // Load DM reference data
        async function loadDMReference() {
            try {
                const response = await fetch('dm-reference.json');
                if (response.ok) {
                    DM_STATE.reference = await response.json();
                    console.log('DM Reference loaded successfully');
                    return true;
                } else {
                    console.warn('DM Reference file not found, using default responses');
                    return false;
                }
            } catch (error) {
                console.warn('Could not load DM reference:', error);
                return false;
            }
        }

        // Initialize DM reference on page load
        loadDMReference();

        // ===============================
        // CONTEXT TRACKING SYSTEM
        // ===============================
        
        // Add NPC to current scene
        function addNPCToScene(name, description, personality = null) {
            DM_STATE.activeNPCs.set(name.toLowerCase(), {
                name: name,
                description: description,
                personality: personality,
                firstMet: Date.now(),
                lastInteraction: Date.now(),
                relationshipLevel: 'neutral',
                conversationTopics: []
            });
            
            if (!DM_STATE.npcsNearby.includes(name)) {
                DM_STATE.npcsNearby.push(name);
            }
        }

        // Update scene context
        function updateSceneContext(location, sceneType, description = '') {
            DM_STATE.currentLocation = location;
            DM_STATE.currentScene = sceneType;
            
            // Add to conversation history
            if (description) {
                addToConversationHistory('scene_change', description);
            }
        }

        // Add to conversation history for continuity
        function addToConversationHistory(type, content, speaker = null) {
            DM_STATE.conversationHistory.push({
                type: type, // 'player_action', 'dm_response', 'npc_dialogue', 'scene_change'
                content: content,
                speaker: speaker,
                timestamp: Date.now(),
                location: DM_STATE.currentLocation,
                npcsPresent: [...DM_STATE.npcsNearby]
            });
            
            // Keep only last 10 entries to avoid bloat
            if (DM_STATE.conversationHistory.length > 10) {
                DM_STATE.conversationHistory = DM_STATE.conversationHistory.slice(-10);
            }
        }

        // Get recent context for AI prompts
        function getRecentContext(maxEntries = 5) {
            return DM_STATE.conversationHistory
                .slice(-maxEntries)
                .map(entry => {
                    if (entry.type === 'player_action') {
                        return `Player: ${entry.content}`;
                    } else if (entry.type === 'dm_response') {
                        return `DM: ${entry.content}`;
                    } else if (entry.type === 'npc_dialogue') {
                        return `${entry.speaker}: ${entry.content}`;
                    } else if (entry.type === 'scene_change') {
                        return `Scene: ${entry.content}`;
                    }
                    return `${entry.type}: ${entry.content}`;
                }).join('\n');
        }

        // Check if player action should change scene
        function shouldChangeScene(playerAction) {
            const action = playerAction.toLowerCase();
            
            // Don't change scene if just talking to NPCs in current location
            if (action.includes('say') || action.includes('ask') || action.includes('tell') || 
                action.includes('talk') || action.includes('speak')) {
                return false;
            }
            
            // Only change scene if player explicitly moves or the action requires it
            if (action.includes('go to') || action.includes('leave') || action.includes('exit') ||
                action.includes('head to') || action.includes('travel')) {
                return true;
            }
            
            return false;
        }

        // Auto-detect NPCs mentioned in DM responses
        function detectAndTrackNPCs(dmResponse) {
            if (!dmResponse || typeof dmResponse !== 'string') {
                console.warn('Invalid DM response for NPC detection:', dmResponse);
                return;
            }
            
            try {
                // Look for common NPC introduction patterns
                const npcPatterns = [
                    /(?:a|an|the)\s+(\w+)\s+(?:dwarf|elf|human|halfling|orc|goblin|merchant|guard|innkeeper|bartender|knight|warrior|mage|wizard|priest|cleric)/gi,
                    /(?:named?|called)\s+([A-Z]\w+)/g,
                    /([A-Z]\w+)(?:\s+(?:the|a|an)\s+\w+)?\s+(?:says?|grumbles?|whispers?|shouts?|replies?)/g,
                    /"[^"]*"\s+(?:says?|grumbles?)\s+([A-Z]\w+)/g
                ];
                
                for (const pattern of npcPatterns) {
                    try {
                        const matches = [...dmResponse.matchAll(pattern)];
                        for (const match of matches) {
                            const npcName = match[1];
                            if (npcName && npcName.length > 2 && npcName !== 'What') { // Filter out common false positives
                                const description = extractNPCDescription(dmResponse, npcName);
                                addNPCToScene(npcName, description);
                                console.log(`Auto-detected NPC: ${npcName}`);
                            }
                        }
                    } catch (patternError) {
                        console.warn('Error processing NPC pattern:', pattern, patternError);
                    }
                }
            } catch (error) {
                console.error('Error in detectAndTrackNPCs:', error);
            }
        }

        // Extract NPC description from DM response
        function extractNPCDescription(text, npcName) {
            // Find sentences containing the NPC name and extract description
            const sentences = text.split(/[.!?]+/);
            for (const sentence of sentences) {
                if (sentence.includes(npcName)) {
                    // Look for descriptive words
                    if (sentence.includes('dwarf')) return 'dwarf';
                    if (sentence.includes('elf')) return 'elf';
                    if (sentence.includes('human')) return 'human';
                    if (sentence.includes('halfling')) return 'halfling';
                    if (sentence.includes('merchant')) return 'merchant';
                    if (sentence.includes('innkeeper')) return 'innkeeper';
                    if (sentence.includes('bartender')) return 'bartender';
                    if (sentence.includes('guard')) return 'guard';
                    if (sentence.includes('grizzled')) return 'grizzled warrior';
                    if (sentence.includes('burly')) return 'burly fighter';
                }
            }
            return 'person';
        }

        // Update scene context based on DM response and player action
        function updateSceneFromResponse(dmResponse, playerAction) {
            const action = playerAction.toLowerCase();
            const response = dmResponse.toLowerCase();
            
            // Don't change scene unless player action clearly indicates movement
            if (shouldChangeScene(playerAction)) {
                // Player wants to move - let the AI handle the scene change
                if (action.includes('fight') && !response.includes('tavern') && !response.includes('inn')) {
                    // Only if the response actually moved to combat
                    if (response.includes('forest') || response.includes('outside') || response.includes('goblins')) {
                        updateSceneContext('forest', 'combat', 'Moving to combat with goblins');
                        DM_STATE.combatActive = true;
                        DM_STATE.npcsNearby = []; // Clear NPCs when leaving location
                    }
                }
            }
            
            // Detect if we're still in the same location with NPCs
            if (response.includes('tavern') || response.includes('inn')) {
                DM_STATE.currentLocation = 'tavern';
                DM_STATE.currentScene = 'social_interaction';
            }
        }

        // ===============================
        // OPENAI INTEGRATION
        // ===============================
        
        // OpenAI configuration
        const openAIConfig = {
            enabled: false,
            apiKey: localStorage.getItem('openai_api_key') || '',
            model: localStorage.getItem('openai_model') || 'gpt-3.5-turbo',
            creativity: parseInt(localStorage.getItem('openai_creativity') || '70'),
            responseLength: localStorage.getItem('openai_response_length') || 'normal',
            useCampaignContext: localStorage.getItem('openai_use_context') !== 'false',
            useReferenceData: localStorage.getItem('openai_use_reference') !== 'false'
        };

        // Open AI DM Settings modal
        function openAIDMSettings() {
            const modal = document.getElementById('ai-dm-settings-modal');
            
            // Load current settings
            const engineRadios = document.querySelectorAll('input[name="aiEngine"]');
            engineRadios.forEach(radio => {
                radio.checked = radio.value === (openAIConfig.enabled ? 'openai' : 'templates');
            });
            
            // Set form values
            document.getElementById('openai-api-key').value = openAIConfig.apiKey;
            document.getElementById('openai-model').value = openAIConfig.model;
            document.getElementById('ai-creativity').value = openAIConfig.creativity;
            document.getElementById('ai-creativity-display').textContent = openAIConfig.creativity + '%';
            document.getElementById('ai-response-length').value = openAIConfig.responseLength;
            document.getElementById('ai-use-campaign-context').checked = openAIConfig.useCampaignContext;
            document.getElementById('ai-use-reference-data').checked = openAIConfig.useReferenceData;
            
            // Toggle OpenAI settings visibility
            toggleOpenAISettings();
            
            // Show modal
            modal.style.display = 'flex';
        }

        // Toggle OpenAI settings visibility
        function toggleOpenAISettings() {
            const openaiRadio = document.querySelector('input[value="openai"]:checked');
            const openaiSettings = document.getElementById('openai-settings');
            
            if (openaiRadio) {
                openaiSettings.style.display = 'block';
            } else {
                openaiSettings.style.display = 'none';
            }
        }

        // Save AI DM Settings
        function saveAIDMSettings() {
            const engineRadio = document.querySelector('input[name="aiEngine"]:checked');
            openAIConfig.enabled = engineRadio.value === 'openai';
            
            if (openAIConfig.enabled) {
                openAIConfig.apiKey = document.getElementById('openai-api-key').value;
                openAIConfig.model = document.getElementById('openai-model').value;
                openAIConfig.creativity = parseInt(document.getElementById('ai-creativity').value);
                openAIConfig.responseLength = document.getElementById('ai-response-length').value;
                openAIConfig.useCampaignContext = document.getElementById('ai-use-campaign-context').checked;
                openAIConfig.useReferenceData = document.getElementById('ai-use-reference-data').checked;
                
                // Save to localStorage
                localStorage.setItem('openai_enabled', 'true');
                localStorage.setItem('openai_api_key', openAIConfig.apiKey);
                localStorage.setItem('openai_model', openAIConfig.model);
                localStorage.setItem('openai_creativity', openAIConfig.creativity);
                localStorage.setItem('openai_response_length', openAIConfig.responseLength);
                localStorage.setItem('openai_use_context', openAIConfig.useCampaignContext);
                localStorage.setItem('openai_use_reference', openAIConfig.useReferenceData);
            } else {
                localStorage.setItem('openai_enabled', 'false');
            }
            
            // Close modal
            document.getElementById('ai-dm-settings-modal').style.display = 'none';
            
            alert('AI DM settings saved!');
        }

        // Test OpenAI connection
        async function testOpenAIConnection() {
            const apiKey = document.getElementById('openai-api-key').value;
            const resultDiv = document.getElementById('openai-test-result');
            
            if (!apiKey) {
                resultDiv.innerHTML = '<span style="color: red;">Please enter an API key</span>';
                return;
            }
            
            resultDiv.innerHTML = '<span style="color: yellow;">Testing connection...</span>';
            
            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-3.5-turbo',
                        messages: [
                            {
                                role: 'system',
                                content: 'You are a helpful assistant. Respond with: "Connection successful!"'
                            },
                            {
                                role: 'user',
                                content: 'Test'
                            }
                        ],
                        max_tokens: 10
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    resultDiv.innerHTML = '<span style="color: green;">‚úÖ Connection successful! API key is valid.</span>';
                } else {
                    const error = await response.json();
                    resultDiv.innerHTML = `<span style="color: red;">‚ùå Error: ${error.error?.message || 'Invalid API key'}</span>`;
                }
            } catch (error) {
                resultDiv.innerHTML = `<span style="color: red;">‚ùå Connection failed: ${error.message}</span>`;
            }
        }

        // Generate DM response using OpenAI
        async function generateOpenAIDMResponse(playerAction, context = {}) {
            if (!openAIConfig.apiKey) {
                console.warn('OpenAI API key not configured');
                return null;
            }
            
            // Track this player action
            addToConversationHistory('player_action', playerAction);
            DM_STATE.lastPlayerAction = playerAction;
            
            // Build the system prompt with enhanced context
            let systemPrompt = `You are an expert Dungeons & Dragons 5e Dungeon Master. IMPORTANT: Maintain scene continuity and don't randomly change locations or ignore NPCs without player direction.`;
            
            // Add combat rules enforcement
            if (combatState.active) {
                systemPrompt += ` COMBAT RULES ENFORCEMENT: The party is currently in combat. Each character gets ONE action, ONE bonus action (if applicable), and movement per turn. Players cannot attack multiple times or take multiple actions unless they have specific abilities that allow it. If a player tries to do more than their action economy allows, remind them of the rules and ask them to choose one action. Track initiative order and ensure proper turn-based combat. `;
                systemPrompt += ` Current turn: ${combatState.combatants[combatState.currentTurn]?.name || 'Unknown'}. Round: ${combatState.round}. `;
            }
            
            // Add current scene context
            systemPrompt += ` Current location: ${DM_STATE.currentLocation}. `;
            systemPrompt += ` Scene type: ${DM_STATE.currentScene}. `;
            
            // Add active NPCs if any
            if (DM_STATE.npcsNearby.length > 0) {
                systemPrompt += `NPCs present: ${DM_STATE.npcsNearby.join(', ')}. `;
                
                // Add detailed NPC info
                const npcDetails = [];
                for (const npcName of DM_STATE.npcsNearby) {
                    const npc = DM_STATE.activeNPCs.get(npcName.toLowerCase());
                    if (npc) {
                        npcDetails.push(`${npc.name} (${npc.description})`);
                    }
                }
                if (npcDetails.length > 0) {
                    systemPrompt += `NPC details: ${npcDetails.join('; ')}. `;
                }
            }
            
            // Add campaign context if enabled
            if (openAIConfig.useCampaignContext && window.currentCampaign) {
                const campaign = window.currentCampaign;
                systemPrompt += `Campaign: ${campaign.scenario || 'fantasy'}. `;
                systemPrompt += `Tone: ${campaign.tone || 'balanced'}. `;
                systemPrompt += `Party: ${window.partyCharacters?.length || 1} adventurers. `;
            }
            
            // Add reference data context if enabled
            if (openAIConfig.useReferenceData && DM_STATE.reference) {
                systemPrompt += `You have access to D&D 5e rules, monsters, items, and encounters. `;
            }
            
            // Add story state
            if (STORY_STATE.plotThreads.length > 0) {
                systemPrompt += `Active plot: ${STORY_STATE.plotThreads[0].description}. `;
            }
            
            // Response length guidelines
            const lengthGuides = {
                brief: 'Keep responses to 1-2 sentences.',
                normal: 'Keep responses to 2-4 sentences.',
                detailed: 'Provide detailed responses of 4-6 sentences.',
                verbose: 'Give rich, descriptive responses of 6+ sentences.'
            };
            systemPrompt += lengthGuides[openAIConfig.responseLength];
            
            systemPrompt += ` CRITICAL: Only change locations if the player explicitly says to move/leave/go somewhere. If talking to NPCs, keep the conversation going in the current location. Always end with "What do you do?" or similar engagement.`;
            
            // Build the user message with recent context
            let userMessage = `Current player action: ${playerAction}`;
            
            // Add conversation history for continuity
            const recentContext = getRecentContext(4);
            if (recentContext) {
                userMessage += `\n\nRecent conversation:\n${recentContext}`;
            }
            
            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${openAIConfig.apiKey}`
                    },
                    body: JSON.stringify({
                        model: openAIConfig.model,
                        messages: [
                            { role: 'system', content: systemPrompt },
                            { role: 'user', content: userMessage }
                        ],
                        temperature: openAIConfig.creativity / 100, // Convert to 0-1 scale
                        max_tokens: 200
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    const dmResponse = data.choices[0].message.content;
                    
                    // Track the DM response for continuity
                    addToConversationHistory('dm_response', dmResponse);
                    
                    // Auto-detect and track NPCs mentioned in the response
                    detectAndTrackNPCs(dmResponse);
                    
                    // Update scene context if needed
                    updateSceneFromResponse(dmResponse, playerAction);
                    
                    return {
                        response: dmResponse,
                        voice: dmResponse,
                        source: 'openai'
                    };
                } else {
                    console.error('OpenAI API error:', await response.text());
                    return null;
                }
            } catch (error) {
                console.error('Failed to generate OpenAI response:', error);
                return null;
            }
        }

        // Get a random encounter based on location and difficulty
        function getRandomEncounter(location = 'forest', difficulty = 'easy') {
            if (!DM_STATE.reference?.encounter_tables) return null;
            
            const encounters = DM_STATE.reference.encounter_tables[location]?.[difficulty];
            if (!encounters) return null;
            
            return encounters[Math.floor(Math.random() * encounters.length)];
        }

        // Generate a random NPC with personality
        function generateNPC() {
            if (!DM_STATE.reference?.npc_generation) return null;
            
            const npc = DM_STATE.reference.npc_generation;
            return {
                personality: npc.personalities[Math.floor(Math.random() * npc.personalities.length)],
                motivation: npc.motivations[Math.floor(Math.random() * npc.motivations.length)],
                quirk: npc.quirks[Math.floor(Math.random() * npc.quirks.length)]
            };
        }

        // Get monster stats
        function getMonsterStats(monsterName) {
            if (!DM_STATE.reference?.monsters) return null;
            
            // Search through all CR categories
            for (const crCategory of Object.values(DM_STATE.reference.monsters)) {
                if (crCategory[monsterName]) {
                    return crCategory[monsterName];
                }
            }
            return null;
        }

        // Determine skill check DC based on difficulty
        function getSkillCheckDC(difficulty = 'medium') {
            if (!DM_STATE.reference?.skill_checks?.dc_guidelines) {
                // Fallback DCs if reference not loaded
                const fallbackDCs = {
                    very_easy: 5,
                    easy: 10,
                    medium: 15,
                    hard: 20,
                    very_hard: 25
                };
                return fallbackDCs[difficulty] || 15;
            }
            
            return DM_STATE.reference.skill_checks.dc_guidelines[difficulty] || 15;
        }

        // ===============================
        // DYNAMIC STORY GENERATION SYSTEM
        // ===============================
        
        // Story state tracking
        const STORY_STATE = {
            currentChapter: 'opening',
            plotThreads: [],
            activeQuests: [],
            completedEvents: [],
            worldState: {},
            narrativeTension: 1,
            storyBeats: []
        };

        // Generate dynamic story hooks based on context
        function generateStoryHook() {
            const hooks = [
                {
                    type: 'mystery',
                    hooks: [
                        "Strange disappearances have plagued the nearby village - livestock vanishing without a trace, and now people...",
                        "An ancient map was discovered in the wall of the old tavern during renovations, marking a location that shouldn't exist...",
                        "Every full moon, ghostly music echoes from the abandoned manor on the hill. Last night wasn't a full moon..."
                    ]
                },
                {
                    type: 'danger',
                    hooks: [
                        "Smoke rises on the horizon - the peaceful hamlet you were heading to appears to be under attack!",
                        "A blood-curdling scream pierces the night, followed by an unnatural silence that sets your teeth on edge...",
                        "The bridge ahead has been destroyed, and fresh tracks suggest it wasn't an accident. Someone doesn't want you to cross..."
                    ]
                },
                {
                    type: 'opportunity',
                    hooks: [
                        "A wealthy merchant's caravan lies overturned beside the road, goods scattered but no bodies in sight...",
                        "You stumble upon a hidden entrance behind a waterfall, ancient runes glowing faintly around its edges...",
                        "A dying knight presses a sealed letter into your hands, gasping 'The king... must not... know...' before expiring..."
                    ]
                },
                {
                    type: 'social',
                    hooks: [
                        "Two rival factions approach your group simultaneously, each demanding you choose a side in their conflict...",
                        "A mysterious figure in fine robes has been asking about you by name in every tavern in town...",
                        "The local lord has heard of your exploits and 'requests' your presence at court immediately..."
                    ]
                }
            ];
            
            const selectedType = hooks[Math.floor(Math.random() * hooks.length)];
            const selectedHook = selectedType.hooks[Math.floor(Math.random() * selectedType.hooks.length)];
            
            return {
                type: selectedType.type,
                description: selectedHook
            };
        }

        // Create opening narration based on campaign scenario
        function startAdventureNarration() {
            const campaign = window.currentCampaign || {};
            const scenario = campaign.scenario || 'forgotten_realms';
            const party = window.partyCharacters || [];
            
            // Build personalized opening based on scenario
            let opening = "";
            let voiceOpening = "";
            
            // Scenario-specific openings
            const scenarioOpenings = {
                forgotten_realms: {
                    text: "The sun rises over the Sword Coast as your party gathers at the crossroads outside Waterdeep. The morning mist clings to the cobblestones, and merchants are already hawking their wares.",
                    voice: "Welcome, brave adventurers, to the Forgotten Realms! The sun rises over the Sword Coast as your party gathers at the crossroads outside Waterdeep. The morning mist clings to the ancient cobblestones, and merchants are already hawking their wares. The city of splendors awaits, but your destiny lies elsewhere..."
                },
                ravenloft: {
                    text: "The mists part reluctantly, revealing a land shrouded in perpetual twilight. Barovia stretches before you, a realm where hope itself seems a distant memory.",
                    voice: "Welcome... to Barovia. The mists have chosen you, though whether for salvation or damnation remains to be seen. The land itself watches your every move, and somewhere in the distance, a wolf howls - or was it something worse? You stand at the gates of a realm where nightmares walk freely..."
                },
                eberron: {
                    text: "The lightning rail hisses to a stop at Sharn Station. The City of Towers stretches impossibly high above and deep below, magical lights dancing between the spires.",
                    voice: "Welcome to Eberron, where magic and technology intertwine! The lightning rail hisses to a stop at Sharn Station. The City of Towers stretches impossibly high above you and deep below, with bridges of magical force connecting the massive spires. Adventure awaits in every shadow of this city of wonders!"
                },
                spelljammer: {
                    text: "Your spelljamming vessel drifts through the phlogiston, the rainbow-colored chaotic matter swirling outside the crystal sphere. A new world awaits.",
                    voice: "Greetings, spacefarers! Your spelljamming vessel glides through the rainbow chaos of the phlogiston. The helm thrums with magical energy beneath your feet, and through the viewport, you can see a new crystal sphere approaching. What wonders and terrors await in this uncharted realm of wildspace?"
                },
                custom: {
                    text: "Your adventure begins at a crossroads, both literal and metaphorical. The path ahead promises danger, glory, and discoveries beyond imagination.",
                    voice: "Welcome, heroes, to a world of infinite possibilities! Your journey begins here, at this fateful moment when ordinary lives transform into legend. The very air seems to thrum with potential. What tale will you write in the annals of history?"
                }
            };
            
            const selectedOpening = scenarioOpenings[scenario] || scenarioOpenings.custom;
            opening = selectedOpening.text;
            voiceOpening = selectedOpening.voice;
            
            // Add a story hook
            const hook = generateStoryHook();
            opening += ` ${hook.description}`;
            voiceOpening += ` ${hook.description}`;
            
            // Add party-specific flavor
            if (party.length > 0) {
                const partySize = party.length === 1 ? "alone" : `as a party of ${party.length}`;
                const partyClasses = party.map(c => c.class).join(", ");
                opening += ` You stand ${partySize}, ready to face whatever comes.`;
                voiceOpening += ` You stand ${partySize} - ${partyClasses} - ready to face whatever destiny awaits. What do you do?`;
            } else {
                opening += " What will you do?";
                voiceOpening += " The choice, as always, is yours. What do you do?";
            }
            
            // Display the opening narration
            const openingMessage = `
                <div class="dm-message voice-message opening-narration">
                    <div class="message-header">
                        <strong>üé≠ Dungeon Master</strong>
                        <span class="voice-indicator-small">üîä</span>
                        <span class="timestamp">${new Date().toLocaleTimeString()}</span>
                    </div>
                    <div class="message-content">
                        <p class="opening-text">${opening}</p>
                        <p class="dm-prompt"><em>What do you do?</em></p>
                    </div>
                </div>
            `;
            
            appendToConversation(openingMessage);
            
            // Store the hook in story state
            STORY_STATE.plotThreads.push(hook);
            STORY_STATE.currentChapter = 'adventure_start';
            
            // Initialize the starting scene context
            DM_STATE.currentLocation = 'village';
            DM_STATE.currentScene = 'quest_start';
            
            // Speak the opening
            setTimeout(() => {
                speakAsDM(voiceOpening);
            }, 500);
        }

        // Generate dynamic story developments based on player actions
        function generateStoryDevelopment(playerAction, context = {}) {
            const action = playerAction.toLowerCase();
            const currentTension = STORY_STATE.narrativeTension;
            
            // Check if action relates to existing plot threads
            const relevantThread = STORY_STATE.plotThreads.find(thread => 
                action.includes(thread.type) || 
                thread.keywords?.some(keyword => action.includes(keyword))
            );
            
            // Generate consequences that build on previous events
            if (STORY_STATE.completedEvents.length > 0) {
                const lastEvent = STORY_STATE.completedEvents[STORY_STATE.completedEvents.length - 1];
                
                // Create callbacks to previous events
                if (Math.random() < 0.3) { // 30% chance of callback
                    return {
                        text: `Your actions remind you of ${lastEvent.description}. The consequences of that choice echo here...`,
                        voice: `Interesting... your current choice mirrors what happened when ${lastEvent.description}. The threads of fate are weaving together. How will you handle it differently this time?`,
                        continuity: true
                    };
                }
            }
            
            // Escalate tension naturally
            if (currentTension < 5 && Math.random() < 0.4) {
                STORY_STATE.narrativeTension++;
                return generateComplication();
            }
            
            // Resolution opportunities at high tension
            if (currentTension >= 7 && Math.random() < 0.5) {
                return generateClimax();
            }
            
            // Default to contextual development
            return generateContextualDevelopment(playerAction, context);
        }

        // Generate complications to raise stakes
        function generateComplication() {
            const complications = [
                {
                    text: "Suddenly, things take an unexpected turn! A new threat emerges from an unforeseen direction.",
                    voice: "Wait! Something's not right here. You notice movement in the shadows - you're not alone! This just became much more dangerous. How do you respond to this new threat?"
                },
                {
                    text: "Your action has unintended consequences! The situation grows more complex.",
                    voice: "Oh, this is interesting! Your action has triggered something unexpected. The simple task has become a web of complications. What started as straightforward is now anything but! What's your next move?"
                },
                {
                    text: "A moral dilemma presents itself - the right choice is no longer clear.",
                    voice: "Hold on... this situation is more complex than it appeared. You're faced with a choice where any action could have serious consequences for innocent people. There's no perfect solution here. What will you prioritize?"
                }
            ];
            
            return complications[Math.floor(Math.random() * complications.length)];
        }

        // Generate climactic moments
        function generateClimax() {
            const climaxes = [
                {
                    text: "This is it - the moment of truth! Everything has led to this critical juncture.",
                    voice: "THIS IS IT! The moment of truth has arrived! Everything you've done has led to this crucial moment. The fate of everyone involved hangs in the balance. This is your chance to be heroes! What do you do?"
                },
                {
                    text: "The tension reaches its breaking point! The situation demands immediate decisive action.",
                    voice: "The tension snaps like a bowstring! No more time for deliberation - the moment demands action NOW! Success or failure, glory or disaster, it all comes down to this. Make your choice!"
                }
            ];
            
            STORY_STATE.narrativeTension = Math.max(1, STORY_STATE.narrativeTension - 3); // Reset tension after climax
            return climaxes[Math.floor(Math.random() * climaxes.length)];
        }

        // Generate contextual story based on action type
        function generateContextualDevelopment(playerAction, context) {
            // This will evolve the story based on what the player does
            const developments = {
                explore: [
                    "Your exploration reveals more than expected - the plot thickens!",
                    "As you investigate, you uncover clues that connect to earlier events.",
                    "Your discovery opens new possibilities and raises new questions."
                ],
                combat: [
                    "The battle reveals the true stakes - this is bigger than you thought!",
                    "Victory brings new information, but also new enemies.",
                    "The fight changes everything - alliances shift and secrets are revealed."
                ],
                social: [
                    "Your words have more impact than expected - relationships permanently change.",
                    "The conversation reveals hidden motivations and secret alliances.",
                    "Your diplomatic approach opens unexpected doors - or closes them forever."
                ],
                puzzle: [
                    "Solving this reveals a piece of a larger mystery.",
                    "The solution brings knowledge, but knowledge can be dangerous.",
                    "Your success here cascades into new opportunities elsewhere."
                ]
            };
            
            // Determine action category
            let category = 'explore'; // default
            if (playerAction.includes('attack') || playerAction.includes('fight')) category = 'combat';
            if (playerAction.includes('talk') || playerAction.includes('persuade')) category = 'social';
            if (playerAction.includes('solve') || playerAction.includes('figure')) category = 'puzzle';
            
            const options = developments[category];
            const selected = options[Math.floor(Math.random() * options.length)];
            
            // Add it to story beats
            STORY_STATE.storyBeats.push({
                action: playerAction,
                development: selected,
                timestamp: Date.now()
            });
            
            return {
                text: selected,
                voice: `${selected} What do you do next?`,
                category: category
            };
        }

        // Generate voice-enabled DM response with real DM personality
        async function generateVoiceDMResponse(playerAction) {
            const action = playerAction.toLowerCase();
            const campaign = window.currentCampaign || {};
            
            // Try OpenAI first if enabled and configured
            if (openAIConfig.enabled && openAIConfig.apiKey) {
                try {
                    updateVoiceStatus('AI DM thinking...', 'processing');
                    const aiResponse = await generateOpenAIDMResponse(playerAction);
                    if (aiResponse) {
                        // Add story development tracking
                        if (Math.random() < 0.3) { // 30% chance to add story development
                            const storyDev = generateStoryDevelopment(playerAction);
                            if (storyDev) {
                                STORY_STATE.completedEvents.push({
                                    action: playerAction,
                                    development: storyDev.text,
                                    timestamp: Date.now()
                                });
                            }
                        }
                        
                        displayDMResponse(aiResponse.response, aiResponse.voice);
                        updateVoiceStatus('Ready to listen', 'ready');
                        return;
                    }
                } catch (error) {
                    console.error('OpenAI generation failed, falling back to templates:', error);
                    updateVoiceStatus('AI failed, using templates...', 'processing');
                }
            }
            
            // Combat responses - much more engaging
            if (action.includes('attack') || action.includes('fight') || action.includes('combat') || action.includes('hit') || action.includes('strike')) {
                const combatResponses = [
                    {
                        response: "Your blade flashes in the light as you move to strike! Roll for initiative - we're entering combat! What's your target?",
                        voice: "Steel rings as weapons are drawn! Roll for initiative everyone! Who or what are you attacking, and describe your approach!",
                        requiresDMRoll: true,
                        rollType: 'initiative'
                    },
                    {
                        response: "Violence erupts! The air crackles with tension as battle is joined! Everyone roll initiative!",
                        voice: "The peaceful moment shatters into chaos! Weapons drawn, spells at the ready - roll for initiative! Describe your opening move!",
                        requiresDMRoll: true,
                        rollType: 'initiative'
                    },
                    {
                        response: "Your hostile intent is clear! Combat begins - roll initiative and tell me your first action!",
                        voice: "Battle is joined! The clash of combat echoes through the area! Roll initiative and tell me - how does your character react in this critical moment?",
                        requiresDMRoll: true,
                        rollType: 'initiative'
                    }
                ];
                DM_STATE.combatActive = true;
                return combatResponses[Math.floor(Math.random() * combatResponses.length)];
            }
            
            // Investigation/Perception - more descriptive
            if (action.includes('look') || action.includes('search') || action.includes('investigate') || action.includes('examine') || action.includes('inspect')) {
                const investigateResponses = [
                    {
                        response: "Your trained eye scans the area methodically. Roll Investigation or Perception - d20 plus your modifier!",
                        voice: "You focus intently, your senses sharpening as you examine every detail. Roll an Investigation or Perception check - what specifically draws your attention?",
                        requiresDMRoll: true,
                        rollType: 'perception'
                    },
                    {
                        response: "Something about this place feels... different. Make an Investigation check to see what you discover!",
                        voice: "The hairs on your neck stand up - something here deserves closer inspection. Roll Investigation and tell me where you're focusing your search!",
                        requiresDMRoll: true,
                        rollType: 'investigation'
                    },
                    {
                        response: "You take a moment to carefully observe your surroundings. Roll Perception and add your Wisdom modifier!",
                        voice: "Time seems to slow as you take in every detail around you. Roll a Perception check - are you looking for danger, treasure, or something else?",
                        requiresDMRoll: true,
                        rollType: 'perception'
                    }
                ];
                return investigateResponses[Math.floor(Math.random() * investigateResponses.length)];
            }
            
            // Social interactions - more nuanced
            if (action.includes('talk') || action.includes('speak') || action.includes('say') || action.includes('ask') || action.includes('tell')) {
                const socialResponses = [
                    {
                        response: "The figure turns to face you, eyebrow raised. Your words will matter here - make a Persuasion, Deception, or Intimidation check!",
                        voice: "The figure's full attention locks onto you, weighing every word. How are you approaching this - with honeyed words, clever lies, or implied threats? Roll the appropriate Charisma check!",
                        requiresDMRoll: true,
                        rollType: 'charisma'
                    },
                    {
                        response: "Your voice cuts through the tension. The NPC's reaction depends on your approach - roll a Charisma-based skill check!",
                        voice: "Your words hang heavy in the air between you. I can see the gears turning in their mind. Are you being persuasive, deceptive, or intimidating? Make your roll and tell me your exact words!",
                        requiresDMRoll: true,
                        rollType: 'charisma'
                    }
                ];
                return socialResponses[Math.floor(Math.random() * socialResponses.length)];
            }
            
            // Movement and exploration - more atmospheric
            if (action.includes('go') || action.includes('move') || action.includes('walk') || action.includes('enter') || action.includes('leave')) {
                const moveResponses = [
                    {
                        response: "You move forward, each step taking you deeper into the unknown. The atmosphere shifts noticeably...",
                        voice: "Your footsteps echo as you advance. The air grows thick with possibility. Are you moving cautiously or boldly? And keep your eyes open - this place holds secrets!",
                        requiresDMRoll: false
                    },
                    {
                        response: "The path ahead beckons. As you progress, new details emerge from the shadows. Roll Perception to see what you notice!",
                        voice: "You press onward, the environment changing subtly around you. Roll a Perception check as you move - something here might be worth your attention. How quickly are you traveling?",
                        requiresDMRoll: true,
                        rollType: 'perception'
                    }
                ];
                return moveResponses[Math.floor(Math.random() * moveResponses.length)];
            }
            
            // Stealth actions - tension building
            if (action.includes('sneak') || action.includes('hide') || action.includes('stealth') || action.includes('quiet')) {
                return {
                    response: "You become one with the shadows, moving like a ghost. Roll Stealth - d20 plus Dexterity modifier!",
                    voice: "Silent as death itself, you slip into concealment. Your heart pounds but your movements are smooth. Roll a Stealth check and tell me - what are you trying to avoid being noticed by?",
                    requiresDMRoll: true,
                    rollType: 'stealth'
                };
            }
            
            // Spellcasting - magical flair
            if (action.includes('cast') || action.includes('spell') || action.includes('magic') || action.includes('cantrip')) {
                return {
                    response: "Arcane energy crackles around your fingers as you begin the incantation! What spell are you casting?",
                    voice: "The Weave responds to your call! Mystical energy swirls around you as reality bends to your will! What spell are you casting, at what level, and who or what is your target? Describe the casting!",
                    requiresDMRoll: false,
                    spellcasting: true
                };
            }
            
            // Skill checks and abilities
            if (action.includes('climb') || action.includes('jump') || action.includes('swim') || action.includes('lift')) {
                return {
                    response: "Your muscles tense as you attempt this physical feat. Roll Athletics - d20 plus Strength modifier!",
                    voice: "Time to test your physical prowess! Your body coils like a spring ready to release. Roll an Athletics check and describe your technique - are you going for power or finesse?",
                    requiresDMRoll: true,
                    rollType: 'athletics'
                };
            }
            
            // Rest and recovery
            if (action.includes('rest') || action.includes('sleep') || action.includes('camp')) {
                return {
                    response: "You find a suitable spot to rest. Are you taking a short rest (1 hour) or a long rest (8 hours)? Roll Perception to ensure the area is safe!",
                    voice: "Exhaustion weighs on you, and rest is needed. You scout for a defensible position. Will this be a short rest to catch your breath, or a long rest to fully recover? Roll Perception to check for danger while you rest!",
                    requiresDMRoll: true,
                    rollType: 'perception'
                };
            }
            
            // Default responses - still engaging
            const defaultResponses = [
                {
                    response: "That's an interesting approach! The world responds to your actions in unexpected ways. Tell me more about what you're trying to accomplish.",
                    voice: "Now that's thinking outside the box! Your action sets events in motion that even I didn't anticipate. Give me more details about your plan - what's your end goal here?",
                    requiresDMRoll: Math.random() < 0.4
                },
                {
                    response: "Your choice ripples through the scene like a stone in still water. Something is about to happen...",
                    voice: "Bold move! The consequences of your action are already beginning to manifest. The tension in the air is palpable. What are you prepared to do if this goes sideways?",
                    requiresDMRoll: Math.random() < 0.5
                },
                {
                    response: "The dice of fate are rolling behind the cosmic screen! Your action triggers a chain of events...",
                    voice: "Ah, the plot thickens! Your decision opens new possibilities I hadn't considered. The story takes an interesting turn here. How committed are you to this course of action?",
                    requiresDMRoll: Math.random() < 0.3
                }
            ];
            
            const selected = defaultResponses[Math.floor(Math.random() * defaultResponses.length)];
            
            // Add campaign flavor
            if (campaign.scenario === 'ravenloft' && Math.random() < 0.3) {
                selected.response += " The mists seem to thicken around you...";
                selected.voice += " And I should mention - the dark mists of Barovia seem to be taking notice of your actions...";
            } else if (campaign.scenario === 'spelljammer' && Math.random() < 0.3) {
                selected.response += " The stars above seem to shift slightly...";
                selected.voice += " The cosmic void around your ship seems to pulse with energy...";
            }
            
            // Incorporate dynamic story development
            const storyDev = generateStoryDevelopment(playerAction);
            if (storyDev && Math.random() < 0.6) { // 60% chance to add story development
                selected.response += ` ${storyDev.text}`;
                selected.voice += ` ${storyDev.voice}`;
            }
            
            // Handle dice rolls
            if (selected.requiresDMRoll) {
                handleDMDiceRoll(selected, playerAction);
            } else {
                displayDMResponse(selected.response, selected.voice);
            }
        }
        
        // Handle DM dice rolling
        function handleDMDiceRoll(responseObj, playerAction) {
            const rollTypes = {
                investigation: { die: 20, modifier: 0, description: "Investigation check" },
                initiative: { die: 20, modifier: 2, description: "Initiative roll" },
                persuasion: { die: 20, modifier: 1, description: "Reaction roll" },
                random: { die: 20, modifier: 0, description: "Outcome roll" }
            };
            
            const rollType = rollTypes[responseObj.rollType] || rollTypes.random;
            const roll = Math.floor(Math.random() * rollType.die) + 1;
            const total = roll + rollType.modifier;
            
            // Display the initial response
            displayDMResponse(responseObj.response, responseObj.voice);
            
            // Add DM dice roll after a delay
            setTimeout(() => {
                const rollMessage = `
                    <div class="dm-roll">
                        <div class="message-header">
                            <strong>üé≤ DM Roll</strong>
                            <span class="timestamp">${new Date().toLocaleTimeString()}</span>
                        </div>
                        <div class="message-content">
                            <p><strong>${rollType.description}:</strong> d${rollType.die} + ${rollType.modifier} = <span class="roll-result">${total}</span> (rolled ${roll})</p>
                        </div>
                    </div>
                `;
                
                appendToConversation(rollMessage);
                
                // Generate follow-up response based on roll result
                setTimeout(() => {
                    generateRollBasedResponse(rollType.description, total, playerAction);
                }, 1500);
                
            }, 2000);
        }
        
        // Generate response based on DM dice roll result with proper D&D flair
        function generateRollBasedResponse(rollDescription, total, originalAction) {
            let followupResponse = "";
            let followupVoice = "";
            const rollType = rollDescription.toLowerCase();
            
            // Natural 20 - Critical Success!
            if (total === 20 || total >= 25) {
                const criticalSuccesses = [
                    {
                        response: "NATURAL 20! Critical Success! The dice gods smile upon you! Your action succeeds spectacularly, creating an opportunity for advantage!",
                        voice: "NATURAL TWENTY! Critical success! The fates themselves conspire in your favor! Not only does your action succeed brilliantly, but you've created an opening for something more! Describe your moment of triumph!"
                    },
                    {
                        response: "CRIT! Legendary success! Your action succeeds so well that it becomes the stuff of tavern tales!",
                        voice: "CRITICAL HIT on the skill check! This is the kind of moment bards write songs about! Your success is so complete it changes the situation entirely in your favor! How does your character celebrate this incredible moment?"
                    }
                ];
                const crit = criticalSuccesses[Math.floor(Math.random() * criticalSuccesses.length)];
                followupResponse = crit.response;
                followupVoice = crit.voice;
            }
            // High Success (18-19)
            else if (total >= 18) {
                if (rollType.includes('stealth')) {
                    followupResponse = "Like a shadow given form, you move completely undetected. You're practically invisible!";
                    followupVoice = "You've become one with the shadows themselves! No one has any idea you're there. You have complete tactical advantage - what's your next move from the shadows?";
                } else if (rollType.includes('perception') || rollType.includes('investigation')) {
                    followupResponse = "Your keen senses reveal hidden details others would miss! You notice something very important...";
                    followupVoice = "Your sharp eyes catch every detail! Not only do you see what you were looking for, but you notice something else entirely - something that changes everything! What catches your attention most?";
                } else if (rollType.includes('persuasion') || rollType.includes('charisma')) {
                    followupResponse = "Your words strike the perfect chord! The NPC is not just convinced - they're eager to help!";
                    followupVoice = "Your silver tongue works its magic perfectly! The NPC's entire demeanor shifts - they're not just willing to help, they're enthusiastic about it! They lean in closer and say...";
                } else if (rollType.includes('initiative')) {
                    followupResponse = "Lightning reflexes! You act before anyone else can even blink! You have the drop on your enemies!";
                    followupVoice = "Incredible reflexes! Time seems to slow as you spring into action before anyone else can react! You have complete control of the battlefield's opening moments - make them count!";
                } else {
                    followupResponse = "Exceptional success! Fortune favors the bold, and you've proven very bold indeed!";
                    followupVoice = "Outstanding! Your skill and luck combine for a truly exceptional result! The dice love you today! How do you capitalize on this golden opportunity?";
                }
            }
            // Good Success (15-17)
            else if (total >= 15) {
                if (rollType.includes('combat') || rollType.includes('attack')) {
                    followupResponse = "Solid hit! Your attack finds its mark with satisfying impact!";
                    followupVoice = "A clean hit! Your strike lands true, and you can see the effect immediately! Your enemy staggers - press the advantage!";
                } else {
                    followupResponse = "Success! Your action achieves exactly what you intended, clean and effective!";
                    followupVoice = "Well done! Your approach works perfectly, achieving your goal with style! The path forward is clear - what's your next step?";
                }
            }
            // Moderate Success (10-14)
            else if (total >= 10) {
                followupResponse = "You succeed, but it's not pretty. The job gets done with a few complications along the way.";
                followupVoice = "Success, but barely! You manage to accomplish your goal, though not without drawing some unwanted attention or creating a new problem. How do you handle the complication?";
            }
            // Close Failure (5-9)
            else if (total >= 5) {
                followupResponse = "So close! You almost succeed, but fall just short. However, all is not lost - you might try a different approach.";
                followupVoice = "Almost! You were so close to success, but not quite there. The good news is you learned something from the attempt. Want to try a different tactic, or double down on this one?";
            }
            // Natural 1 or Critical Failure
            else if (total === 1 || total <= 4) {
                const criticalFailures = [
                    {
                        response: "NATURAL 1! Critical failure! The dice betray you spectacularly! This is going to hurt...",
                        voice: "OOF! Natural one! Critical failure! Not only does your action fail, but it fails in the most spectacular way possible! Something has gone terribly, hilariously wrong! How does your character react to this disaster?"
                    },
                    {
                        response: "Catastrophic failure! Your action backfires completely, creating a whole new problem!",
                        voice: "Oh no! That's a critical failure! Your attempt goes so wrong it actually makes things worse! The universe itself seems to be laughing at you! Quick, damage control - what do you do?"
                    }
                ];
                const fail = criticalFailures[Math.floor(Math.random() * criticalFailures.length)];
                followupResponse = fail.response;
                followupVoice = fail.voice;
            }
            // Regular Failure
            else {
                followupResponse = "Failure. Your action doesn't work as intended, and the situation remains challenging.";
                followupVoice = "That's a failure. Your attempt doesn't achieve what you hoped, and you'll need to reconsider your approach. The situation is getting tense - what's plan B?";
            }
            
            displayDMResponse(followupResponse, followupVoice);
        }
        
        // Display DM response with voice
        function displayDMResponse(textResponse, voiceResponse) {
            const responseMessage = `
                <div class="dm-message voice-message">
                    <div class="message-header">
                        <strong>üé≠ Dungeon Master</strong>
                        <span class="voice-indicator-small">üîä</span>
                        <span class="timestamp">${new Date().toLocaleTimeString()}</span>
                    </div>
                    <div class="message-content">
                        <p>${textResponse}</p>
                        <p class="dm-prompt"><em>What do you do next?</em></p>
                    </div>
                </div>
            `;
            
            appendToConversation(responseMessage);
            
            // Speak the response
            setTimeout(() => {
                speakAsDM(voiceResponse || textResponse);
            }, 500);
        }
        
        // Legacy text-only function (fallback)
        function generateDMResponse(playerAction) {
            const responses = [
                {
                    condition: playerAction.toLowerCase().includes('left') || playerAction.toLowerCase().includes('forest'),
                    response: "You venture deeper into the forest. The strange lights dance between the ancient trees, leading you to a hidden clearing where an old stone altar sits covered in glowing runes. A soft humming fills the air."
                },
                {
                    condition: playerAction.toLowerCase().includes('right') || playerAction.toLowerCase().includes('settlement'),
                    response: "You approach the settlement, which turns out to be a small trading post. A weathered innkeeper greets you warmly, offering hot food and tales of recent strange happenings in the region."
                },
                {
                    condition: playerAction.toLowerCase().includes('investigate') || playerAction.toLowerCase().includes('examine'),
                    response: "Your investigation reveals more than you initially expected. Roll a d20 + your Investigation modifier to see what you discover!"
                },
                {
                    condition: playerAction.toLowerCase().includes('attack') || playerAction.toLowerCase().includes('fight'),
                    response: "Combat begins! Roll for initiative! The tension in the air is palpable as weapons are drawn and spells are prepared."
                },
                {
                    condition: playerAction.toLowerCase().includes('talk') || playerAction.toLowerCase().includes('speak'),
                    response: "Your words carry weight in this moment. The NPC listens intently, their expression shifting as they consider your words carefully."
                }
            ];
            
            // Find matching response or use default
            let dmResponse = responses.find(r => r.condition)?.response || 
                "Interesting choice! The consequences of your action begin to unfold before you. The world reacts to your decision in ways both expected and surprising.";
            
            // Add some dynamic elements based on campaign
            const campaign = window.currentCampaign;
            if (campaign?.moralComplexity === 'morally_gray') {
                dmResponse += " The moral implications of this choice are not immediately clear...";
            }
            
            const responseMessage = `
                <div class="dm-message">
                    <div class="message-header">
                        <strong>üé≠ Dungeon Master</strong>
                        <span class="timestamp">${new Date().toLocaleTimeString()}</span>
                    </div>
                    <div class="message-content">
                        <p>${dmResponse}</p>
                        <p class="dm-prompt"><em>What do you do next?</em></p>
                    </div>
                </div>
            `;
            
            appendToConversation(responseMessage);
        }
        
        // Roll dice
        function rollDice() {
            const dice = ['d4', 'd6', 'd8', 'd10', 'd12', 'd20'];
            const selectedDie = prompt('Which die do you want to roll? (d4, d6, d8, d10, d12, d20)', 'd20');
            
            if (dice.includes(selectedDie)) {
                const sides = parseInt(selectedDie.substring(1));
                const result = Math.floor(Math.random() * sides) + 1;
                
                const rollMessage = `
                    <div class="dice-roll">
                        <div class="message-header">
                            <strong>üé≤ Dice Roll</strong>
                            <span class="timestamp">${new Date().toLocaleTimeString()}</span>
                        </div>
                        <div class="message-content">
                            <p><strong>${getActiveCharacterName()}</strong> rolled a <strong>${selectedDie}</strong>: <span class="roll-result">${result}</span></p>
                        </div>
                    </div>
                `;
                
                appendToConversation(rollMessage);
            }
        }
        
        // Initiate quick actions
        function initiateAction(actionType) {
            const actions = {
                combat: "I want to initiate combat!",
                explore: "I want to explore the area more thoroughly.",
                rest: "I want to take a rest to recover.",
                inventory: "I want to check my inventory and equipment."
            };
            
            const input = document.getElementById('player-input');
            input.value = actions[actionType] || "I want to take an action.";
            sendPlayerAction();
        }
        
        // Helper functions
        function getActiveCharacterName() {
            const characters = window.partyCharacters || [];
            return characters.length > 0 ? characters[0].name : 'Adventurer';
        }
        
        function appendToConversation(messageHTML) {
            const history = document.getElementById('conversation-history');
            if (history) {
                history.innerHTML += messageHTML;
                history.scrollTop = history.scrollHeight;
                
                // Save conversation to campaign
                if (window.currentCampaign) {
                    saveCurrentCampaignData();
                }
            }
        }
        
        function updateGameStatus(location, time, weather) {
            document.getElementById('current-location').textContent = location;
            document.getElementById('current-time').textContent = time;
            document.getElementById('current-weather').textContent = weather;
        }

        // ===============================
        // COMBAT SYSTEM - D&D 5E RULES
        // ===============================
        
        // Combat state management
        let combatState = {
            active: false,
            combatants: [],
            currentTurn: 0,
            round: 1,
            mapZoom: 1,
            actionEconomy: {
                action: true,
                bonusAction: true,
                movement: 30,
                reaction: true
            }
        };

        // Modified initiateAction function to properly handle combat
        function initiateAction(actionType) {
            if (actionType === 'combat') {
                // Check if already in combat
                if (combatState.active) {
                    switchScreen('combat');
                    return;
                }
                
                // Start combat encounter
                startCombatEncounter();
            } else {
                const actions = {
                    explore: "I want to explore the area more thoroughly.",
                    rest: "I want to take a rest to recover.",
                    inventory: "I want to check my inventory and equipment."
                };

                if (actions[actionType]) {
                    document.getElementById('player-input').value = actions[actionType];
                    sendPlayerAction();
                }
            }
        }

        // Start a combat encounter
        function startCombatEncounter() {
            // Initialize combat with party characters and some enemies
            const partyMembers = window.partyCharacters || [];
            const enemies = generateEnemies();
            
            combatState.combatants = [
                ...partyMembers.map(char => ({
                    ...char,
                    type: 'player',
                    initiative: 0,
                    position: { x: 100 + Math.random() * 100, y: 200 + Math.random() * 100 },
                    conditions: []
                })),
                ...enemies
            ];
            
            // Roll initiative for all combatants
            rollInitiative();
            
            // Show combat screen
            combatState.active = true;
            switchScreen('combat');
            
            // Initialize battle map
            initializeBattleMap();
            
            // Add combat message
            addCombatMessage('Combat has begun! Rolling initiative...', 'system');
        }

        // Generate random enemies for the encounter
        function generateEnemies() {
            const enemyTemplates = [
                { name: 'Goblin', hp: 7, ac: 15, initiative: 0, type: 'enemy' },
                { name: 'Orc', hp: 15, ac: 13, initiative: 0, type: 'enemy' },
                { name: 'Bandit', hp: 11, ac: 12, initiative: 0, type: 'enemy' }
            ];
            
            const numEnemies = Math.min(3, Math.max(1, (window.partyCharacters?.length || 1)));
            const enemies = [];
            
            for (let i = 0; i < numEnemies; i++) {
                const template = enemyTemplates[Math.floor(Math.random() * enemyTemplates.length)];
                enemies.push({
                    ...template,
                    name: template.name + (numEnemies > 1 ? ` ${i + 1}` : ''),
                    position: { x: 300 + Math.random() * 200, y: 150 + Math.random() * 200 },
                    conditions: [],
                    combat: {
                        hitPoints: { current: template.hp, max: template.hp },
                        armorClass: template.ac
                    }
                });
            }
            
            return enemies;
        }

        // Roll initiative for all combatants
        function rollInitiative() {
            combatState.combatants.forEach(combatant => {
                // Roll d20 + DEX modifier
                const dexMod = Math.floor((combatant.abilities?.dexterity?.score || 10) / 2) - 5;
                combatant.initiative = Math.floor(Math.random() * 20) + 1 + dexMod;
            });
            
            // Sort by initiative (highest first)
            combatState.combatants.sort((a, b) => {
                if (b.initiative !== a.initiative) {
                    return b.initiative - a.initiative;
                }
                // Tie-breaker: higher DEX score wins
                const aDex = a.abilities?.dexterity?.score || 10;
                const bDex = b.abilities?.dexterity?.score || 10;
                return bDex - aDex;
            });
            
            combatState.currentTurn = 0;
            updateInitiativeDisplay();
            updateActionEconomy();
        }

        // Update the initiative tracker display
        function updateInitiativeDisplay() {
            const initiativeList = document.getElementById('initiative-list');
            if (!initiativeList) return;
            
            initiativeList.innerHTML = '';
            
            combatState.combatants.forEach((combatant, index) => {
                const entry = document.createElement('div');
                entry.className = `initiative-entry ${combatant.type}`;
                if (index === combatState.currentTurn) {
                    entry.classList.add('current-turn');
                }
                
                const hpDisplay = combatant.combat?.hitPoints ? 
                    `${combatant.combat.hitPoints.current}/${combatant.combat.hitPoints.max} HP` : '';
                
                entry.innerHTML = `
                    <div>
                        <div class="initiative-name">${combatant.name}</div>
                        <div style="font-size: 0.8rem; color: var(--color-text-secondary);">${hpDisplay}</div>
                    </div>
                    <div class="initiative-value">${combatant.initiative}</div>
                `;
                
                initiativeList.appendChild(entry);
            });
        }

        // Update action economy display
        function updateActionEconomy() {
            const currentCombatant = combatState.combatants[combatState.currentTurn];
            if (!currentCombatant || currentCombatant.type !== 'player') {
                // Hide action economy for non-player turns
                return;
            }
            
            document.getElementById('action-status').textContent = 
                combatState.actionEconomy.action ? 'Available' : 'Used';
            document.getElementById('action-status').className = 
                combatState.actionEconomy.action ? 'available' : 'used';
                
            document.getElementById('bonus-action-status').textContent = 
                combatState.actionEconomy.bonusAction ? 'Available' : 'Used';
            document.getElementById('bonus-action-status').className = 
                combatState.actionEconomy.bonusAction ? 'available' : 'used';
                
            document.getElementById('movement-status').textContent = 
                `${combatState.actionEconomy.movement} ft`;
            document.getElementById('movement-status').className = 
                combatState.actionEconomy.movement > 0 ? 'available' : 'used';
                
            document.getElementById('reaction-status').textContent = 
                combatState.actionEconomy.reaction ? 'Available' : 'Used';
            document.getElementById('reaction-status').className = 
                combatState.actionEconomy.reaction ? 'available' : 'used';
        }

        // Handle combat actions with D&D 5e rules
        function combatAction(actionType) {
            const currentCombatant = combatState.combatants[combatState.currentTurn];
            
            if (!currentCombatant || currentCombatant.type !== 'player') {
                addCombatMessage("It's not your turn!", 'system');
                return;
            }
            
            switch (actionType) {
                case 'attack':
                    if (!combatState.actionEconomy.action) {
                        addCombatMessage("You've already used your action this turn!", 'system');
                        return;
                    }
                    handleAttackAction(currentCombatant);
                    combatState.actionEconomy.action = false;
                    break;
                    
                case 'dodge':
                    if (!combatState.actionEconomy.action) {
                        addCombatMessage("You've already used your action this turn!", 'system');
                        return;
                    }
                    currentCombatant.conditions = currentCombatant.conditions || [];
                    currentCombatant.conditions.push('dodging');
                    addCombatMessage(`${currentCombatant.name} takes the Dodge action. Attacks against you have disadvantage until your next turn.`, 'system');
                    combatState.actionEconomy.action = false;
                    break;
                    
                case 'dash':
                    if (!combatState.actionEconomy.action) {
                        addCombatMessage("You've already used your action this turn!", 'system');
                        return;
                    }
                    const speed = currentCombatant.speed || 30;
                    combatState.actionEconomy.movement += speed;
                    addCombatMessage(`${currentCombatant.name} takes the Dash action. Movement increased by ${speed} ft.`, 'system');
                    combatState.actionEconomy.action = false;
                    break;
                    
                case 'help':
                    if (!combatState.actionEconomy.action) {
                        addCombatMessage("You've already used your action this turn!", 'system');
                        return;
                    }
                    addCombatMessage(`${currentCombatant.name} uses the Help action. Choose an ally to give them advantage on their next ability check or attack.`, 'system');
                    combatState.actionEconomy.action = false;
                    break;
                    
                case 'hide':
                    if (!combatState.actionEconomy.action) {
                        addCombatMessage("You've already used your action this turn!", 'system');
                        return;
                    }
                    const stealthRoll = Math.floor(Math.random() * 20) + 1;
                    const stealthMod = Math.floor((currentCombatant.abilities?.dexterity?.score || 10) / 2) - 5;
                    const total = stealthRoll + stealthMod;
                    addCombatMessage(`${currentCombatant.name} attempts to hide. Stealth check: ${stealthRoll} + ${stealthMod} = ${total}`, 'system');
                    combatState.actionEconomy.action = false;
                    break;
                    
                case 'ready':
                    if (!combatState.actionEconomy.action) {
                        addCombatMessage("You've already used your action this turn!", 'system');
                        return;
                    }
                    addCombatMessage(`${currentCombatant.name} readies an action. Describe your trigger and action.`, 'system');
                    combatState.actionEconomy.action = false;
                    break;
                    
                case 'disengage':
                    if (!combatState.actionEconomy.action) {
                        addCombatMessage("You've already used your action this turn!", 'system');
                        return;
                    }
                    addCombatMessage(`${currentCombatant.name} takes the Disengage action. You can move without provoking opportunity attacks.`, 'system');
                    combatState.actionEconomy.action = false;
                    break;
            }
            
            updateActionEconomy();
        }

        // Handle attack action with proper D&D 5e mechanics
        function handleAttackAction(attacker) {
            // Find available targets (enemies for players, players for enemies)
            const targets = combatState.combatants.filter(c => 
                c.type !== attacker.type && 
                (c.combat?.hitPoints?.current || 0) > 0
            );
            
            if (targets.length === 0) {
                addCombatMessage("No valid targets for attack!", 'system');
                return;
            }
            
            // For simplicity, attack the first available target
            const target = targets[0];
            
            // Roll attack
            const attackRoll = Math.floor(Math.random() * 20) + 1;
            const attackBonus = Math.floor((attacker.abilities?.strength?.score || 10) / 2) - 5 + 2; // +2 proficiency
            const totalAttack = attackRoll + attackBonus;
            
            const targetAC = target.combat?.armorClass || 10;
            
            if (attackRoll === 20) {
                // Critical hit!
                const damage = Math.floor(Math.random() * 8) + 1 + Math.floor(Math.random() * 8) + 1; // 2d8 for crit
                const strMod = Math.floor((attacker.abilities?.strength?.score || 10) / 2) - 5;
                const totalDamage = Math.max(1, damage + strMod);
                
                target.combat.hitPoints.current = Math.max(0, target.combat.hitPoints.current - totalDamage);
                
                addCombatMessage(`CRITICAL HIT! ${attacker.name} rolls a natural 20 and deals ${totalDamage} damage to ${target.name}!`, 'attack');
            } else if (attackRoll === 1) {
                // Critical miss!
                addCombatMessage(`CRITICAL MISS! ${attacker.name} rolls a natural 1 and misses spectacularly!`, 'attack');
            } else if (totalAttack >= targetAC) {
                // Hit!
                const damage = Math.floor(Math.random() * 8) + 1; // 1d8
                const strMod = Math.floor((attacker.abilities?.strength?.score || 10) / 2) - 5;
                const totalDamage = Math.max(1, damage + strMod);
                
                target.combat.hitPoints.current = Math.max(0, target.combat.hitPoints.current - totalDamage);
                
                addCombatMessage(`${attacker.name} hits ${target.name} for ${totalDamage} damage! (AC ${targetAC}, rolled ${totalAttack})`, 'attack');
            } else {
                // Miss!
                addCombatMessage(`${attacker.name} attacks ${target.name} but misses! (AC ${targetAC}, rolled ${totalAttack})`, 'attack');
            }
            
            // Check if target is defeated
            if (target.combat.hitPoints.current <= 0) {
                addCombatMessage(`${target.name} is defeated!`, 'system');
                target.conditions = target.conditions || [];
                target.conditions.push('defeated');
            }
            
            updateInitiativeDisplay();
            updateBattleMap();
        }

        // Advance to next turn
        function nextTurn() {
            if (!combatState.active) return;
            
            // Reset action economy
            combatState.actionEconomy = {
                action: true,
                bonusAction: true,
                movement: 30,
                reaction: true
            };
            
            // Clear temporary conditions
            const currentCombatant = combatState.combatants[combatState.currentTurn];
            if (currentCombatant.conditions) {
                currentCombatant.conditions = currentCombatant.conditions.filter(c => c !== 'dodging');
            }
            
            // Advance turn
            combatState.currentTurn++;
            if (combatState.currentTurn >= combatState.combatants.length) {
                combatState.currentTurn = 0;
                combatState.round++;
                addCombatMessage(`--- Round ${combatState.round} ---`, 'system');
            }
            
            const newCombatant = combatState.combatants[combatState.currentTurn];
            addCombatMessage(`${newCombatant.name}'s turn!`, 'system');
            
            updateInitiativeDisplay();
            updateActionEconomy();
            updateBattleMap();
            
            // Handle AI turns for non-player characters
            if (newCombatant.type !== 'player') {
                setTimeout(() => handleAITurn(newCombatant), 1000);
            }
        }

        // Handle AI turns for enemies and allies
        function handleAITurn(combatant) {
            if ((combatant.combat?.hitPoints?.current || 0) <= 0) {
                addCombatMessage(`${combatant.name} is defeated and cannot act.`, 'system');
                nextTurn();
                return;
            }
            
            // Simple AI: attack if possible, otherwise do nothing
            const targets = combatState.combatants.filter(c => 
                c.type !== combatant.type && 
                (c.combat?.hitPoints?.current || 0) > 0
            );
            
            if (targets.length > 0) {
                handleAttackAction(combatant);
            } else {
                addCombatMessage(`${combatant.name} has no valid targets.`, 'system');
            }
            
            setTimeout(() => nextTurn(), 1500);
        }

        // Initialize the battle map
        function initializeBattleMap() {
            const map = document.getElementById('battle-map');
            const combatantsLayer = document.getElementById('combatants-layer');
            
            if (!map || !combatantsLayer) return;
            
            // Clear existing tokens
            combatantsLayer.innerHTML = '';
            
            // Add combatant tokens
            combatState.combatants.forEach((combatant, index) => {
                const token = document.createElement('div');
                token.className = `combatant-token ${combatant.type}`;
                token.textContent = combatant.name.charAt(0).toUpperCase();
                token.title = combatant.name;
                token.style.left = combatant.position.x + 'px';
                token.style.top = combatant.position.y + 'px';
                token.dataset.combatantIndex = index;
                
                if (index === combatState.currentTurn) {
                    token.classList.add('current-turn');
                }
                
                // Add drag functionality for player characters on their turn
                if (combatant.type === 'player' && index === combatState.currentTurn) {
                    token.draggable = true;
                    token.style.cursor = 'move';
                    
                    token.addEventListener('dragstart', (e) => {
                        e.dataTransfer.setData('text/plain', index);
                        token.style.opacity = '0.5';
                    });
                    
                    token.addEventListener('dragend', (e) => {
                        token.style.opacity = '1';
                    });
                }
                
                combatantsLayer.appendChild(token);
            });
            
            // Add drop zone functionality to the battle map
            map.addEventListener('dragover', (e) => {
                e.preventDefault();
            });
            
            map.addEventListener('drop', (e) => {
                e.preventDefault();
                const combatantIndex = parseInt(e.dataTransfer.getData('text/plain'));
                const mapRect = map.getBoundingClientRect();
                const newX = e.clientX - mapRect.left - 20; // Center the token
                const newY = e.clientY - mapRect.top - 20;
                
                // Calculate movement distance
                const combatant = combatState.combatants[combatantIndex];
                const oldX = combatant.position.x;
                const oldY = combatant.position.y;
                const distance = Math.sqrt((newX - oldX) ** 2 + (newY - oldY) ** 2);
                const feetMoved = Math.round(distance / 10) * 5; // Convert pixels to 5-foot squares
                
                if (feetMoved <= combatState.actionEconomy.movement) {
                    // Valid move
                    combatant.position.x = Math.max(0, Math.min(newX, map.clientWidth - 40));
                    combatant.position.y = Math.max(0, Math.min(newY, map.clientHeight - 40));
                    combatState.actionEconomy.movement -= feetMoved;
                    
                    addCombatMessage(`${combatant.name} moves ${feetMoved} feet. ${combatState.actionEconomy.movement} feet of movement remaining.`, 'system');
                    updateBattleMap();
                    updateActionEconomy();
                } else {
                    // Invalid move - not enough movement
                    addCombatMessage(`${combatant.name} doesn't have enough movement! Distance: ${feetMoved} ft, Available: ${combatState.actionEconomy.movement} ft.`, 'system');
                    updateBattleMap(); // Reset position
                }
            });
        }

        // Update battle map (refresh token positions and states)
        function updateBattleMap() {
            initializeBattleMap();
        }

        // Add message to combat log
        function addCombatMessage(message, type = 'system') {
            const messagesContainer = document.getElementById('combat-messages');
            if (!messagesContainer) return;
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `combat-message ${type}`;
            
            const timestamp = new Date().toLocaleTimeString();
            messageDiv.innerHTML = `
                ${message}
                <span class="timestamp">${timestamp}</span>
            `;
            
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        // Map controls
        function zoomMap(direction) {
            const map = document.getElementById('battle-map');
            if (!map) return;
            
            if (direction === 'in') {
                combatState.mapZoom = Math.min(2, combatState.mapZoom + 0.2);
            } else {
                combatState.mapZoom = Math.max(0.5, combatState.mapZoom - 0.2);
            }
            
            map.style.transform = `scale(${combatState.mapZoom})`;
        }

        function centerMap() {
            const map = document.getElementById('battle-map');
            if (!map) return;
            
            combatState.mapZoom = 1;
            map.style.transform = 'scale(1)';
            map.scrollLeft = 0;
            map.scrollTop = 0;
        }

        // End combat
        function endCombat() {
            combatState.active = false;
            combatState.combatants = [];
            combatState.currentTurn = 0;
            combatState.round = 1;
            
            addCombatMessage('Combat has ended!', 'system');
            
            // Return to game screen
            switchScreen('game');
        }
    </script>

    <!-- Game Settings Modal -->
    <div id="game-settings-modal" class="modal" style="display: none;">
        <div class="modal-content large-modal">
            <div class="modal-header">
                <h3>‚öôÔ∏è Game Settings</h3>
                <button class="modal-close" onclick="this.closest('.modal').style.display='none'">‚úï</button>
            </div>
            <div class="modal-body">
                <div class="settings-tabs">
                    <button class="tab-button active" onclick="showSettingsTab('ai-settings')">ü§ñ AI Dungeon Master</button>
                    <button class="tab-button" onclick="showSettingsTab('voice-settings')">üé§ Voice & Audio</button>
                    <button class="tab-button" onclick="showSettingsTab('game-preferences')">üéÆ Preferences</button>
                </div>
                
                <div class="settings-content">
                    <!-- AI DM Settings Tab -->
                    <div id="ai-settings-tab" class="settings-tab active">
                        <div class="ai-engine-selection">
                            <h4>AI Engine</h4>
                            <div class="radio-group">
                                <label>
                                    <input type="radio" name="gameAiEngine" value="template" checked>
                                    Template Responses (Free, Basic)
                                </label>
                                <label>
                                    <input type="radio" name="gameAiEngine" value="openai">
                                    OpenAI (Premium, Advanced)
                                </label>
                            </div>
                        </div>

                        <div id="game-openai-settings" class="openai-settings" style="display: none;">
                            <h4>OpenAI Configuration</h4>
                            <div class="form-group">
                                <label for="game-openai-api-key">API Key:</label>
                                <div class="form-row">
                                    <input type="password" id="game-openai-api-key" placeholder="sk-..." 
                                           value="" class="api-key-input">
                                    <button type="button" onclick="testOpenAIInSettings()" class="test-button">Test</button>
                                </div>
                                <div id="game-openai-test-result" class="test-result"></div>
                            </div>
                            
                            <div class="form-group">
                                <label for="game-ai-model">Model:</label>
                                <select id="game-ai-model">
                                    <option value="gpt-3.5-turbo">GPT-3.5 Turbo (Faster, Cheaper)</option>
                                    <option value="gpt-4">GPT-4 (Smarter, More Expensive)</option>
                                    <option value="gpt-4-turbo-preview">GPT-4 Turbo (Latest)</option>
                                </select>
                            </div>
                            
                            <div class="form-group">
                                <label for="game-ai-creativity">Creativity: <span id="game-ai-creativity-display">70%</span></label>
                                <input type="range" id="game-ai-creativity" min="0" max="100" value="70" step="10">
                                <small>Lower = More predictable, Higher = More creative</small>
                            </div>
                            
                            <div class="form-group">
                                <label for="game-ai-response-length">Response Length:</label>
                                <select id="game-ai-response-length">
                                    <option value="short">Short (50-100 words)</option>
                                    <option value="normal" selected>Normal (100-200 words)</option>
                                    <option value="long">Long (200-300 words)</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Voice Settings Tab -->
                    <div id="voice-settings-tab" class="settings-tab">
                        <div class="voice-engine-selection">
                            <h4>Voice Engine</h4>
                            <div class="radio-group">
                                <label>
                                    <input type="radio" name="gameVoiceEngine" value="browser" checked>
                                    Browser Text-to-Speech (Free, Basic)
                                </label>
                                <label>
                                    <input type="radio" name="gameVoiceEngine" value="elevenlabs">
                                    ElevenLabs (Premium, High Quality)
                                </label>
                            </div>
                        </div>

                        <div id="game-elevenlabs-settings" class="elevenlabs-settings" style="display: none;">
                            <h4>ElevenLabs Configuration</h4>
                            <div class="form-group">
                                <label for="game-elevenlabs-api-key">API Key:</label>
                                <div class="form-row">
                                    <input type="password" id="game-elevenlabs-api-key" placeholder="Enter your ElevenLabs API key" 
                                           value="" class="api-key-input">
                                    <button type="button" onclick="testElevenLabsInSettings()" class="test-button">Test</button>
                                </div>
                                <div id="game-elevenlabs-test-result" class="test-result"></div>
                            </div>
                            
                            <div class="form-group">
                                <label for="game-elevenlabs-voice-id">DM Voice:</label>
                                <select id="game-elevenlabs-voice-id">
                                    <option value="">Loading voices...</option>
                                </select>
                                <button type="button" onclick="loadElevenLabsVoicesInSettings()" class="secondary-button">Refresh Voices</button>
                            </div>
                            
                            <div class="form-group">
                                <label for="game-voice-stability">Stability: <span id="game-voice-stability-display">50%</span></label>
                                <input type="range" id="game-voice-stability" min="0" max="100" value="50" step="5">
                                <small>Lower = More variable, Higher = More stable</small>
                            </div>
                            
                            <div class="form-group">
                                <label for="game-voice-clarity">Clarity: <span id="game-voice-clarity-display">75%</span></label>
                                <input type="range" id="game-voice-clarity" min="0" max="100" value="75" step="5">
                                <small>Lower = More similar to original, Higher = Enhanced clarity</small>
                            </div>
                            
                            <div class="form-group">
                                <button type="button" onclick="testElevenLabsVoiceInSettings()" class="primary-button">Test Voice</button>
                            </div>
                        </div>

                        <!-- Browser TTS Settings -->
                        <div id="game-browser-tts-settings" class="browser-tts-settings">
                            <h4>Browser Text-to-Speech</h4>
                            <div class="form-group">
                                <label for="game-browser-voice">Voice:</label>
                                <select id="game-browser-voice">
                                    <option value="">Default System Voice</option>
                                </select>
                            </div>
                            
                            <div class="form-group">
                                <label for="game-voice-rate">Speech Rate: <span id="game-voice-rate-display">1.0x</span></label>
                                <input type="range" id="game-voice-rate" min="0.5" max="2" value="1" step="0.1">
                            </div>
                            
                            <div class="form-group">
                                <label for="game-voice-pitch">Pitch: <span id="game-voice-pitch-display">1.0x</span></label>
                                <input type="range" id="game-voice-pitch" min="0.5" max="2" value="1" step="0.1">
                            </div>
                        </div>
                    </div>

                    <!-- Game Preferences Tab -->
                    <div id="game-preferences-tab" class="settings-tab">
                        <h4>Auto-Save</h4>
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="game-auto-save-enabled" checked>
                                Enable auto-save every 5 minutes
                            </label>
                        </div>
                        
                        <h4>Campaign Preferences</h4>
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="game-use-campaign-context" checked>
                                Include campaign context in AI responses
                            </label>
                        </div>
                        
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="game-use-reference-data" checked>
                                Use D&D reference data for AI responses
                            </label>
                        </div>
                        
                        <h4>Interface</h4>
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="game-show-timestamps" checked>
                                Show timestamps on messages
                            </label>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="secondary-button" onclick="this.closest('.modal').style.display='none'">Cancel</button>
                <button class="primary-button" onclick="saveGameSettings()">Save Settings</button>
            </div>
        </div>
    </div>

    <!-- Initialize Application -->
    <script type="module">
        // Check browser compatibility first
        const isModuleSupported = 'noModule' in HTMLScriptElement.prototype;
        const isFileProtocol = window.location.protocol === 'file:';
        
        if (isFileProtocol) {
            console.warn('‚ö†Ô∏è Running from file:// protocol. ES modules may not work properly.');
            console.log('üí° For full functionality, serve this app from a web server (e.g., python -m http.server)');
        }
        
        // Import the core module
        import './js/core.js';
        
        // Application initialization
        document.addEventListener('DOMContentLoaded', async () => {
            const loadingScreen = document.getElementById('loading-screen');
            const loadingProgress = document.getElementById('loading-progress');
            const loadingText = document.getElementById('loading-text');
            const app = document.getElementById('app');
            
            function updateProgress(progress, text) {
                loadingProgress.style.width = progress + '%';
                loadingText.textContent = text;
                console.log(`üìä ${progress}%: ${text}`);
            }
            
            try {
                updateProgress(10, 'Loading ancient scrolls...');
                await new Promise(resolve => setTimeout(resolve, 100));
                
                updateProgress(20, 'Checking browser compatibility...');
                // Browser checks
                if (window.location.protocol === 'file:') {
                    console.warn('üö® File protocol detected - this may cause issues');
                }
                
                updateProgress(30, 'Importing core modules...');
                // Wait for DNDCore to be available globally
                let attempts = 0;
                while (!window.DNDCore && attempts < 100) {
                    await new Promise(resolve => setTimeout(resolve, 50));
                    attempts++;
                    if (attempts % 10 === 0) {
                        updateProgress(30 + (attempts / 2), `Waiting for core module... (${attempts}/100)`);
                    }
                }
                
                if (!window.DNDCore) {
                    throw new Error('DNDCore module failed to load after 5 seconds. This usually indicates a file:// protocol issue or JavaScript error.');
                }
                
                updateProgress(60, 'Core module loaded successfully');
                console.log('‚úÖ DNDCore is available');
                
                updateProgress(70, 'Initializing application modules...');
                
                // Listen for core loading progress
                window.DNDCore.on('core:loading_progress', (event) => {
                    const { loaded, total, current } = event.detail;
                    const moduleProgress = 70 + ((loaded / total) * 20);
                    updateProgress(moduleProgress, `Loading ${current}... (${loaded}/${total})`);
                });
                
                updateProgress(75, 'Starting core initialization...');
                
                // Initialize the core application with timeout
                const initPromise = window.DNDCore.init();
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('Initialization timed out after 30 seconds')), 30000);
                });
                
                await Promise.race([initPromise, timeoutPromise]);
                
                updateProgress(95, 'Finalizing setup...');
                await new Promise(resolve => setTimeout(resolve, 200));
                
                updateProgress(100, 'Welcome, adventurer!');
                console.log('üéâ Application initialized successfully');
                
                // Hide loading screen and show app
                setTimeout(() => {
                    console.log('üé¨ Hiding loading screen');
                    loadingScreen.classList.add('fade-out');
                    setTimeout(() => {
                        loadingScreen.style.display = 'none';
                        app.style.opacity = '1';
                        console.log('‚úÖ Application fully loaded and visible');
                    }, 500);
                }, 300);
                
            } catch (error) {
                loadingText.textContent = `Error: ${error.message}`;
                console.error('Application initialization failed:', error);
                
                // Show detailed error in the error container
                const errorContainer = document.getElementById('error-container');
                if (errorContainer) {
                    errorContainer.style.display = 'block';
                    
                    let helpText = '';
                    if (window.location.protocol === 'file:') {
                        helpText = `
                            <div class="error-help">
                                <h3>üí° Quick Fix</h3>
                                <p>You're running this from a file:// URL, which causes security restrictions.</p>
                                <p><strong>Solution:</strong> Run a local server:</p>
                                <ol>
                                    <li>Open terminal/command prompt in this folder</li>
                                    <li>Run: <code>python -m http.server 8000</code></li>
                                    <li>Open: <a href="http://localhost:8000" target="_blank">http://localhost:8000</a></li>
                                </ol>
                                <p>Or use the provided <code>start-server.py</code> script.</p>
                            </div>
                        `;
                    }
                    
                    errorContainer.innerHTML = `
                        <div class="critical-error">
                            <h2>‚ö†Ô∏è Initialization Error</h2>
                            <p>The D&D Voice Adventure app failed to initialize.</p>
                            ${helpText}
                            <details>
                                <summary>Technical Details</summary>
                                <pre>${error.stack || error.message}</pre>
                            </details>
                            <div class="error-actions">
                                <button onclick="location.reload()">üîÑ Reload</button>
                                <button onclick="window.open('README-SERVER.md', '_blank')">üìñ Help Guide</button>
                            </div>
                        </div>
                    `;
                }
                
                // Hide loading screen after showing error
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                }, 1000);
            }
        });
        
        // Service Worker Registration for PWA support
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then(registration => console.log('SW registered'))
                    .catch(error => console.log('SW registration failed'));
            });
        }
        
        // Global error handler
        window.addEventListener('error', (event) => {
            console.error('Global error:', event.error);
            if (window.DNDCore) {
                window.DNDCore.handleCriticalError(event.error);
            }
        });
        
        // Prevent default drag and drop to avoid accidental navigation
        document.addEventListener('dragover', e => e.preventDefault());
        document.addEventListener('drop', e => e.preventDefault());

        // Initialize AI DM settings after DOM loads
        document.addEventListener('DOMContentLoaded', function() {
            // Load OpenAI config from localStorage
            const enabled = localStorage.getItem('openai_enabled') === 'true';
            if (enabled) {
                openAIConfig.enabled = true;
            }

            // Add event listeners for AI engine radio buttons
            const aiRadioButtons = document.querySelectorAll('input[name="aiEngine"]');
            aiRadioButtons.forEach(radio => {
                radio.addEventListener('change', toggleOpenAISettings);
            });

            // Add event listener for creativity slider
            const creativitySlider = document.getElementById('ai-creativity');
            if (creativitySlider) {
                creativitySlider.addEventListener('input', function() {
                    document.getElementById('ai-creativity-display').textContent = this.value + '%';
                });
            }
        });
    </script>
</body>
</html>