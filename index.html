<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Taylor's Epic D&D Time - A comprehensive tabletop RPG companion with voice integration, inspired by Baldur's Gate 3 and Gloomhaven.">
    <meta name="keywords" content="D&D, Dungeons Dragons, RPG, tabletop, voice, adventure, campaign, Taylor">
    <meta name="author" content="Taylor's Epic D&D Time">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://taylor834-sketch.github.io/AI-DND-DM/">
    <meta property="og:title" content="Taylor's Epic D&D Time">
    <meta property="og:description" content="Experience immersive tabletop RPG adventures with voice integration and atmospheric storytelling.">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://taylor834-sketch.github.io/AI-DND-DM/"
    <meta property="twitter:title" content="Taylor's Epic D&D Time">
    <meta property="twitter:description" content="Experience immersive tabletop RPG adventures with voice integration and atmospheric storytelling.">
    
    <title>Taylor's Epic D&D Time</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="./assets/favicon.ico">
    
    <!-- Preconnect for performance -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Crimson+Text:ital,wght@0,400;0,600;1,400&display=swap" rel="stylesheet">
    
    <!-- Main Stylesheet -->
    <link rel="stylesheet" href="./css/main.css">
    
    <!-- Error Styles -->
    <style>
        .critical-error {
            max-width: 600px;
            margin: 50px auto;
            padding: 30px;
            background: #1a1a1a;
            border: 2px solid #ff4444;
            border-radius: 10px;
            color: white;
            font-family: 'Crimson Text', serif;
        }
        .critical-error h2 {
            color: #ff6666;
            margin-top: 0;
        }
        .error-help {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #4CAF50;
        }
        .error-help h3 {
            color: #4CAF50;
            margin-top: 0;
        }
        .error-help code {
            background: #333;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
        }
        .error-actions {
            margin-top: 20px;
        }
        .error-actions button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            margin-right: 10px;
            cursor: pointer;
            font-size: 14px;
        }
        .error-actions button:hover {
            background: #45a049;
        }
        .error-actions button:nth-child(2) {
            background: #2196F3;
        }
        .error-actions button:nth-child(2):hover {
            background: #1976D2;
        }
        
        /* Battle map loading spinner animation */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Settings tabs */
        .settings-tabs {
            display: flex;
            border-bottom: 2px solid #444;
            margin-bottom: 20px;
        }
        
        .settings-tab {
            padding: 12px 24px;
            background: transparent;
            border: none;
            color: #999;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
        }
        
        .settings-tab:hover {
            color: #f0f0f0;
            background: rgba(255, 255, 255, 0.1);
        }
        
        .settings-tab.active {
            color: #f0f0f0;
            border-bottom: 3px solid #8B4513;
        }
        
        .settings-tab-content {
            display: none;
        }
        
        .settings-tab-content.active {
            display: block;
        }
        
        .voice-test-section {
            margin: 20px 0;
            padding: 15px;
            background: #2a2a2a;
            border-radius: 8px;
        }
        
        .scenario-buttons, .control-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        
        .results-container {
            min-height: 100px;
            padding: 15px;
            background: #1a1a1a;
            border-radius: 5px;
            font-family: monospace;
        }
    </style>
    
    <!-- Preload critical resources -->
    <link rel="preload" href="./css/main.css" as="style">
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading-screen" class="loading-screen">
        <div class="loading-content">
            <div class="dragon-symbol">üêâ</div>
            <h1 class="loading-title">Taylor's Epic D&D Time</h1>
            <div class="loading-bar">
                <div class="loading-progress" id="loading-progress"></div>
            </div>
            <p class="loading-text" id="loading-text">Awakening ancient powers...</p>
        </div>
    </div>

    <!-- Error Container for Critical Errors -->
    <div id="error-container" class="error-container" style="display: none;"></div>

    <!-- Main Application Container -->
    <div id="app" class="app-container">
        <!-- Main Menu Screen -->
        <div id="mainMenu-screen" class="screen main-menu-screen active">
            <!-- Background Elements -->
            <div class="background-overlay"></div>
            <div class="particle-container" id="particle-container"></div>
            
            <!-- Header -->
            <header class="main-header">
                <div class="title-container">
                    <h1 class="main-title">
                        <span class="title-primary">Taylor's Epic</span>
                        <span class="title-secondary">D&D Time</span>
                    </h1>
                    <p class="subtitle">Embark on Epic Journeys</p>
                </div>
            </header>

            <!-- Main Menu Navigation -->
            <nav class="main-menu">
                <div class="menu-container">
                    <button id="create-campaign-btn" class="menu-button primary-button">
                        <span class="button-icon">‚öîÔ∏è</span>
                        <span class="button-text">Create New Campaign</span>
                        <span class="button-description">Begin a fresh adventure</span>
                    </button>

                    <button id="continue-campaign-btn" class="menu-button secondary-button">
                        <span class="button-icon">üìñ</span>
                        <span class="button-text">Continue Campaign</span>
                        <span class="button-description">Resume your journey</span>
                    </button>

                    <button id="load-github-btn" class="menu-button secondary-button">
                        <span class="button-icon">‚òÅÔ∏è</span>
                        <span class="button-text">Load from GitHub</span>
                        <span class="button-description">Sync your adventures</span>
                    </button>

                    <button id="world-browser-btn" class="menu-button secondary-button">
                        <span class="button-icon">üåç</span>
                        <span class="button-text">World Browser</span>
                        <span class="button-description">Explore NPCs, locations, and lore</span>
                    </button>

                    <button id="settings-btn" class="menu-button tertiary-button">
                        <span class="button-icon">‚öôÔ∏è</span>
                        <span class="button-text">Settings</span>
                        <span class="button-description">Configure your experience</span>
                    </button>
                </div>
            </nav>

            <!-- Footer -->
            <footer class="main-footer">
                <div class="footer-content">
                    <p class="version-info">Version <span id="app-version">1.0.0</span></p>
                    <p class="github-link">
                        <a href="https://github.com/taylor834-sketch/AI-DND-DM" target="_blank" rel="noopener noreferrer">
                            View on GitHub
                        </a>
                    </p>
                </div>
            </footer>
        </div>

        <!-- Settings Screen -->
        <div id="settings-screen" class="screen settings-screen">
            <div class="settings-container">
                <header class="screen-header">
                    <h2>Settings</h2>
                    <button class="close-button" onclick="promptToSave('mainMenu')">‚úï</button>
                </header>
                
                <div class="settings-tabs">
                    <button class="settings-tab active" onclick="showSettingsTab('general')">General</button>
                    <button class="settings-tab" onclick="showSettingsTab('voice-testing')">Voice Testing</button>
                </div>
                
                <div class="settings-content">
                    <div id="general-settings" class="settings-tab-content active">
                        <div class="settings-section">
                        <h3>Audio</h3>
                        <div class="setting-item">
                            <label>
                                <input type="checkbox" id="enable-audio"> Enable Audio Effects
                            </label>
                        </div>
                        <div class="setting-item">
                            <label>
                                Master Volume
                                <input type="range" id="master-volume" min="0" max="100" value="70">
                            </label>
                        </div>
                    </div>
                    
                    <div class="settings-section">
                        <h3>Display</h3>
                        <div class="setting-item">
                            <label>
                                <select id="theme-select">
                                    <option value="dark">Dark Theme</option>
                                    <option value="light">Light Theme</option>
                                    <option value="auto">Auto (System)</option>
                                </select>
                                Theme
                            </label>
                        </div>
                        <div class="setting-item">
                            <label>
                                <input type="checkbox" id="enable-particles" checked> Enable Particles
                            </label>
                        </div>
                    </div>
                    
                    <div class="settings-section">
                        <h3>GitHub Integration</h3>
                        <div class="setting-item">
                            <label>
                                GitHub Token
                                <input type="password" id="github-token" placeholder="ghp_xxxxxxxxxxxx">
                            </label>
                        </div>
                        <div class="setting-item">
                            <label>
                                Repository
                                <input type="text" id="github-repo" placeholder="username/dnd-campaigns">
                            </label>
                        </div>
                        <button id="test-github-connection" class="secondary-button">Test Connection</button>
                    </div>
                    </div>
                    
                    <div id="voice-testing-settings" class="settings-tab-content" style="display: none;">
                        <div class="settings-section">
                            <h3>üß™ Voice Integration Test Suite</h3>
                            <p style="color: #999; margin-bottom: 20px;">Comprehensive testing tools for voice recognition and synthesis features</p>
                            
                            <div id="voice-test-scenarios" class="voice-test-section">
                                <h4>Test Scenarios</h4>
                                <div class="scenario-buttons">
                                    <button class="secondary-button" onclick="runVoiceTest('basic-recognition')">Basic Speech Recognition</button>
                                    <button class="secondary-button" onclick="runVoiceTest('character-context')">Character Context</button>
                                    <button class="secondary-button" onclick="runVoiceTest('voice-commands')">Voice Commands</button>
                                    <button class="secondary-button" onclick="runVoiceTest('dm-responses')">DM Responses</button>
                                </div>
                            </div>
                            
                            <div id="voice-test-controls" class="voice-test-section">
                                <h4>Test Controls</h4>
                                <div class="control-buttons">
                                    <button class="primary-button" onclick="runAllVoiceTests()">Run All Tests</button>
                                    <button class="secondary-button" onclick="testMicrophone()">Test Microphone</button>
                                    <button class="secondary-button" onclick="testSpeakers()">Test Speakers</button>
                                    <button class="secondary-button" onclick="calibrateVoice()">Calibrate Voice</button>
                                </div>
                            </div>
                            
                            <div id="voice-test-results" class="voice-test-section">
                                <h4>Test Results</h4>
                                <div id="test-results-display" class="results-container">
                                    <p style="color: #999;">No tests run yet. Click a test button above to begin.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Campaign List Screen -->
        <div id="campaignList-screen" class="screen campaign-list-screen">
            <div class="screen-header">
                <h2>Continue Campaign</h2>
                <button class="back-button" onclick="promptToSave('mainMenu')">‚Üê Back</button>
            </div>
            <div class="campaign-list-container">
                <div id="campaign-list-content">
                    <!-- Campaigns will be populated here -->
                </div>
            </div>
        </div>

        <!-- Campaign Creation Screen -->
        <div id="campaignCreation-screen" class="screen campaign-creation-screen">
            <div class="campaign-creation-container">
                <header class="screen-header">
                    <h2>Create New Campaign</h2>
                    <button class="close-button" onclick="promptToSave('mainMenu')">‚úï</button>
                </header>
                
                <form id="campaign-creation-form" class="campaign-form" onsubmit="createCampaign(event); return false;">
                    <div class="form-section">
                        <h3>Campaign Details</h3>
                        
                        <div class="form-group">
                            <label for="campaign-name">Campaign Name *</label>
                            <input type="text" id="campaign-name" name="campaignName" required 
                                   placeholder="The Shattered Crown" maxlength="50">
                            <small>Give your adventure a memorable name</small>
                        </div>

                        <div class="form-group">
                            <label for="world-seed">World Seed</label>
                            <input type="text" id="world-seed" name="worldSeed" 
                                   placeholder="mystical_forests_47291" maxlength="30">
                            <small>Optional: Custom seed for world generation (leave blank for random)</small>
                        </div>
                    </div>

                    <div class="form-section">
                        <h3>Campaign Style</h3>
                        
                        <div class="form-group">
                            <label for="moral-complexity">Moral Complexity</label>
                            <select id="moral-complexity" name="moralComplexity" required>
                                <option value="simple">Simple - Clear good vs evil</option>
                                <option value="nuanced" selected>Nuanced - Shades of gray with clear consequences</option>
                                <option value="morally_gray">Morally Gray - Complex choices with no clear right answer</option>
                            </select>
                            <small>How complex should moral decisions be in your campaign?</small>
                        </div>

                        <div class="form-group">
                            <label for="starting-region">Starting Region</label>
                            <select id="starting-region" name="startingRegion" required>
                                <option value="sword_coast">Sword Coast - Classic D&D adventure region</option>
                                <option value="underdark">Underdark - Dark underground realm</option>
                                <option value="feywild">Feywild - Magical fey realm</option>
                                <option value="shadowfell">Shadowfell - Dark reflection of the material plane</option>
                                <option value="elemental_planes">Elemental Planes - Raw elemental forces</option>
                                <option value="custom">Custom Region</option>
                            </select>
                            <small>Choose the starting location for your adventure</small>
                        </div>

                        <div class="form-group" id="custom-region-group" style="display: none;">
                            <label for="custom-region-name">Custom Region Name</label>
                            <input type="text" id="custom-region-name" name="customRegionName" 
                                   placeholder="The Forgotten Realms" maxlength="40">
                            <small>Name your custom starting region</small>
                        </div>
                    </div>

                    <div class="form-section">
                        <h3>Starting Scenario</h3>
                        <div class="scenario-selection">
                            <div class="scenario-option selected" data-scenario="mysterious_caravan" onclick="selectScenario('mysterious_caravan')">
                                <div class="scenario-header">
                                    <h4>üöö The Mysterious Caravan</h4>
                                    <span class="scenario-difficulty">Beginner</span>
                                </div>
                                <p>A merchant caravan has gone missing on the trade routes. Investigate their disappearance and uncover a web of intrigue.</p>
                                <div class="scenario-features">
                                    <span class="feature">Investigation</span>
                                    <span class="feature">Social Encounters</span>
                                    <span class="feature">Mystery</span>
                                </div>
                            </div>

                            <div class="scenario-option" data-scenario="goblin_raids" onclick="selectScenario('goblin_raids')">
                                <div class="scenario-header">
                                    <h4>‚öîÔ∏è Goblin Raids</h4>
                                    <span class="scenario-difficulty">Beginner</span>
                                </div>
                                <p>Goblin raiders threaten a peaceful village. Rally the townsfolk and drive back the goblin menace.</p>
                                <div class="scenario-features">
                                    <span class="feature">Combat</span>
                                    <span class="feature">Tactics</span>
                                    <span class="feature">Community</span>
                                </div>
                            </div>

                            <div class="scenario-option" data-scenario="ancient_ruins" onclick="selectScenario('ancient_ruins')">
                                <div class="scenario-header">
                                    <h4>üèõÔ∏è The Ancient Ruins</h4>
                                    <span class="scenario-difficulty">Intermediate</span>
                                </div>
                                <p>Explore forgotten ruins filled with traps, puzzles, and ancient guardians protecting lost treasures.</p>
                                <div class="scenario-features">
                                    <span class="feature">Exploration</span>
                                    <span class="feature">Puzzles</span>
                                    <span class="feature">Treasure</span>
                                </div>
                            </div>

                            <div class="scenario-option" data-scenario="political_intrigue" onclick="selectScenario('political_intrigue')">
                                <div class="scenario-header">
                                    <h4>üëë Court of Shadows</h4>
                                    <span class="scenario-difficulty">Advanced</span>
                                </div>
                                <p>Navigate the dangerous waters of noble court politics, where words are weapons and alliances shift like shadows.</p>
                                <div class="scenario-features">
                                    <span class="feature">Roleplay</span>
                                    <span class="feature">Intrigue</span>
                                    <span class="feature">Politics</span>
                                </div>
                            </div>
                        </div>
                        <input type="hidden" id="selected-scenario" name="startingScenario" value="mysterious_caravan">
                    </div>

                    <div class="form-actions">
                        <button type="button" class="secondary-button" onclick="promptToSave('mainMenu')">
                            Cancel
                        </button>
                        <button type="submit" class="primary-button">
                            <span class="button-icon">‚ú®</span>
                            Create Campaign
                        </button>
                    </div>
                </form>
            </div>
        </div>

        <!-- API Configuration Screen -->
        <div id="apiSetup-screen" class="screen api-setup-screen">
            <div class="api-setup-container">
                <header class="screen-header">
                    <h2>üîß API Configuration</h2>
                    <p>Configure your AI services for the best D&D experience</p>
                </header>

                <div class="api-setup-content">
                    <!-- OpenAI Configuration -->
                    <div class="api-section">
                        <div class="api-header">
                            <h3>ü§ñ OpenAI (AI Dungeon Master)</h3>
                            <span class="api-status" id="openai-status">Not Configured</span>
                        </div>
                        <div class="api-description">
                            <p>Powers intelligent DM responses and story continuation. Recommended for the best experience.</p>
                            <a href="https://platform.openai.com/api-keys" target="_blank">Get your API key ‚Üí</a>
                        </div>
                        <div class="form-group">
                            <label for="setup-openai-key">API Key:</label>
                            <div class="form-row">
                                <input type="password" id="setup-openai-key" placeholder="sk-..." 
                                       value="" class="api-key-input">
                                <button type="button" onclick="testOpenAISetup()" class="test-button">Test</button>
                            </div>
                        </div>
                        <div id="openai-test-result" class="test-result"></div>
                        
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="setup-openai-enabled" checked>
                                Enable OpenAI (recommended)
                            </label>
                        </div>
                    </div>

                    <!-- ElevenLabs Configuration -->
                    <div class="api-section">
                        <div class="api-header">
                            <h3>üéµ ElevenLabs (Voice Synthesis)</h3>
                            <span class="api-status" id="elevenlabs-status">Not Configured</span>
                        </div>
                        <div class="api-description">
                            <p>High-quality AI voice for DM narration. Optional but adds immersion.</p>
                            <a href="https://elevenlabs.io/app/speech-synthesis" target="_blank">Get your API key ‚Üí</a>
                        </div>
                        <div class="form-group">
                            <label for="setup-elevenlabs-key">API Key:</label>
                            <div class="form-row">
                                <input type="password" id="setup-elevenlabs-key" placeholder="Enter your ElevenLabs API key" 
                                       value="" class="api-key-input">
                                <button type="button" onclick="testElevenLabsSetup()" class="test-button">Test</button>
                            </div>
                        </div>
                        <div id="elevenlabs-test-result" class="test-result"></div>
                        
                        <div class="form-group">
                            <label for="setup-elevenlabs-voice">Voice:</label>
                            <select id="setup-elevenlabs-voice">
                                <option value="">Test API key first</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="setup-elevenlabs-enabled">
                                Enable ElevenLabs voice (optional)
                            </label>
                        </div>
                    </div>

                    <!-- API Skip Option -->
                    <div class="api-section skip-section">
                        <div class="api-header">
                            <h3>‚ö° Quick Start</h3>
                        </div>
                        <div class="api-description">
                            <p>You can skip API setup and use basic features. APIs can be configured later in settings.</p>
                        </div>
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="skip-api-setup">
                                Skip API setup for now (use template responses)
                            </label>
                        </div>
                    </div>
                </div>

                <div class="screen-actions">
                    <button onclick="goBackToCampaignList()" class="secondary-button">‚Üê Back to Campaigns</button>
                    <button onclick="continueToCharacterSetup()" class="primary-button" id="continue-to-character-setup">
                        Continue to Character Setup ‚Üí
                    </button>
                </div>
            </div>
        </div>

        <!-- Character Setup Screen -->
        <div id="characterSetup-screen" class="screen character-setup-screen">
            <div class="character-setup-container">
                <header class="screen-header">
                    <h2>Character Setup</h2>
                    <div class="header-actions">
                        <button id="import-character-btn" class="secondary-button">Import from D&D Beyond</button>
                        <button class="close-button" onclick="promptToSave('mainMenu')">‚úï</button>
                    </div>
                </header>

                <!-- Import Character Modal -->
                <div id="import-modal" class="modal" style="display: none;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3>Import D&D Beyond Character</h3>
                            <button class="modal-close" onclick="this.closest('.modal').style.display='none'">‚úï</button>
                        </div>
                        <div class="modal-body">
                            <p>Copy and paste your character sheet text from D&D Beyond:</p>
                            <textarea id="character-import-text" placeholder="Paste your D&D Beyond character sheet here..." rows="10"></textarea>
                        </div>
                        <div class="modal-footer">
                            <button class="secondary-button" onclick="this.closest('.modal').style.display='none'">Cancel</button>
                            <button id="parse-character-btn" class="primary-button">Parse Character</button>
                        </div>
                    </div>
                </div>

                <!-- Party Management -->
                <div class="party-management">
                    <h3>Party Members</h3>
                    <div id="party-list" class="party-list">
                        <div class="empty-party">
                            <p>No characters in party. Import or create characters to get started.</p>
                            <button class="primary-button" onclick="document.getElementById('import-modal').style.display='flex'">
                                <span class="button-icon">üë•</span>
                                Add First Character
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Character Actions -->
                <div class="character-actions" id="character-actions" style="display: none;">
                    <button id="continue-to-game-btn" class="primary-button">
                        <span class="button-icon">üéÆ</span>
                        Continue to Game
                    </button>
                </div>
            </div>
        </div>

        <!-- Character Sheet Screen -->
        <div id="characterSheet-screen" class="screen character-sheet-screen">
            <div class="character-sheet-container">
                <header class="character-sheet-header">
                    <div class="character-name-section">
                        <h2 id="character-name">Character Name</h2>
                        <div class="character-basics">
                            <span id="character-class-level">Class Level</span>
                            <span id="character-race">Race</span>
                        </div>
                    </div>
                    <div class="party-switcher">
                        <select id="character-switcher">
                            <option>Select Character</option>
                        </select>
                    </div>
                    <div class="header-actions">
                        <button id="save-character-btn" class="secondary-button">Save</button>
                        <button class="close-button" onclick="promptToSave('mainMenu')">‚úï</button>
                    </div>
                </header>

                <!-- Character Sheet Tabs -->
                <div class="character-tabs">
                    <button class="tab-button active" data-tab="overview">Overview</button>
                    <button class="tab-button" data-tab="abilities">Abilities</button>
                    <button class="tab-button" data-tab="skills">Skills</button>
                    <button class="tab-button" data-tab="inventory">Inventory</button>
                    <button class="tab-button" data-tab="spells">Spells</button>
                    <button class="tab-button" data-tab="features">Features</button>
                    <button class="tab-button" data-tab="relationships">Relationships</button>
                </div>

                <!-- Tab Content -->
                <div class="tab-content">
                    <!-- Overview Tab -->
                    <div id="overview-tab" class="tab-panel active">
                        <div class="overview-grid">
                            <div class="vital-stats">
                                <h3>Vital Stats</h3>
                                <div class="stat-row">
                                    <label>Armor Class</label>
                                    <span id="ac-value">10</span>
                                </div>
                                <div class="stat-row">
                                    <label>Hit Points</label>
                                    <div class="hp-section">
                                        <input type="number" id="current-hp" min="0">
                                        <span>/</span>
                                        <span id="max-hp">1</span>
                                    </div>
                                </div>
                                <div class="stat-row">
                                    <label>Speed</label>
                                    <span id="speed-value">30 ft</span>
                                </div>
                                <div class="stat-row">
                                    <label>Proficiency Bonus</label>
                                    <span id="prof-bonus">+2</span>
                                </div>
                            </div>

                            <div class="ability-overview">
                                <h3>Ability Scores</h3>
                                <div class="ability-grid">
                                    <div class="ability-score">
                                        <div class="ability-name">STR</div>
                                        <div class="ability-value" id="str-score">10</div>
                                        <div class="ability-modifier" id="str-mod">+0</div>
                                    </div>
                                    <div class="ability-score">
                                        <div class="ability-name">DEX</div>
                                        <div class="ability-value" id="dex-score">10</div>
                                        <div class="ability-modifier" id="dex-mod">+0</div>
                                    </div>
                                    <div class="ability-score">
                                        <div class="ability-name">CON</div>
                                        <div class="ability-value" id="con-score">10</div>
                                        <div class="ability-modifier" id="con-mod">+0</div>
                                    </div>
                                    <div class="ability-score">
                                        <div class="ability-name">INT</div>
                                        <div class="ability-value" id="int-score">10</div>
                                        <div class="ability-modifier" id="int-mod">+0</div>
                                    </div>
                                    <div class="ability-score">
                                        <div class="ability-name">WIS</div>
                                        <div class="ability-value" id="wis-score">10</div>
                                        <div class="ability-modifier" id="wis-mod">+0</div>
                                    </div>
                                    <div class="ability-score">
                                        <div class="ability-name">CHA</div>
                                        <div class="ability-value" id="cha-score">10</div>
                                        <div class="ability-modifier" id="cha-mod">+0</div>
                                    </div>
                                </div>
                            </div>

                            <div class="character-info">
                                <h3>Character Information</h3>
                                <div class="info-row">
                                    <label>Background:</label>
                                    <span id="character-background">Unknown</span>
                                </div>
                                <div class="info-row">
                                    <label>Alignment:</label>
                                    <span id="character-alignment">Unknown</span>
                                </div>
                                <div class="info-row">
                                    <label>Experience:</label>
                                    <span id="character-xp">0 XP</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Abilities Tab -->
                    <div id="abilities-tab" class="tab-panel">
                        <div class="abilities-content">
                            <div class="saving-throws">
                                <h3>Saving Throws</h3>
                                <div id="saving-throws-list" class="saves-list">
                                    <!-- Populated by JavaScript -->
                                </div>
                            </div>
                            <div class="ability-details">
                                <h3>Ability Score Details</h3>
                                <div id="ability-details-list" class="ability-list">
                                    <!-- Populated by JavaScript -->
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Skills Tab -->
                    <div id="skills-tab" class="tab-panel">
                        <h3>Skills</h3>
                        <div id="skills-list" class="skills-list">
                            <!-- Populated by JavaScript -->
                        </div>
                    </div>

                    <!-- Inventory Tab -->
                    <div id="inventory-tab" class="tab-panel">
                        <div class="inventory-content">
                            <div class="weapons-section">
                                <h3>Weapons</h3>
                                <div id="weapons-list" class="equipment-list">
                                    <!-- Populated by JavaScript -->
                                </div>
                            </div>
                            <div class="armor-section">
                                <h3>Armor</h3>
                                <div id="armor-list" class="equipment-list">
                                    <!-- Populated by JavaScript -->
                                </div>
                            </div>
                            <div class="items-section">
                                <h3>Items</h3>
                                <div id="items-list" class="equipment-list">
                                    <!-- Populated by JavaScript -->
                                </div>
                            </div>
                            <div class="currency-section">
                                <h3>Currency</h3>
                                <div class="currency-grid">
                                    <div class="coin"><span class="coin-type">CP</span><span id="cp-amount">0</span></div>
                                    <div class="coin"><span class="coin-type">SP</span><span id="sp-amount">0</span></div>
                                    <div class="coin"><span class="coin-type">EP</span><span id="ep-amount">0</span></div>
                                    <div class="coin"><span class="coin-type">GP</span><span id="gp-amount">0</span></div>
                                    <div class="coin"><span class="coin-type">PP</span><span id="pp-amount">0</span></div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Spells Tab -->
                    <div id="spells-tab" class="tab-panel">
                        <div class="spells-content">
                            <div class="spellcasting-info">
                                <h3>Spellcasting</h3>
                                <div class="spell-stats">
                                    <div class="spell-stat">
                                        <label>Spellcasting Ability</label>
                                        <span id="spellcasting-ability">None</span>
                                    </div>
                                    <div class="spell-stat">
                                        <label>Spell Save DC</label>
                                        <span id="spell-save-dc">8</span>
                                    </div>
                                    <div class="spell-stat">
                                        <label>Spell Attack Bonus</label>
                                        <span id="spell-attack-bonus">+0</span>
                                    </div>
                                </div>
                            </div>
                            <div class="spell-slots">
                                <h3>Spell Slots</h3>
                                <div id="spell-slots-list" class="slots-list">
                                    <!-- Populated by JavaScript -->
                                </div>
                            </div>
                            <div class="spells-known">
                                <h3>Spells Known</h3>
                                <div id="spells-list" class="spells-list">
                                    <!-- Populated by JavaScript -->
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Features Tab -->
                    <div id="features-tab" class="tab-panel">
                        <h3>Features & Traits</h3>
                        <div id="features-list" class="features-list">
                            <!-- Populated by JavaScript -->
                        </div>
                    </div>

                    <!-- Relationships Tab -->
                    <div id="relationships-tab" class="tab-panel">
                        <div class="relationships-content">
                            <div class="backstory-section">
                                <h3>Backstory</h3>
                                <div class="backstory-item">
                                    <label>Personality Traits:</label>
                                    <div id="personality-traits" class="trait-list"></div>
                                </div>
                                <div class="backstory-item">
                                    <label>Ideals:</label>
                                    <div id="ideals" class="trait-list"></div>
                                </div>
                                <div class="backstory-item">
                                    <label>Bonds:</label>
                                    <div id="bonds" class="trait-list"></div>
                                </div>
                                <div class="backstory-item">
                                    <label>Flaws:</label>
                                    <div id="flaws" class="trait-list"></div>
                                </div>
                            </div>
                            <div class="notes-section">
                                <h3>Notes</h3>
                                <textarea id="character-notes" placeholder="Character notes and relationships..."></textarea>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- World Browser Screen -->
        <div id="worldBrowser-screen" class="screen world-browser-screen">
            <div class="world-browser-container">
                <header class="screen-header">
                    <h2>World Browser</h2>
                    <button class="close-button" onclick="promptToSave('mainMenu')">‚úï</button>
                </header>

                <!-- Search and Filters -->
                <div class="world-browser-filters">
                    <div class="search-section">
                        <input type="text" id="world-search" placeholder="Search NPCs, locations, factions, events..." class="search-input">
                        <button id="search-btn" class="search-button">üîç</button>
                    </div>
                    
                    <div class="filter-section">
                        <div class="filter-group">
                            <label>Category:</label>
                            <select id="category-filter">
                                <option value="all">All</option>
                                <option value="npcs">NPCs</option>
                                <option value="locations">Locations</option>
                                <option value="factions">Factions</option>
                                <option value="events">Events</option>
                            </select>
                        </div>
                        
                        <div class="filter-group">
                            <label>Region:</label>
                            <select id="region-filter">
                                <option value="all">All Regions</option>
                            </select>
                        </div>
                        
                        <div class="filter-group">
                            <label>Status:</label>
                            <select id="status-filter">
                                <option value="all">All</option>
                                <option value="active">Active</option>
                                <option value="inactive">Inactive</option>
                                <option value="hostile">Hostile</option>
                                <option value="friendly">Friendly</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- World Browser Tabs -->
                <div class="world-browser-tabs">
                    <button class="world-tab-button active" data-tab="all">All</button>
                    <button class="world-tab-button" data-tab="npcs">NPCs</button>
                    <button class="world-tab-button" data-tab="locations">Locations</button>
                    <button class="world-tab-button" data-tab="factions">Factions</button>
                    <button class="world-tab-button" data-tab="events">Events</button>
                    <button class="world-tab-button" data-tab="timeline">Timeline</button>
                    <button class="world-tab-button" data-tab="relationships">Relationships</button>
                </div>

                <!-- Tab Content -->
                <div class="world-tab-content">
                    <!-- All Tab -->
                    <div id="all-world-tab" class="world-tab-panel active">
                        <div id="all-results" class="world-results-grid">
                            <!-- Populated by JavaScript -->
                        </div>
                    </div>

                    <!-- NPCs Tab -->
                    <div id="npcs-world-tab" class="world-tab-panel">
                        <div class="npc-section">
                            <div class="section-header">
                                <h3>Non-Player Characters</h3>
                                <button id="add-npc-btn" class="add-button">+ Add NPC</button>
                            </div>
                            <div id="npc-results" class="npc-grid">
                                <!-- Populated by JavaScript -->
                            </div>
                        </div>
                    </div>

                    <!-- Locations Tab -->
                    <div id="locations-world-tab" class="world-tab-panel">
                        <div class="location-section">
                            <div class="section-header">
                                <h3>Locations</h3>
                                <button id="add-location-btn" class="add-button">+ Add Location</button>
                            </div>
                            <div id="location-results" class="location-grid">
                                <!-- Populated by JavaScript -->
                            </div>
                        </div>
                    </div>

                    <!-- Factions Tab -->
                    <div id="factions-world-tab" class="world-tab-panel">
                        <div class="faction-section">
                            <div class="section-header">
                                <h3>Factions</h3>
                                <button id="add-faction-btn" class="add-button">+ Add Faction</button>
                            </div>
                            <div id="faction-results" class="faction-grid">
                                <!-- Populated by JavaScript -->
                            </div>
                        </div>
                    </div>

                    <!-- Events Tab -->
                    <div id="events-world-tab" class="world-tab-panel">
                        <div class="event-section">
                            <div class="section-header">
                                <h3>Events</h3>
                                <button id="add-event-btn" class="add-button">+ Add Event</button>
                            </div>
                            <div id="event-results" class="event-list">
                                <!-- Populated by JavaScript -->
                            </div>
                        </div>
                    </div>

                    <!-- Timeline Tab -->
                    <div id="timeline-world-tab" class="world-tab-panel">
                        <div class="timeline-section">
                            <h3>Campaign Timeline</h3>
                            <div class="timeline-controls">
                                <button id="timeline-filter-major" class="timeline-filter">Major Events</button>
                                <button id="timeline-filter-all" class="timeline-filter active">All Events</button>
                                <select id="timeline-date-range">
                                    <option value="all">All Time</option>
                                    <option value="recent">Last 30 Days</option>
                                    <option value="session">Current Session</option>
                                </select>
                            </div>
                            <div id="timeline-results" class="timeline-container">
                                <!-- Populated by JavaScript -->
                            </div>
                        </div>
                    </div>

                    <!-- Relationships Tab -->
                    <div id="relationships-world-tab" class="world-tab-panel">
                        <div class="relationships-section">
                            <h3>Relationship Map</h3>
                            <div class="relationship-controls">
                                <select id="relationship-focus">
                                    <option value="all">Show All Relationships</option>
                                    <option value="party">Party Connections</option>
                                    <option value="factions">Faction Networks</option>
                                    <option value="locations">Location Connections</option>
                                </select>
                                <button id="relationship-reset" class="secondary-button">Reset View</button>
                            </div>
                            <div id="relationship-map" class="relationship-map">
                                <!-- Populated by JavaScript with visual relationship mapping -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- World Entity Detail Modal -->
        <div id="world-detail-modal" class="modal" style="display: none;">
            <div class="modal-content world-detail-content">
                <div class="modal-header">
                    <h3 id="detail-title">Entity Details</h3>
                    <button class="modal-close" onclick="this.closest('.modal').style.display='none'">‚úï</button>
                </div>
                <div class="modal-body" id="detail-body">
                    <!-- Populated by JavaScript based on entity type -->
                </div>
                <div class="modal-footer">
                    <button id="edit-entity-btn" class="secondary-button">Edit</button>
                    <button class="primary-button" onclick="this.closest('.modal').style.display='none'">Close</button>
                </div>
            </div>
        </div>

        <!-- Add/Edit Entity Modal -->
        <div id="entity-form-modal" class="modal" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">
                    <h3 id="entity-form-title">Add Entity</h3>
                    <button class="modal-close" onclick="this.closest('.modal').style.display='none'">‚úï</button>
                </div>
                <div class="modal-body">
                    <form id="entity-form">
                        <div id="entity-form-fields">
                            <!-- Populated dynamically based on entity type -->
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button class="secondary-button" onclick="this.closest('.modal').style.display='none'">Cancel</button>
                    <button id="save-entity-btn" class="primary-button">Save</button>
                </div>
            </div>
        </div>
        
        <!-- Game Screen -->
        <div id="game-screen" class="screen game-screen">
            <div class="game-container">
                <header class="game-header">
                    <h2>Taylor's Epic D&D Time</h2>
                    <div class="game-controls">
                        <button class="secondary-button" onclick="switchScreen('characterSheet')">üìÑ Character Sheet</button>
                        <button class="secondary-button" onclick="switchScreen('worldBrowser')">üåç World Browser</button>
                        <button class="secondary-button" onclick="showTacticalBattleMap()">üó∫Ô∏è Battle Map</button>
                        <button class="secondary-button" onclick="openGameSettings()">‚öôÔ∏è Settings</button>
                        <button class="secondary-button" onclick="saveAndExitToMainMenu()">üíæ Save and Exit</button>
                    </div>
                </header>
                
                <!-- Game Status Panel -->
                <div id="game-status" class="game-status-panel" style="background: #2a2a2a; padding: 10px 20px; margin: 10px 0; border-radius: 8px; display: flex; justify-content: space-around; align-items: center;">
                    <div class="status-item">
                        <span style="color: #999;">üìç Location:</span>
                        <span id="current-location" style="color: #f0f0f0; margin-left: 5px;">Unknown</span>
                    </div>
                    <div class="status-item">
                        <span style="color: #999;">üïê Time:</span>
                        <span id="current-time" style="color: #f0f0f0; margin-left: 5px;">Dawn</span>
                    </div>
                    <div class="status-item">
                        <span style="color: #999;">‚òÅÔ∏è Weather:</span>
                        <span id="current-weather" style="color: #f0f0f0; margin-left: 5px;">Clear</span>
                    </div>
                </div>
                
                <div class="game-content" style="display: flex; gap: 20px; height: calc(100vh - 180px);">
                    <!-- Left Side: AI DM Conversation Interface -->
                    <div class="dm-conversation" style="flex: 1; display: flex; flex-direction: column; min-width: 400px;">
                        <div class="conversation-header">
                            <h3>üé≤ Adventure Story</h3>
                        </div>
                        
                        <div id="conversation-history" class="conversation-history" style="flex: 1; overflow-y: auto;">
                            <!-- Conversation history will be populated here -->
                        </div>
                        
                        <div class="player-input-section">
                            <div class="voice-controls">
                                <div class="voice-status">
                                    <div id="voice-status-indicator" class="voice-indicator">
                                        <span id="voice-status-text">Ready to listen</span>
                                        <div id="voice-animation" class="voice-animation"></div>
                                    </div>
                                </div>
                                
                                <div class="voice-buttons">
                                    <button id="start-listening-btn" class="voice-button primary-button" onclick="startListening()">
                                        üé§ Speak Action
                                    </button>
                                    <button id="stop-listening-btn" class="voice-button secondary-button" onclick="stopListening()" style="display: none;">
                                        ‚èπÔ∏è Stop
                                    </button>
                                    <button class="voice-button secondary-button" onclick="toggleDMVoice()">
                                        <span id="dm-voice-toggle">üîä DM Voice: ON</span>
                                    </button>
                                </div>
                            </div>
                            
                            <div class="text-fallback">
                                <details>
                                    <summary>Or type your action (fallback)</summary>
                                    <div class="input-group">
                                        <textarea id="player-input" placeholder="Describe your action..." rows="2"></textarea>
                                        <div class="input-actions">
                                            <button class="secondary-button" onclick="sendPlayerAction()">Send Text</button>
                                            <button class="secondary-button" onclick="rollDice()">üé≤ Roll Dice</button>
                                        </div>
                                    </div>
                                </details>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Right Side: Enhanced Tactical Battle Map -->
                    <div id="embedded-battle-map-container" class="embedded-battle-map-container" style="flex: 1; display: flex; flex-direction: column; min-width: 500px; max-width: 60%; background: linear-gradient(145deg, #2a2a2a, #1a1a1a); border-radius: 10px; padding: 10px; box-sizing: border-box;">
                        <!-- Map will be embedded here by the tactical battle map module -->
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Combat System -->
        <div id="combat-screen" class="screen combat-screen" style="display: none;">
            <div class="combat-container">
                <header class="combat-header">
                    <h2>‚öîÔ∏è Combat Encounter</h2>
                    <div class="combat-controls">
                        <button class="secondary-button" onclick="endCombat()">End Combat</button>
                        <button class="secondary-button" onclick="switchScreen('game')">Back to Game</button>
                    </div>
                </header>
                
                <div class="combat-content">
                    <!-- Initiative Tracker -->
                    <div class="combat-sidebar">
                        <div class="initiative-tracker">
                            <h3>üé≤ Initiative Order</h3>
                            <div id="initiative-list" class="initiative-list">
                                <!-- Initiative entries will be populated here -->
                            </div>
                            <div class="combat-controls-bottom">
                                <button class="primary-button" onclick="nextTurn()">Next Turn</button>
                                <button class="secondary-button" onclick="rollInitiative()">Re-roll Initiative</button>
                            </div>
                        </div>
                        
                        <div class="turn-actions">
                            <h3>Current Turn Actions</h3>
                            <div id="turn-actions" class="action-economy">
                                <div class="action-slot">
                                    <span class="action-label">Action:</span>
                                    <span id="action-status" class="available">Available</span>
                                </div>
                                <div class="action-slot">
                                    <span class="action-label">Bonus Action:</span>
                                    <span id="bonus-action-status" class="available">Available</span>
                                </div>
                                <div class="action-slot">
                                    <span class="action-label">Movement:</span>
                                    <span id="movement-status" class="available">30 ft</span>
                                </div>
                                <div class="action-slot">
                                    <span class="action-label">Reaction:</span>
                                    <span id="reaction-status" class="available">Available</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="combat-actions">
                            <h3>Combat Actions</h3>
                            <div class="action-buttons">
                                <button class="action-btn attack" onclick="combatAction('attack')">‚öîÔ∏è Attack</button>
                                <button class="action-btn" onclick="combatAction('dodge')">üõ°Ô∏è Dodge</button>
                                <button class="action-btn" onclick="combatAction('dash')">üèÉ Dash</button>
                                <button class="action-btn" onclick="combatAction('help')">ü§ù Help</button>
                                <button class="action-btn" onclick="combatAction('hide')">üë§ Hide</button>
                                <button class="action-btn" onclick="combatAction('ready')">‚è≥ Ready</button>
                                <button class="action-btn" onclick="combatAction('disengage')">üèÉ‚Äç‚ôÇÔ∏è Disengage</button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Battle Map -->
                    <div class="battle-map-container">
                        <div class="battle-map-header" style="background: #2a2a2a; padding: 12px 15px; border-radius: 8px 8px 0 0; margin-bottom: 0; border-bottom: 2px solid #444;">
                            <h3 style="margin: 0; color: #f0f0f0; font-size: 1.2em; display: inline-block;">‚öîÔ∏è Tactical Battle Map</h3>
                            <div class="map-controls" style="float: right;">
                                <button class="secondary-button" onclick="zoomMap('in')">üîç+</button>
                                <button class="secondary-button" onclick="zoomMap('out')">üîç-</button>
                                <button class="secondary-button" onclick="centerMap()">üéØ Center</button>
                            </div>
                        </div>
                        <div id="battle-map" class="battle-map" style="position: relative; min-height: 400px;">
                            <!-- Loading indicator for battle map -->
                            <div id="battle-map-loading" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; z-index: 100; display: none;">
                                <div style="background: rgba(42, 42, 42, 0.95); padding: 30px; border-radius: 10px; border: 2px solid #444;">
                                    <div class="loading-spinner" style="width: 50px; height: 50px; margin: 0 auto 20px; border: 5px solid #444; border-top-color: #f0f0f0; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                                    <h3 style="color: #f0f0f0; margin: 0 0 10px 0;">Loading Battle Map...</h3>
                                    <p id="battle-map-loading-text" style="color: #999; margin: 0;">Initializing tactical grid system</p>
                                </div>
                            </div>
                            <div class="grid-overlay" id="grid-overlay"></div>
                            <div class="combatants-layer" id="combatants-layer"></div>
                        </div>
                        <div class="map-legend">
                            <div class="legend-item">
                                <div class="legend-icon player"></div>
                                <span>Player Characters</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-icon ally"></div>
                                <span>Allies</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-icon enemy"></div>
                                <span>Enemies</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-icon current-turn"></div>
                                <span>Current Turn</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Combat Log -->
                <div class="combat-log">
                    <h3>üìú Combat Log</h3>
                    <div id="combat-messages" class="combat-messages">
                        <!-- Combat messages will appear here -->
                    </div>
                </div>
            </div>
        </div>
        
        <!-- AI DM Settings Modal -->
        <div id="ai-dm-settings-modal" class="modal" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>ü§ñ AI Dungeon Master Settings</h3>
                    <button class="modal-close" onclick="this.closest('.modal').style.display='none'">‚úï</button>
                </div>
                <div class="modal-body">
                    <div class="ai-engine-selection">
                        <h4>AI Engine</h4>
                        <div class="radio-group">
                            <label>
                                <input type="radio" name="aiEngine" value="templates" checked>
                                Template-Based (Free, Basic)
                            </label>
                            <label>
                                <input type="radio" name="aiEngine" value="openai">
                                OpenAI GPT (Premium, Dynamic)
                            </label>
                        </div>
                    </div>
                    
                    <div id="openai-settings" style="display: none;">
                        <div class="form-group">
                            <label for="openai-api-key">OpenAI API Key</label>
                            <input type="password" id="openai-api-key" placeholder="sk-...">
                            <small>Get your API key from <a href="https://platform.openai.com/api-keys" target="_blank">OpenAI Platform</a></small>
                        </div>
                        
                        <div class="form-group">
                            <label for="openai-model">Model</label>
                            <select id="openai-model">
                                <option value="gpt-3.5-turbo">GPT-3.5 Turbo (Fast, Economical)</option>
                                <option value="gpt-4">GPT-4 (Best Quality)</option>
                                <option value="gpt-4-turbo-preview">GPT-4 Turbo (Fast, High Quality)</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label for="ai-creativity">Creativity Level</label>
                            <input type="range" id="ai-creativity" min="0" max="100" value="70">
                            <span id="ai-creativity-display">70%</span>
                            <small>Higher = more creative/unpredictable responses</small>
                        </div>
                        
                        <div class="form-group">
                            <label for="ai-response-length">Response Length</label>
                            <select id="ai-response-length">
                                <option value="brief">Brief (1-2 sentences)</option>
                                <option value="normal" selected>Normal (2-4 sentences)</option>
                                <option value="detailed">Detailed (4-6 sentences)</option>
                                <option value="verbose">Verbose (6+ sentences)</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="ai-use-campaign-context" checked>
                                Use Campaign Context (scenario, party, history)
                            </label>
                        </div>
                        
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="ai-use-reference-data" checked>
                                Use D&D Reference Data (monsters, rules, items)
                            </label>
                        </div>
                        
                        <button class="secondary-button" onclick="testOpenAIConnection()">Test Connection</button>
                        <div id="openai-test-result"></div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="secondary-button" onclick="this.closest('.modal').style.display='none'">Cancel</button>
                    <button class="primary-button" onclick="saveAIDMSettings()">Save Settings</button>
                </div>
            </div>
        </div>
        
        <!-- Voice Settings Modal -->
        <div id="voice-settings-modal" class="modal" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">
                    <h3>üé§ Voice Settings</h3>
                    <button class="modal-close" onclick="this.closest('.modal').style.display='none'">‚úï</button>
                </div>
                <div class="modal-body">
                    <div class="voice-engine-selection">
                        <h4>Voice Engine</h4>
                        <div class="radio-group">
                            <label>
                                <input type="radio" name="voiceEngine" value="browser" checked>
                                Browser TTS (Free, Basic Quality)
                            </label>
                            <label>
                                <input type="radio" name="voiceEngine" value="elevenlabs">
                                ElevenLabs (Premium, High Quality)
                            </label>
                        </div>
                    </div>
                    
                    <div id="elevenlabs-settings" class="elevenlabs-settings" style="display: none;">
                        <h4>ElevenLabs Configuration</h4>
                        <div class="form-group">
                            <label for="elevenlabs-api-key">API Key:</label>
                            <input type="password" id="elevenlabs-api-key" placeholder="Enter your ElevenLabs API key" 
                                   value="${localStorage.getItem('elevenlabs_api_key') || ''}">
                            <button type="button" onclick="testElevenLabsAPI()" class="secondary-button">Test API Key</button>
                            <small>Your API key is stored locally and never sent to our servers</small>
                            <div id="elevenlabs-test-result"></div>
                        </div>
                        
                        <div class="form-group">
                            <label for="elevenlabs-voice-id">DM Voice:</label>
                            <select id="elevenlabs-voice-id">
                                <option value="">Loading voices...</option>
                            </select>
                            <button type="button" onclick="loadElevenLabsVoices()" class="secondary-button">Refresh Voices</button>
                        </div>
                        
                        <div class="form-group">
                            <label for="voice-stability">Stability (0-1):</label>
                            <input type="range" id="voice-stability" min="0" max="1" step="0.1" value="0.5">
                            <span id="stability-value">0.5</span>
                        </div>
                        
                        <div class="form-group">
                            <label for="voice-clarity">Clarity & Similarity (0-1):</label>
                            <input type="range" id="voice-clarity" min="0" max="1" step="0.1" value="0.75">
                            <span id="clarity-value">0.75</span>
                        </div>
                        
                        <div class="form-group">
                            <button type="button" onclick="testElevenLabsVoice()" class="primary-button">Test Voice</button>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="secondary-button" onclick="this.closest('.modal').style.display='none'">Cancel</button>
                    <button class="primary-button" onclick="saveVoiceSettings()">Save Settings</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Notification Container -->
    <div id="notification-container" class="notification-container"></div>

    <!-- Simple button handlers that work immediately -->
    <script>
        // Simple screen switching function that works without modules
        // Get current active screen
        function getCurrentScreen() {
            const activeScreen = document.querySelector('.screen.active');
            if (activeScreen) {
                return activeScreen.id.replace('-screen', '');
            }
            return null;
        }
        
        function switchScreen(screenName) {
            console.log('Switching to screen:', screenName);
            
            // Track navigation history (but don't duplicate consecutive entries)
            const currentScreen = getCurrentScreen();
            if (currentScreen && currentScreen !== screenName) {
                // Keep navigation history limited to last 5 screens to avoid memory issues
                if (window.navigationHistory.length >= 5) {
                    window.navigationHistory.shift();
                }
                window.navigationHistory.push(currentScreen);
                console.log('Navigation history:', window.navigationHistory);
            }
            
            // Hide all screens
            const screens = document.querySelectorAll('.screen');
            screens.forEach(screen => {
                screen.style.display = 'none';
                screen.classList.remove('active');
            });
            
            // Show the target screen
            const targetScreen = document.getElementById(screenName + '-screen');
            if (targetScreen) {
                targetScreen.style.display = 'block';
                targetScreen.classList.add('active');
                console.log('Screen shown:', screenName);
                
                // Initialize screen-specific functionality
                if (screenName === 'characterSheet') {
                    // Initialize character sheet tabs when switching to character sheet
                    setTimeout(() => {
                        initializeCharacterSheetTabs();
                        
                        // If no specific character is being viewed, show first party member
                        if (window.partyCharacters && window.partyCharacters.length > 0) {
                            populateCharacterSheet(window.partyCharacters[0]);
                        }
                    }, 100);
                }
            } else {
                console.error('Screen not found:', screenName);
            }
        }
        
        // Add click handlers when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Setting up button handlers...');
            
            // Create New Campaign button
            const createBtn = document.getElementById('create-campaign-btn');
            if (createBtn) {
                createBtn.onclick = function() {
                    console.log('Create Campaign clicked');
                    switchScreen('campaignCreation');
                };
                console.log('Create Campaign button handler attached');
            }
            
            // Continue Campaign button
            const continueBtn = document.getElementById('continue-campaign-btn');
            if (continueBtn) {
                continueBtn.onclick = function() {
                    console.log('Continue Campaign clicked');
                    showCampaignList();
                };
                console.log('Continue Campaign button handler attached');
            }
            
            // Load from GitHub button
            const githubBtn = document.getElementById('load-github-btn');
            if (githubBtn) {
                githubBtn.onclick = function() {
                    console.log('Load from GitHub clicked');
                    alert('GitHub integration will be available soon!');
                };
                console.log('GitHub button handler attached');
            }
            
            // World Browser button
            const worldBtn = document.getElementById('world-browser-btn');
            if (worldBtn) {
                worldBtn.onclick = function() {
                    console.log('World Browser clicked');
                    switchScreen('worldBrowser');
                };
                console.log('World Browser button handler attached');
            }
            
            // Settings button
            const settingsBtn = document.getElementById('settings-btn');
            if (settingsBtn) {
                settingsBtn.onclick = function() {
                    console.log('Settings clicked');
                    switchScreen('settings');
                };
                console.log('Settings button handler attached');
            }
            
            console.log('All button handlers set up');
        });
        
        // Scenario selection function
        function selectScenario(scenarioId) {
            console.log('Selecting scenario:', scenarioId);
            
            // Remove selected class from all scenarios
            const scenarios = document.querySelectorAll('.scenario-option');
            scenarios.forEach(scenario => {
                scenario.classList.remove('selected');
            });
            
            // Add selected class to clicked scenario
            const selectedScenario = document.querySelector(`[data-scenario="${scenarioId}"]`);
            if (selectedScenario) {
                selectedScenario.classList.add('selected');
                
                // Update hidden input value
                const hiddenInput = document.getElementById('selected-scenario');
                if (hiddenInput) {
                    hiddenInput.value = scenarioId;
                }
                
                console.log('Scenario selected:', scenarioId);
            }
        }
        
        // Campaign creation function
        function createCampaign(event) {
            event.preventDefault(); // Prevent form submission
            console.log('Creating campaign...');
            
            // Get form data
            const form = document.getElementById('campaign-creation-form');
            const formData = new FormData(form);
            const campaignData = {
                id: 'campaign_' + Date.now(),
                name: formData.get('campaignName'),
                worldSeed: formData.get('worldSeed'),
                moralComplexity: formData.get('moralComplexity'),
                startingRegion: formData.get('startingRegion'),
                startingScenario: formData.get('startingScenario'),
                createdDate: new Date().toISOString(),
                lastPlayed: new Date().toISOString(),
                characters: [],
                gameState: {
                    currentLocation: 'Starting Region',
                    storyProgress: 0,
                    completedQuests: [],
                    activeQuests: []
                }
            };
            
            console.log('Campaign data:', campaignData);
            
            // Save campaign to localStorage
            saveCampaign(campaignData);
            
            // Set as current campaign
            window.currentCampaign = campaignData;
            
            // Show API setup screen first for new campaigns
            switchScreen('apiSetup');
            setTimeout(() => {
                loadAPISettingsForSetup(null); // Load from localStorage since it's a new campaign
            }, 100);
            
            // Show success message
            alert('Campaign "' + campaignData.name + '" created successfully!');
        }
        
        // Save campaign to localStorage
        function saveCampaign(campaignData) {
            try {
                // Get existing campaigns
                let campaigns = JSON.parse(localStorage.getItem('dnd_campaigns')) || [];
                
                // Find existing campaign or add new one
                const existingIndex = campaigns.findIndex(c => c.id === campaignData.id);
                if (existingIndex >= 0) {
                    campaigns[existingIndex] = campaignData;
                    console.log('Updated existing campaign:', campaignData.name);
                } else {
                    campaigns.push(campaignData);
                    console.log('Added new campaign:', campaignData.name);
                }
                
                // Save to localStorage
                localStorage.setItem('dnd_campaigns', JSON.stringify(campaigns));
                console.log('Campaign saved to localStorage');
                
                return true;
            } catch (error) {
                console.error('Error saving campaign:', error);
                return false;
            }
        }
        
        // Load campaigns from localStorage
        function loadCampaigns() {
            try {
                // Try to get campaigns from the new CampaignManager system first
                if (window.DNDCore && window.DNDCore.getModule('campaignManager')) {
                    const campaignManager = window.DNDCore.getModule('campaignManager');
                    const campaigns = campaignManager.listCampaigns();
                    
                    // Convert the campaigns object to array format for display
                    if (campaigns && typeof campaigns === 'object') {
                        return Object.entries(campaigns).map(([campaignId, campaignInfo]) => {
                            // Try to load the full campaign data
                            const fullCampaignData = localStorage.getItem(`dnd_voice_campaign_${campaignId}`);
                            if (fullCampaignData) {
                                try {
                                    const campaign = JSON.parse(fullCampaignData);
                                    return {
                                        id: campaignId,
                                        name: campaign.meta?.name || campaignInfo.name || 'Untitled Campaign',
                                        startingRegion: campaign.settings?.startingRegion || 'Unknown Region',
                                        lastPlayed: campaignInfo.lastModified || campaign.meta?.lastModified || new Date().toISOString(),
                                        characters: campaign.party?.characters ? Object.values(campaign.party.characters) : [],
                                        gameState: campaign.gameState || {}
                                    };
                                } catch (error) {
                                    console.warn('Failed to parse campaign data for:', campaignId);
                                    return {
                                        id: campaignId,
                                        name: campaignInfo.name || 'Untitled Campaign',
                                        startingRegion: 'Unknown Region',
                                        lastPlayed: campaignInfo.lastModified || new Date().toISOString(),
                                        characters: [],
                                        gameState: {}
                                    };
                                }
                            } else {
                                return {
                                    id: campaignId,
                                    name: campaignInfo.name || 'Untitled Campaign',
                                    startingRegion: 'Unknown Region',
                                    lastPlayed: campaignInfo.lastModified || new Date().toISOString(),
                                    characters: [],
                                    gameState: {}
                                };
                            }
                        });
                    }
                }
                
                // Fallback to legacy system
                return JSON.parse(localStorage.getItem('dnd_campaigns')) || [];
            } catch (error) {
                console.error('Error loading campaigns:', error);
                return [];
            }
        }
        
        // Comprehensive Campaign Data Save - saves everything for AI DM continuity
        async function saveComprehensiveCampaignData() {
            if (!window.currentCampaign) {
                console.error('No current campaign to save');
                return false;
            }

            console.log('üóÑÔ∏è Saving comprehensive campaign database...');

            try {
                // Collect all game data for AI DM context
                const comprehensiveGameState = {
                    // Session metadata
                    sessionInfo: {
                        sessionNumber: (window.currentCampaign.sessionSummaries?.length || 0) + 1,
                        startTime: window.sessionStartTime || Date.now(),
                        endTime: Date.now(),
                        duration: Date.now() - (window.sessionStartTime || Date.now()),
                        playedBy: window.partyCharacters?.map(c => c.name) || []
                    },
                    
                    // Complete DM State
                    dmState: {
                        currentLocation: DM_STATE.currentLocation,
                        currentScene: DM_STATE.currentScene,
                        combatActive: DM_STATE.combatActive,
                        npcsNearby: DM_STATE.npcsNearby,
                        activeNPCs: Array.from(DM_STATE.activeNPCs.entries()),
                        recentEvents: DM_STATE.recentEvents,
                        conversationHistory: DM_STATE.conversationHistory,
                        tensionLevel: DM_STATE.tensionLevel,
                        lastPlayerAction: DM_STATE.lastPlayerAction
                    },
                    
                    // Complete Story State
                    storyState: {
                        currentChapter: STORY_STATE.currentChapter,
                        plotThreads: STORY_STATE.plotThreads,
                        activeQuests: STORY_STATE.activeQuests,
                        completedEvents: STORY_STATE.completedEvents,
                        worldState: STORY_STATE.worldState,
                        narrativeTension: STORY_STATE.narrativeTension,
                        storyBeats: STORY_STATE.storyBeats
                    },
                    
                    // Complete conversation log
                    conversationLog: getConversationHistory(),
                    
                    // Player decisions and consequences
                    playerDecisions: analyzePlayerDecisions(DM_STATE.conversationHistory),
                    
                    // World database for AI context
                    worldDatabase: {
                        locations: await getLocationDatabase(),
                        npcs: await getNPCDatabase(), 
                        quests: await getQuestDatabase(),
                        relationships: await getRelationshipDatabase(),
                        factions: await getFactionDatabase(),
                        lore: await getLoreDatabase(),
                        timeline: DM_STATE.recentEvents || []
                    },
                    
                    // Character progression
                    characterProgression: {
                        party: window.partyCharacters || [],
                        experience: 0,
                        levelUps: [],
                        itemsGained: [],
                        itemsLost: [],
                        spellsLearned: [],
                        skillsImproved: []
                    }
                };

                // Save to campaign
                window.currentCampaign.gameState = comprehensiveGameState;
                window.currentCampaign.lastPlayed = new Date().toISOString();
                
                // Save enhanced data
                const success = saveCampaign(window.currentCampaign);
                
                if (success) {
                    console.log('‚úÖ Comprehensive campaign data saved successfully');
                    console.log(`üìä Saved: ${comprehensiveGameState.conversationLog.length} conversation entries`);
                    console.log(`üìä Saved: ${Object.keys(comprehensiveGameState.worldDatabase.npcs).length} NPCs`);
                    console.log(`üìä Saved: ${comprehensiveGameState.storyState.activeQuests.length} active quests`);
                    return true;
                } else {
                    console.error('‚ùå Failed to save comprehensive data');
                    return false;
                }
                
            } catch (error) {
                console.error('‚ùå Error in comprehensive save:', error);
                return false;
            }
        }

        // Database collection functions
        async function getLocationDatabase() {
            return {
                [DM_STATE.currentLocation]: {
                    name: DM_STATE.currentLocation,
                    type: DM_STATE.currentScene,
                    description: `Location where the party has spent time`,
                    npcsPresent: DM_STATE.npcsNearby,
                    events: DM_STATE.recentEvents,
                    visited: true,
                    lastVisited: new Date().toISOString()
                }
            };
        }

        async function getNPCDatabase() {
            const npcDatabase = {};
            
            for (const [npcName, npcData] of DM_STATE.activeNPCs.entries()) {
                npcDatabase[npcName] = {
                    ...npcData,
                    lastEncounter: new Date().toISOString(),
                    relationshipStatus: 'met',
                    conversationTopics: [],
                    questsInvolved: []
                };
            }
            
            return npcDatabase;
        }

        async function getQuestDatabase() {
            return STORY_STATE.activeQuests.map(quest => ({
                name: quest,
                status: 'active',
                startedDate: new Date().toISOString(),
                objectives: [],
                rewards: [],
                difficulty: 'normal',
                questGiver: 'unknown',
                location: DM_STATE.currentLocation
            }));
        }

        async function getRelationshipDatabase() {
            const relationships = {};
            
            for (const npcName of Array.from(DM_STATE.activeNPCs.keys())) {
                relationships[npcName] = {
                    reputation: 0,
                    trust: 0,
                    lastInteraction: new Date().toISOString(),
                    relationshipType: 'neutral',
                    sharedHistory: []
                };
            }
            
            return relationships;
        }

        async function getFactionDatabase() {
            return {
                'local_village': {
                    name: 'Local Village',
                    reputation: 0,
                    influence: 'local',
                    attitude: 'neutral',
                    members: DM_STATE.npcsNearby
                }
            };
        }

        async function getLoreDatabase() {
            return {
                worldEvents: DM_STATE.recentEvents,
                legends: [],
                history: [],
                rumors: [],
                discoveries: []
            };
        }

        // Analyze player decisions from conversation history
        function analyzePlayerDecisions(conversationHistory) {
            const decisions = {
                majorDecisions: [],
                moralChoices: [],
                strategicChoices: [],
                diplomaticChoices: []
            };

            for (const entry of conversationHistory) {
                if (entry.type === 'player_action') {
                    const action = entry.content.toLowerCase();
                    
                    // Classify decision types
                    if (action.includes('attack') || action.includes('fight') || action.includes('kill')) {
                        decisions.strategicChoices.push({
                            decision: entry.content,
                            timestamp: entry.timestamp,
                            type: 'combat',
                            context: DM_STATE.currentLocation
                        });
                    } else if (action.includes('help') || action.includes('save') || action.includes('rescue')) {
                        decisions.moralChoices.push({
                            decision: entry.content,
                            timestamp: entry.timestamp,
                            type: 'heroic',
                            context: DM_STATE.currentLocation
                        });
                    } else if (action.includes('talk') || action.includes('negotiate') || action.includes('persuade')) {
                        decisions.diplomaticChoices.push({
                            decision: entry.content,
                            timestamp: entry.timestamp,
                            type: 'diplomatic',
                            context: DM_STATE.currentLocation
                        });
                    }
                    
                    // Flag major story decisions
                    if (action.includes('quest') || action.includes('mission') || action.includes('journey')) {
                        decisions.majorDecisions.push({
                            decision: entry.content,
                            timestamp: entry.timestamp,
                            type: 'story',
                            context: DM_STATE.currentLocation
                        });
                    }
                }
            }

            return decisions;
        }

        // Save comprehensive campaign session data (legacy function)
        function saveCurrentCampaignData() {
            if (window.currentCampaign) {
                // Update campaign with current party data
                if (window.partyCharacters) {
                    window.currentCampaign.characters = window.partyCharacters;
                }
                
                // Save API configurations with campaign
                window.currentCampaign.apiConfig = {
                    openai: {
                        enabled: openAIConfig.enabled,
                        apiKey: openAIConfig.apiKey,
                        model: openAIConfig.model,
                        creativity: openAIConfig.creativity,
                        responseLength: openAIConfig.responseLength
                    },
                    elevenlabs: {
                        enabled: elevenLabsConfig.enabled,
                        apiKey: elevenLabsConfig.apiKey,
                        voiceId: elevenLabsConfig.voiceId,
                        stability: elevenLabsConfig.stability,
                        clarity: elevenLabsConfig.clarity
                    }
                };
                
                // Save complete game state
                window.currentCampaign.gameState = {
                    // DM state
                    dmState: {
                        currentLocation: DM_STATE.currentLocation,
                        currentScene: DM_STATE.currentScene,
                        combatActive: DM_STATE.combatActive,
                        npcsNearby: DM_STATE.npcsNearby,
                        activeNPCs: Array.from(DM_STATE.activeNPCs.entries()), // Convert Map to array
                        recentEvents: DM_STATE.recentEvents,
                        conversationHistory: DM_STATE.conversationHistory,
                        tensionLevel: DM_STATE.tensionLevel,
                        lastPlayerAction: DM_STATE.lastPlayerAction
                    },
                    // Story state  
                    storyState: {
                        currentChapter: STORY_STATE.currentChapter,
                        plotThreads: STORY_STATE.plotThreads,
                        activeQuests: STORY_STATE.activeQuests,
                        completedEvents: STORY_STATE.completedEvents,
                        worldState: STORY_STATE.worldState,
                        narrativeTension: STORY_STATE.narrativeTension,
                        storyBeats: STORY_STATE.storyBeats
                    },
                    // Conversation history from UI
                    conversationLog: getConversationHistory(),
                    // Session metadata
                    sessionData: {
                        playTime: Date.now() - (window.sessionStartTime || Date.now()),
                        actionsCount: DM_STATE.conversationHistory.length,
                        lastSaveTime: Date.now()
                    }
                };
                
                // Update last played timestamp
                window.currentCampaign.lastPlayed = new Date().toISOString();
                
                // Save to localStorage
                const success = saveCampaign(window.currentCampaign);
                if (success) {
                    console.log('Comprehensive campaign session saved');
                    return true;
                } else {
                    console.error('Failed to save campaign session');
                    return false;
                }
            }
            return false;
        }

        // ===============================
        // AUTO-SAVE SYSTEM
        // ===============================
        
        // Auto-save interval (5 minutes = 300000ms)
        const AUTO_SAVE_INTERVAL = 5 * 60 * 1000; // 5 minutes
        let autoSaveTimer = null;
        let isAutoSaveEnabled = true;
        
        // Start auto-save timer
        function startAutoSave() {
            // Clear any existing timer
            stopAutoSave();
            
            if (!isAutoSaveEnabled) {
                console.log('Auto-save is disabled');
                return;
            }
            
            console.log('Starting auto-save timer (every 5 minutes)');
            
            autoSaveTimer = setInterval(() => {
                if (window.currentCampaign) {
                    console.log('üîÑ Auto-saving campaign...');
                    const saved = saveCurrentCampaignData();
                    if (saved) {
                        console.log('‚úÖ Auto-save completed successfully');
                        // Show brief notification
                        showNotification('Campaign auto-saved', 'success', 2000);
                    } else {
                        console.error('‚ùå Auto-save failed');
                        showNotification('Auto-save failed', 'error', 3000);
                    }
                } else {
                    console.log('No active campaign to auto-save');
                }
            }, AUTO_SAVE_INTERVAL);
        }
        
        // Stop auto-save timer
        function stopAutoSave() {
            if (autoSaveTimer) {
                clearInterval(autoSaveTimer);
                autoSaveTimer = null;
                console.log('Auto-save timer stopped');
            }
        }
        
        // Enable/disable auto-save
        function setAutoSave(enabled) {
            isAutoSaveEnabled = enabled;
            if (enabled) {
                startAutoSave();
            } else {
                stopAutoSave();
            }
            console.log(`Auto-save ${enabled ? 'enabled' : 'disabled'}`);
        }
        
        // Initialize session tracking
        function initializeSession() {
            if (!window.sessionStartTime) {
                window.sessionStartTime = Date.now();
                console.log('Session started at:', new Date(window.sessionStartTime));
            }
            
            // Start auto-save when session begins
            startAutoSave();
        }
        
        // Show brief notification to user
        function showNotification(message, type = 'info', duration = 3000) {
            // Ensure type is a string to prevent errors
            type = String(type || 'info');
            console.log(`[${type.toUpperCase()}] ${message}`);
            
            // Create notification element
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.textContent = message;
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${type === 'success' ? '#2e7d32' : type === 'error' ? '#c62828' : '#1565c0'};
                color: white;
                padding: 12px 24px;
                border-radius: 4px;
                box-shadow: 0 4px 8px rgba(0,0,0,0.3);
                z-index: 10000;
                font-size: 14px;
                max-width: 300px;
                opacity: 0;
                transform: translateX(100%);
                transition: all 0.3s ease;
            `;
            
            document.body.appendChild(notification);
            
            // Animate in
            setTimeout(() => {
                notification.style.opacity = '1';
                notification.style.transform = 'translateX(0)';
            }, 10);
            
            // Auto-remove after duration
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    if (notification.parentNode) {
                        document.body.removeChild(notification);
                    }
                }, 300);
            }, duration);
        }

        // Get conversation history from the UI
        function getConversationHistory() {
            const historyDiv = document.getElementById('conversation-history');
            if (!historyDiv) return [];
            
            const messages = historyDiv.querySelectorAll('.player-message, .dm-message');
            const conversationLog = [];
            
            messages.forEach((message, index) => {
                const isDM = message.classList.contains('dm-message');
                const content = message.querySelector('.message-content')?.textContent?.trim() || '';
                const timestamp = message.querySelector('.timestamp')?.textContent || new Date().toLocaleTimeString();
                
                conversationLog.push({
                    id: index,
                    type: isDM ? 'dm' : 'player',
                    content: content,
                    timestamp: timestamp,
                    html: message.outerHTML // Save full HTML for restoration
                });
            });
            
            return conversationLog;
        }

        // Load and restore campaign session state
        function loadCampaignSession(campaign) {
            if (campaign.gameState) {
                const gameState = campaign.gameState;
                
                // Restore DM state
                if (gameState.dmState) {
                    DM_STATE.currentLocation = gameState.dmState.currentLocation || 'village';
                    DM_STATE.currentScene = gameState.dmState.currentScene || 'quest_start';
                    DM_STATE.combatActive = gameState.dmState.combatActive || false;
                    DM_STATE.npcsNearby = gameState.dmState.npcsNearby || [];
                    DM_STATE.recentEvents = gameState.dmState.recentEvents || [];
                    DM_STATE.conversationHistory = gameState.dmState.conversationHistory || [];
                    DM_STATE.tensionLevel = gameState.dmState.tensionLevel || 1;
                    DM_STATE.lastPlayerAction = gameState.dmState.lastPlayerAction || '';
                    
                    // Restore activeNPCs Map from saved array
                    DM_STATE.activeNPCs.clear();
                    if (gameState.dmState.activeNPCs) {
                        gameState.dmState.activeNPCs.forEach(([key, value]) => {
                            DM_STATE.activeNPCs.set(key, value);
                        });
                    }
                }
                
                // Restore story state
                if (gameState.storyState) {
                    STORY_STATE.currentChapter = gameState.storyState.currentChapter || 'adventure_start';
                    STORY_STATE.plotThreads = gameState.storyState.plotThreads || [];
                    STORY_STATE.activeQuests = gameState.storyState.activeQuests || [];
                    STORY_STATE.completedEvents = gameState.storyState.completedEvents || [];
                    STORY_STATE.worldState = gameState.storyState.worldState || {};
                    STORY_STATE.narrativeTension = gameState.storyState.narrativeTension || 1;
                    STORY_STATE.storyBeats = gameState.storyState.storyBeats || [];
                }
                
                // Don't restore conversation to UI - just keep it in memory for AI context
                // The recap will be shown instead
                if (gameState.conversationLog && gameState.conversationLog.length > 0) {
                    console.log(`Loaded ${gameState.conversationLog.length} previous conversation entries for AI context`);
                    // Don't call restoreConversationHistory - we want a fresh chat with just the recap
                }
                
                console.log('Campaign session state restored');
                return true;
            }
            
            console.log('No saved session state found - starting fresh');
            return false;
        }

        // Restore conversation history to the UI
        function restoreConversationHistory(conversationLog) {
            const historyDiv = document.getElementById('conversation-history');
            if (!historyDiv) return;
            
            // Clear existing conversation
            historyDiv.innerHTML = '';
            
            // Restore each message
            conversationLog.forEach(logEntry => {
                try {
                    const messageDiv = document.createElement('div');
                    
                    // Handle both old format (string) and new format (object with html property)
                    if (typeof logEntry === 'string') {
                        // Old format - direct HTML string
                        messageDiv.innerHTML = logEntry;
                    } else if (logEntry && logEntry.html) {
                        // New format - object with html property
                        messageDiv.innerHTML = logEntry.html;
                    } else {
                        console.warn('Unknown conversation log format:', logEntry);
                        return;
                    }
                    
                    if (messageDiv.firstElementChild) {
                        historyDiv.appendChild(messageDiv.firstElementChild);
                    }
                } catch (error) {
                    console.error('Error restoring conversation entry:', error);
                }
            });
            
            // Scroll to bottom
            historyDiv.scrollTop = historyDiv.scrollHeight;
            console.log(`Restored ${conversationLog.length} conversation messages`);
        }

        // Comprehensive Save and Exit function
        async function saveAndExitToMainMenu() {
            if (!window.currentCampaign) {
                console.log('No active campaign to save');
                promptToSave('mainMenu');
                return;
            }

            // Show save progress
            showNotification('üìù Saving session and generating summary...', 'info', 5000);

            try {
                // 1. Save comprehensive campaign data
                const success = await saveComprehensiveCampaignData();
                
                if (success) {
                    // 2. Generate session summary
                    const summary = await generateSessionSummary();
                    
                    // 3. Save the summary to the campaign
                    if (summary) {
                        window.currentCampaign.lastSessionSummary = summary;
                        window.currentCampaign.sessionSummaries = window.currentCampaign.sessionSummaries || [];
                        window.currentCampaign.sessionSummaries.push({
                            date: new Date().toISOString(),
                            summary: summary,
                            sessionLength: Date.now() - (window.sessionStartTime || Date.now()),
                            actionsCount: DM_STATE.conversationHistory.length
                        });
                        
                        // Save the updated campaign
                        saveCampaign(window.currentCampaign);
                    }
                    
                    showNotification('‚úÖ Session saved successfully! Summary generated.', 3000, 'success');
                    
                    // Clear session state and go to main menu
                    setTimeout(() => {
                        stopAutoSave();
                        window.currentCampaign = null;
                        window.partyCharacters = [];
                        switchScreen('mainMenu');
                    }, 2000);
                    
                } else {
                    showNotification('‚ùå Failed to save session. Please try again.', 5000, 'error');
                }
                
            } catch (error) {
                console.error('Save and exit failed:', error);
                showNotification('‚ùå Error saving session: ' + error.message, 5000, 'error');
            }
        }

        // Enhanced session summary generation
        async function generateSessionSummary() {
            const conversationLog = getConversationHistory();
            
            if (!conversationLog || conversationLog.length === 0) {
                return "A new adventure begins! The party is ready to embark on their journey.";
            }

            // Get session data for summary
            const sessionData = {
                actions: conversationLog.filter(msg => msg.type === 'player').length,
                dmResponses: conversationLog.filter(msg => msg.type === 'dm').length,
                duration: Date.now() - (window.sessionStartTime || Date.now()),
                location: DM_STATE.currentLocation || 'unknown',
                activeQuests: STORY_STATE.activeQuests || [],
                npcsEncountered: Array.from(DM_STATE.activeNPCs.keys()),
                keyEvents: DM_STATE.recentEvents || []
            };

            // Try AI-powered summary first
            if (window.openAIConfig && window.openAIConfig.apiKey) {
                try {
                    const aiSummary = await generateAISessionSummary(conversationLog, sessionData);
                    if (aiSummary) {
                        return aiSummary;
                    }
                } catch (error) {
                    console.warn('AI summary generation failed, using template:', error);
                }
            }

            // Fallback to template-based summary
            return generateTemplateSummary(conversationLog, sessionData);
        }

        // AI-powered session summary generation
        async function generateAISessionSummary(conversationLog, sessionData) {
            const recentMessages = conversationLog.slice(-15); // Last 15 exchanges
            const conversationText = recentMessages.map(msg => 
                `${msg.type === 'dm' ? 'DM' : 'Player'}: ${msg.content}`
            ).join('\n');

            const systemPrompt = `You are a D&D Dungeon Master creating a brief session recap for players. 

Create a 2-3 sentence summary of what happened in this session. Focus on:
- Key story moments and decisions made
- Combat encounters or challenges faced
- NPCs met and important dialogue
- Quest progress or new plot developments
- Locations explored

Keep it engaging and set up anticipation for the next session. Write in past tense as if recounting events.

Session Data:
- Location: ${sessionData.location}
- Player Actions: ${sessionData.actions}
- Active Quests: ${sessionData.activeQuests.join(', ') || 'None'}
- NPCs Encountered: ${sessionData.npcsEncountered.join(', ') || 'None'}
- Key Events: ${sessionData.keyEvents.join(', ') || 'None'}`;

            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${window.openAIConfig.apiKey}`
                },
                body: JSON.stringify({
                    model: window.openAIConfig.model || 'gpt-3.5-turbo',
                    messages: [
                        { role: 'system', content: systemPrompt },
                        { role: 'user', content: `Recent session activity:\n${conversationText}` }
                    ],
                    max_tokens: 200,
                    temperature: 0.7
                })
            });

            if (response.ok) {
                const data = await response.json();
                return data.choices[0].message.content.trim();
            }
            
            throw new Error('AI API request failed');
        }

        // Template-based session summary fallback
        function generateTemplateSummary(conversationLog, sessionData) {
            let summary = "Last session, the party ";
            
            // Add location context
            if (sessionData.location && sessionData.location !== 'unknown') {
                summary += `explored ${sessionData.location} and `;
            }
            
            // Add action context
            if (sessionData.actions > 5) {
                summary += "had an action-packed adventure with multiple encounters. ";
            } else if (sessionData.actions > 2) {
                summary += "engaged in several key interactions. ";
            } else {
                summary += "began their journey with careful planning. ";
            }
            
            // Add NPC context
            if (sessionData.npcsEncountered.length > 0) {
                summary += `They met ${sessionData.npcsEncountered.slice(0, 2).join(' and ')}, `;
            }
            
            // Add quest context
            if (sessionData.activeQuests.length > 0) {
                summary += `advancing their quest to ${sessionData.activeQuests[0].toLowerCase()}. `;
            } else {
                summary += "setting the stage for their upcoming adventures. ";
            }
            
            return summary + "The story continues...";
        }

        // Initialize AI DM with complete campaign context for continuity
        async function initializeAIDMWithCampaignContext(campaign) {
            if (!campaign.gameState || !window.openAIConfig?.apiKey) {
                console.log('‚ö†Ô∏è AI DM context initialization skipped (no API key or game state)');
                return;
            }

            console.log('üß† Initializing AI DM with complete campaign context...');

            try {
                const gameState = campaign.gameState;
                
                // Build comprehensive context for AI DM
                const dmContextPrompt = `You are the AI Dungeon Master for "${campaign.name}". Here is the complete campaign context you need to remember:

CAMPAIGN OVERVIEW:
- Campaign: ${campaign.scenario || 'Fantasy Adventure'}
- Tone: ${campaign.tone || 'Heroic'}
- Current Session: ${gameState.sessionInfo?.sessionNumber || 1}

PARTY INFORMATION:
${gameState.characterProgression?.party?.map(char => 
`- ${char.name}: Level ${char.level} ${char.race} ${char.class}`).join('\n') || '- No party data available'}

CURRENT WORLD STATE:
- Location: ${gameState.dmState?.currentLocation || 'Unknown'}
- Scene: ${gameState.dmState?.currentScene || 'Unknown'}
- Active Quests: ${gameState.storyState?.activeQuests?.join(', ') || 'None'}
- Tension Level: ${gameState.dmState?.tensionLevel || 1}/5

KNOWN NPCs:
${gameState.worldDatabase?.npcs ? Object.entries(gameState.worldDatabase.npcs).map(([name, npc]) => 
`- ${name}: ${npc.description || 'NPC encountered'}`).join('\n') : '- No NPCs recorded'}

RECENT EVENTS:
${gameState.dmState?.recentEvents?.map(event => `- ${event}`).join('\n') || '- No recent events'}

PLAYER DECISION PATTERNS:
- Major Decisions: ${gameState.playerDecisions?.majorDecisions?.length || 0}
- Moral Choices: ${gameState.playerDecisions?.moralChoices?.length || 0} 
- Combat Choices: ${gameState.playerDecisions?.strategicChoices?.length || 0}
- Diplomatic Choices: ${gameState.playerDecisions?.diplomaticChoices?.length || 0}

LAST SESSION SUMMARY:
${campaign.lastSessionSummary || 'This is the beginning of the adventure.'}

Remember this context for ALL future interactions. Maintain continuity with this information.`;

                // Send context initialization to AI (non-visible to player)
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${window.openAIConfig.apiKey}`
                    },
                    body: JSON.stringify({
                        model: window.openAIConfig.model || 'gpt-3.5-turbo',
                        messages: [
                            { role: 'system', content: dmContextPrompt },
                            { role: 'user', content: 'Acknowledge that you understand and remember this campaign context. Just say "Context loaded" and nothing else.' }
                        ],
                        max_tokens: 50,
                        temperature: 0.3
                    })
                });

                if (response.ok) {
                    console.log('‚úÖ AI DM campaign context loaded successfully');
                } else {
                    console.warn('‚ö†Ô∏è Failed to initialize AI DM context');
                }

            } catch (error) {
                console.error('‚ùå AI DM context initialization failed:', error);
            }
        }

        // Show episode-style session recap when continuing campaign
        async function showSessionRecap(campaign) {
            if (!campaign.lastSessionSummary && (!campaign.sessionSummaries || campaign.sessionSummaries.length === 0)) {
                console.log('No session recap to show - this is the first session');
                return;
            }

            console.log('üì∫ Displaying session recap...');

            // Get the most recent session summary
            const latestSummary = campaign.lastSessionSummary || 
                (campaign.sessionSummaries && campaign.sessionSummaries.length > 0 ? 
                campaign.sessionSummaries[campaign.sessionSummaries.length - 1].summary : null);

            if (!latestSummary) return;

            // Create episode-style recap message
            const recapMessage = `
                <div class="message dm-message episode-recap">
                    <div class="message-header">
                        <span class="speaker">üì∫ Previously on Taylor's Epic D&D Time...</span>
                        <span class="timestamp">${new Date().toLocaleTimeString()}</span>
                    </div>
                    <div class="message-content episode-content">
                        <div class="episode-intro">
                            <strong>Session Recap</strong>
                        </div>
                        <p>${latestSummary}</p>
                        <div class="episode-outro">
                            <em>The adventure continues...</em>
                        </div>
                    </div>
                    ${getDMActionButtons()}
                </div>
            `;

            // Add recap to conversation
            setTimeout(() => {
                appendToConversation(recapMessage);
                
                // Add special styling for episode recap
                const style = document.createElement('style');
                style.textContent = `
                    .episode-recap {
                        border-left: 4px solid #DAA520 !important;
                        background: linear-gradient(135deg, #2a2a2a, #3a3a2a) !important;
                    }
                    .episode-recap .speaker {
                        color: #DAA520 !important;
                        font-weight: bold;
                    }
                    .episode-content {
                        font-style: italic;
                        padding: 15px;
                        background: rgba(218, 165, 32, 0.1);
                        border-radius: 8px;
                        margin: 10px 0;
                    }
                    .episode-intro {
                        color: #DAA520;
                        font-size: 14px;
                        margin-bottom: 10px;
                        text-transform: uppercase;
                        letter-spacing: 1px;
                    }
                    .episode-outro {
                        margin-top: 15px;
                        text-align: center;
                        color: #888;
                        font-size: 12px;
                    }
                `;
                
                if (!document.querySelector('#episode-recap-styles')) {
                    style.id = 'episode-recap-styles';
                    document.head.appendChild(style);
                }

                // Play TTS if enabled
                if (window.isTTSEnabled) {
                    speakText(`Previously on Taylor's Epic D&D Time: ${latestSummary}`);
                }

                console.log('‚úÖ Session recap displayed');
            }, 1000);
        }

        // Generate session recap using AI or template
        async function generateSessionRecap(campaign) {
            if (!campaign.gameState || !campaign.gameState.conversationLog) {
                return null;
            }
            
            const conversationLog = campaign.gameState.conversationLog;
            const lastSession = conversationLog.slice(-10); // Last 10 messages
            
            if (lastSession.length === 0) {
                return null;
            }
            
            // Try to use OpenAI for recap if available
            if (openAIConfig.enabled && openAIConfig.apiKey) {
                try {
                    const summary = lastSession.map(msg => 
                        `${msg.type === 'dm' ? 'DM' : 'Player'}: ${msg.content}`
                    ).join('\n');
                    
                    const response = await fetch('https://api.openai.com/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${openAIConfig.apiKey}`
                        },
                        body: JSON.stringify({
                            model: 'gpt-3.5-turbo',
                            messages: [
                                {
                                    role: 'system',
                                    content: 'You are a D&D Dungeon Master. Provide a brief 2-3 sentence recap of what happened in the last session based on the conversation log. Be engaging and set up for continuing the adventure.'
                                },
                                {
                                    role: 'user',
                                    content: `Last session conversation:\n${summary}`
                                }
                            ],
                            max_tokens: 150,
                            temperature: 0.7
                        })
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        return data.choices[0].message.content;
                    }
                } catch (error) {
                    console.error('Failed to generate AI recap:', error);
                }
            }
            
            // Fallback to template recap
            const dmState = campaign.gameState.dmState;
            const location = dmState?.currentLocation || 'unknown location';
            const npcs = dmState?.npcsNearby?.length > 0 ? ` You were interacting with ${dmState.npcsNearby.join(', ')}.` : '';
            const lastAction = dmState?.lastPlayerAction ? ` Your last action was: "${dmState.lastPlayerAction}".` : '';
            
            return `Welcome back, adventurers! Last session, you were in ${location}.${npcs}${lastAction} The adventure continues from where you left off...`;
        }
        
        // Display session recap to player
        function displaySessionRecap(recap) {
            if (!recap) {
                console.log('No recap to display');
                return;
            }
            
            console.log('Displaying session recap:', recap);
            
            // IMPORTANT: Clear conversation history for the new session
            // Players only see the recap, not old messages
            const history = document.getElementById('conversation-history');
            if (history) {
                history.innerHTML = '';
                console.log('Cleared old conversation from display (kept in memory for AI)');
            }
            
            // Create recap message and add to conversation
            const recapHTML = `
                <div class="dm-message voice-message episode-recap">
                    <div class="message-header">
                        <strong>üé≠ Dungeon Master</strong>
                        <span class="voice-indicator-small">üîä</span>
                        <span class="timestamp">${new Date().toLocaleTimeString()}</span>
                    </div>
                    <div class="message-content">
                        <h3 class="recap-title">üìú Previously on Taylor's Epic D&D Time...</h3>
                        <p class="recap-content">${recap}</p>
                        <p class="recap-footer"><em>The adventure continues from where you left off...</em></p>
                    </div>
                </div>
            `;
            
            // Add ONLY the recap to conversation (not old messages)
            appendToConversation(recapHTML);
            
            // Speak the recap automatically
            setTimeout(() => {
                speakAsDM(`Previously on Taylor's Epic D&D Time... ${recap} The adventure continues...`);
            }, 500);
            
            // Add to DM conversation history for continuity
            addToConversationHistory('dm_response', recap);
            
            console.log('Session recap displayed successfully');
        }
        
        // Restore API configuration from campaign
        function restoreAPIConfiguration(campaign) {
            if (campaign.apiConfig) {
                console.log('üîß Restoring API configuration from campaign:', campaign.apiConfig);
                
                // Restore OpenAI config
                if (campaign.apiConfig.openai) {
                    openAIConfig.enabled = campaign.apiConfig.openai.enabled || false;
                    openAIConfig.apiKey = campaign.apiConfig.openai.apiKey || '';
                    openAIConfig.model = campaign.apiConfig.openai.model || 'gpt-3.5-turbo';
                    openAIConfig.creativity = campaign.apiConfig.openai.creativity || 0.7;
                    openAIConfig.responseLength = campaign.apiConfig.openai.responseLength || 150;
                    
                    // Update localStorage
                    if (openAIConfig.apiKey) {
                        localStorage.setItem('openai_api_key', openAIConfig.apiKey);
                        localStorage.setItem('openai_enabled', openAIConfig.enabled);
                    }
                    
                    console.log('‚úÖ OpenAI config restored:', openAIConfig.enabled);
                }
                
                // Restore ElevenLabs config
                if (campaign.apiConfig.elevenlabs) {
                    elevenLabsConfig.enabled = campaign.apiConfig.elevenlabs.enabled || false;
                    elevenLabsConfig.apiKey = campaign.apiConfig.elevenlabs.apiKey || '';
                    elevenLabsConfig.voiceId = campaign.apiConfig.elevenlabs.voiceId || '';
                    elevenLabsConfig.stability = campaign.apiConfig.elevenlabs.stability || 0.5;
                    elevenLabsConfig.clarity = campaign.apiConfig.elevenlabs.clarity || 0.75;
                    
                    // Update localStorage
                    if (elevenLabsConfig.apiKey) {
                        localStorage.setItem('elevenlabs_api_key', elevenLabsConfig.apiKey);
                        localStorage.setItem('elevenlabs_voice_id', elevenLabsConfig.voiceId);
                        localStorage.setItem('voice_engine', elevenLabsConfig.enabled ? 'elevenlabs' : 'browser');
                    }
                    
                    console.log('‚úÖ ElevenLabs config restored:', elevenLabsConfig.enabled);
                }
            } else {
                console.log('No API config found in campaign, using localStorage defaults');
            }
        }
        
        // Navigation context tracking
        window.navigationHistory = [];
        
        // Function to determine appropriate return screen for character sheet
        function getCharacterSheetReturnScreen() {
            // If we have a current campaign and came from the game screen, return to game
            if (window.currentCampaign && window.navigationHistory.length > 0) {
                const previousScreen = window.navigationHistory[window.navigationHistory.length - 1];
                if (previousScreen === 'game') {
                    return 'game';
                }
            }
            
            // Default to main menu
            return 'mainMenu';
        }
        
        // Prompt to save before navigating away
        function promptToSave(targetScreen) {
            // Special handling for character sheet exit
            if (targetScreen === 'mainMenu' && getCurrentScreen() === 'characterSheet') {
                const returnScreen = getCharacterSheetReturnScreen();
                if (returnScreen === 'game') {
                    // Return to game screen instead of main menu
                    switchScreen('game');
                    return;
                }
            }
            
            if (window.currentCampaign && targetScreen === 'mainMenu') {
                const shouldSave = confirm('Do you want to save your current campaign progress before returning to the main menu?');
                if (shouldSave) {
                    const saved = saveCurrentCampaignData();
                    if (saved) {
                        alert('Campaign saved successfully!');
                    } else {
                        alert('Failed to save campaign. Please try again.');
                        return; // Don't navigate if save failed
                    }
                }
                
                // Stop auto-save and clear current campaign when going to main menu
                stopAutoSave();
                window.currentCampaign = null;
                window.partyCharacters = [];
            }
            
            // Proceed with navigation
            switchScreen(targetScreen);
        }
        
        // Character parsing function
        function parseCharacterSheet() {
            const textarea = document.getElementById('character-import-text');
            const text = textarea.value.trim();
            
            if (!text) {
                alert('Please paste character sheet data first!');
                return;
            }
            
            console.log('Parsing character sheet...');
            
            try {
                const character = parseCharacterData(text);
                console.log('Parsed character:', character);
                
                // Add character to party
                addCharacterToParty(character);
                
                // Close the modal
                document.getElementById('import-modal').style.display = 'none';
                
                // Clear the textarea
                textarea.value = '';
                
                alert('Character "' + character.name + '" imported successfully!');
                
            } catch (error) {
                console.error('Error parsing character:', error);
                alert('Error parsing character sheet. Please check the format.');
            }
        }
        
        // Parse the character data from the text format
        function parseCharacterData(text) {
            const lines = text.split('\n');
            const character = {
                // Basic info
                name: '',
                class: '',
                level: 1,
                species: '',
                background: '',
                alignment: '',
                
                // Ability scores
                abilities: {
                    strength: 10, dexterity: 10, constitution: 10,
                    intelligence: 10, wisdom: 10, charisma: 10
                },
                
                // Combat stats
                combat: {
                    armorClass: 10,
                    hitPoints: { current: 1, max: 1 },
                    initiative: 0,
                    speed: 30,
                    proficiencyBonus: 2
                },
                
                // Skills and saves
                savingThrows: {},
                skills: {},
                
                // Equipment and weapons
                weapons: [],
                equipment: {},
                
                // Features and traits
                features: [],
                
                // Other data
                proficiencies: {
                    armor: '', weapons: '', tools: '', languages: ''
                },
                personality: {
                    traits: '', ideals: '', bonds: '', flaws: ''
                },
                currency: {
                    cp: 0, sp: 0, ep: 0, gp: 0, pp: 0
                }
            };
            
            let currentSection = '';
            
            for (let line of lines) {
                line = line.trim();
                
                // Skip comments and empty lines
                if (line.startsWith('#') || !line) continue;
                
                // Check for section headers
                if (line.startsWith('[') && line.endsWith(']')) {
                    currentSection = line.slice(1, -1);
                    continue;
                }
                
                // Parse key=value pairs
                if (line.includes('=')) {
                    const [key, value] = line.split('=', 2);
                    const cleanKey = key.trim();
                    const cleanValue = value.trim();
                    
                    switch (currentSection) {
                        case 'CHARACTER_INFO':
                            if (cleanKey === 'name') character.name = cleanValue;
                            else if (cleanKey === 'class') character.class = cleanValue;
                            else if (cleanKey === 'level') character.level = parseInt(cleanValue);
                            else if (cleanKey === 'species') character.species = cleanValue;
                            else if (cleanKey === 'background') character.background = cleanValue;
                            else if (cleanKey === 'alignment') character.alignment = cleanValue;
                            break;
                            
                        case 'ABILITY_SCORES':
                            if (cleanKey in character.abilities) {
                                character.abilities[cleanKey] = parseInt(cleanValue);
                            }
                            break;
                            
                        case 'COMBAT_STATS':
                            if (cleanKey === 'armor_class') character.combat.armorClass = parseInt(cleanValue);
                            else if (cleanKey === 'hit_points_max') character.combat.hitPoints.max = parseInt(cleanValue);
                            else if (cleanKey === 'hit_points_current') character.combat.hitPoints.current = parseInt(cleanValue);
                            else if (cleanKey === 'initiative') character.combat.initiative = cleanValue;
                            else if (cleanKey === 'speed') character.combat.speed = parseInt(cleanValue);
                            else if (cleanKey === 'proficiency_bonus') character.combat.proficiencyBonus = cleanValue;
                            break;
                            
                        case 'SAVING_THROWS':
                            character.savingThrows[cleanKey] = cleanValue;
                            break;
                            
                        case 'SKILLS':
                            character.skills[cleanKey] = cleanValue;
                            break;
                            
                        case 'WEAPONS':
                            if (cleanKey.startsWith('weapon_')) {
                                const weaponData = cleanValue.split(',');
                                if (weaponData.length >= 3) {
                                    character.weapons.push({
                                        name: weaponData[0],
                                        attackBonus: weaponData[1],
                                        damage: weaponData[2],
                                        properties: weaponData[3] || ''
                                    });
                                }
                            }
                            break;
                            
                        case 'EQUIPMENT':
                            if (!cleanKey.includes('_qty') && !cleanKey.includes('total_') && !cleanKey.includes('encumbered') && !cleanKey.includes('max_carry')) {
                                const equipData = cleanValue.split(',');
                                character.equipment[cleanKey] = {
                                    quantity: parseInt(equipData[0]) || 1,
                                    weight: parseInt(equipData[1]) || 0
                                };
                            }
                            break;
                            
                        case 'PROFICIENCIES':
                            if (cleanKey === 'armor') character.proficiencies.armor = cleanValue;
                            else if (cleanKey === 'weapons') character.proficiencies.weapons = cleanValue;
                            else if (cleanKey === 'tools') character.proficiencies.tools = cleanValue;
                            else if (cleanKey === 'languages') character.proficiencies.languages = cleanValue;
                            break;
                            
                        case 'PERSONALITY':
                            if (cleanKey === 'personality_traits') character.personality.traits = cleanValue;
                            else if (cleanKey === 'ideals') character.personality.ideals = cleanValue;
                            else if (cleanKey === 'bonds') character.personality.bonds = cleanValue;
                            else if (cleanKey === 'flaws') character.personality.flaws = cleanValue;
                            break;
                            
                        case 'CURRENCY':
                            if (cleanKey === 'copper_pieces') character.currency.cp = parseInt(cleanValue);
                            else if (cleanKey === 'silver_pieces') character.currency.sp = parseInt(cleanValue);
                            else if (cleanKey === 'electrum_pieces') character.currency.ep = parseInt(cleanValue);
                            else if (cleanKey === 'gold_pieces') character.currency.gp = parseInt(cleanValue);
                            else if (cleanKey === 'platinum_pieces') character.currency.pp = parseInt(cleanValue);
                            break;
                            
                        case 'FEATURES_TRAITS':
                            if (cleanValue && !cleanValue.startsWith('#')) {
                                character.features.push({
                                    name: cleanKey.replace(/_/g, ' '),
                                    description: cleanValue
                                });
                            }
                            break;
                    }
                }
            }
            
            return character;
        }
        
        // Add character to the party display
        function addCharacterToParty(character) {
            const partyList = document.getElementById('party-list');
            const emptyParty = partyList.querySelector('.empty-party');
            
            // Remove empty party message
            if (emptyParty) {
                emptyParty.remove();
            }
            
            // Remove existing "Add Another Character" button if it exists
            const existingAddBtn = partyList.querySelector('.add-another-character');
            if (existingAddBtn) {
                existingAddBtn.remove();
            }
            
            // Create character card
            const characterCard = document.createElement('div');
            characterCard.className = 'character-card';
            characterCard.innerHTML = `
                <div class="character-info">
                    <h4>${character.name}</h4>
                    <p>Level ${character.level} ${character.species} ${character.class}</p>
                    <p>AC: ${character.combat.armorClass} | HP: ${character.combat.hitPoints.current}/${character.combat.hitPoints.max}</p>
                </div>
                <div class="character-actions">
                    <button class="secondary-button" onclick="editCharacter('${character.name}')">Edit</button>
                    <button class="secondary-button" onclick="viewCharacterSheet('${character.name}')">View Sheet</button>
                    <button class="danger-button" onclick="removeCharacter('${character.name}')">Remove</button>
                </div>
            `;
            
            partyList.appendChild(characterCard);
            
            // Add "Add Another Character" button after all characters
            const addAnotherBtn = document.createElement('div');
            addAnotherBtn.className = 'add-another-character';
            addAnotherBtn.innerHTML = `
                <button class="secondary-button" onclick="document.getElementById('import-modal').style.display='flex'">
                    <span class="button-icon">‚ûï</span>
                    Add Another Character
                </button>
            `;
            partyList.appendChild(addAnotherBtn);
            
            // Show character actions section
            document.getElementById('character-actions').style.display = 'block';
            
            // Store character data (in a real app this would go to a database)
            if (!window.partyCharacters) window.partyCharacters = [];
            window.partyCharacters.push(character);
        }
        
        // Remove character from party
        function removeCharacter(characterName) {
            if (confirm(`Remove ${characterName} from the party?`)) {
                // Remove from party array
                if (window.partyCharacters) {
                    window.partyCharacters = window.partyCharacters.filter(c => c.name !== characterName);
                }
                
                // Remove from DOM
                const partyList = document.getElementById('party-list');
                const characterCards = partyList.querySelectorAll('.character-card');
                
                characterCards.forEach(card => {
                    const nameElement = card.querySelector('h4');
                    if (nameElement && nameElement.textContent === characterName) {
                        card.remove();
                    }
                });
                
                // If no characters left, show empty party message
                if (!window.partyCharacters || window.partyCharacters.length === 0) {
                    const addAnotherBtn = partyList.querySelector('.add-another-character');
                    if (addAnotherBtn) {
                        addAnotherBtn.remove();
                    }
                    
                    const emptyParty = document.createElement('div');
                    emptyParty.className = 'empty-party';
                    emptyParty.innerHTML = `
                        <p>No characters in party. Import or create characters to get started.</p>
                        <button class="primary-button" onclick="document.getElementById('import-modal').style.display='flex'">
                            <span class="button-icon">üë•</span>
                            Add First Character
                        </button>
                    `;
                    partyList.appendChild(emptyParty);
                    
                    // Hide character actions
                    document.getElementById('character-actions').style.display = 'none';
                }
            }
        }
        
        // View character sheet function
        function viewCharacterSheet(characterName) {
            const character = window.partyCharacters?.find(c => c.name === characterName);
            if (!character) {
                alert('Character not found!');
                return;
            }
            
            // Populate character sheet fields
            populateCharacterSheet(character);
            
            // Switch to character sheet screen
            switchScreen('characterSheet');
            
            // Initialize tab functionality
            setTimeout(() => {
                initializeCharacterSheetTabs();
            }, 100);
        }
        
        // ===============================
        // CHARACTER SHEET TAB SYSTEM
        // ===============================
        
        // Initialize character sheet tabs
        function initializeCharacterSheetTabs() {
            const tabButtons = document.querySelectorAll('.character-tabs .tab-button');
            
            tabButtons.forEach(button => {
                button.addEventListener('click', function() {
                    const tabName = this.getAttribute('data-tab');
                    switchCharacterTab(tabName);
                });
            });
            
            console.log('Character sheet tabs initialized');
        }
        
        // Switch character sheet tab
        function switchCharacterTab(tabName) {
            // Remove active class from all tab buttons
            const tabButtons = document.querySelectorAll('.character-tabs .tab-button');
            tabButtons.forEach(button => {
                button.classList.remove('active');
            });
            
            // Add active class to clicked tab button
            const activeButton = document.querySelector(`.character-tabs .tab-button[data-tab="${tabName}"]`);
            if (activeButton) {
                activeButton.classList.add('active');
            }
            
            // Hide all tab panels
            const tabPanels = document.querySelectorAll('.tab-panel');
            tabPanels.forEach(panel => {
                panel.classList.remove('active');
            });
            
            // Show selected tab panel
            const activePanel = document.getElementById(tabName + '-tab');
            if (activePanel) {
                activePanel.classList.add('active');
            }
            
            console.log('Switched to character sheet tab:', tabName);
        }
        
        // Populate character sheet with character data
        function populateCharacterSheet(character) {
            // Basic info
            document.getElementById('character-name').textContent = character.name;
            document.getElementById('character-class-level').textContent = `Level ${character.level} ${character.class}`;
            document.getElementById('character-race').textContent = character.species;
            
            // Combat stats
            document.getElementById('ac-value').textContent = character.combat.armorClass;
            document.getElementById('max-hp').textContent = character.combat.hitPoints.max;
            document.getElementById('current-hp').value = character.combat.hitPoints.current;
            document.getElementById('speed-value').textContent = character.combat.speed + ' ft';
            document.getElementById('prof-bonus').textContent = character.combat.proficiencyBonus;
            
            // Ability scores
            for (const [ability, score] of Object.entries(character.abilities)) {
                const modifier = Math.floor((score - 10) / 2);
                const modifierStr = modifier >= 0 ? `+${modifier}` : `${modifier}`;
                
                document.getElementById(`${ability.substring(0, 3)}-score`).textContent = score;
                document.getElementById(`${ability.substring(0, 3)}-mod`).textContent = modifierStr;
            }
            
            // Add character to switcher dropdown
            const switcher = document.getElementById('character-switcher');
            if (switcher && !Array.from(switcher.options).some(opt => opt.value === character.name)) {
                const option = document.createElement('option');
                option.value = character.name;
                option.textContent = character.name;
                option.selected = true;
                switcher.appendChild(option);
            }
            
            console.log('Character sheet populated for:', character.name);
        }
        
        // Edit character function (placeholder)
        function editCharacter(characterName) {
            alert('Edit character functionality will be available soon!');
        }
        
        // Load and display saved campaigns
        function showCampaignList() {
            const campaigns = loadCampaigns();
            const contentDiv = document.getElementById('campaign-list-content');
            
            if (campaigns.length === 0) {
                contentDiv.innerHTML = `
                    <div class="empty-state">
                        <p>No saved campaigns found.</p>
                        <button class="primary-button" onclick="switchScreen('campaignCreation')">Create New Campaign</button>
                    </div>
                `;
            } else {
                let campaignsHTML = '<div class="campaigns-grid">';
                
                campaigns.forEach(campaign => {
                    const lastPlayed = new Date(campaign.lastPlayed).toLocaleDateString();
                    const characterCount = campaign.characters ? campaign.characters.length : 0;
                    
                    // Ensure we have a campaign name (fallback chain)
                    const campaignName = campaign.name || campaign.meta?.name || 'Untitled Campaign';
                    const region = campaign.startingRegion || campaign.settings?.startingRegion || 'Unknown Region';
                    
                    // Determine campaign status
                    let statusText = 'üÜï New Campaign';
                    let statusClass = 'new-campaign';
                    
                    if (campaign.gameState && campaign.gameState.timeline && campaign.gameState.timeline.length > 1) {
                        statusText = 'üéØ In Progress';
                        statusClass = 'active-campaign';
                    } else if (characterCount > 0) {
                        statusText = 'üë• Characters Created';
                        statusClass = 'setup-campaign';
                    }
                    
                    campaignsHTML += `
                        <div class="campaign-card">
                            <div class="campaign-info">
                                <h3>${campaignName}</h3>
                                <div class="campaign-status ${statusClass}">
                                    <span>${statusText}</span>
                                </div>
                                <p><strong>Region:</strong> ${region}</p>
                                <p><strong>Characters:</strong> ${characterCount}</p>
                                <p><strong>Last Played:</strong> ${lastPlayed}</p>
                            </div>
                            <div class="campaign-actions">
                                <button class="primary-button" onclick="loadCampaign('${campaign.id}')">Continue</button>
                                <button class="secondary-button" onclick="deleteCampaign('${campaign.id}')">Delete</button>
                            </div>
                        </div>
                    `;
                });
                
                campaignsHTML += '</div>';
                campaignsHTML += `
                    <div class="campaign-list-actions">
                        <button class="primary-button" onclick="switchScreen('campaignCreation')">Create New Campaign</button>
                    </div>
                `;
                
                contentDiv.innerHTML = campaignsHTML;
            }
            
            switchScreen('campaignList');
        }
        
        // Load a specific campaign
        function loadCampaign(campaignId) {
            console.log('üé≤ Loading campaign:', campaignId);
            
            // Use the campaign manager module for loading
            if (window.DNDCore && window.DNDCore.getModule('campaignManager')) {
                const campaignManager = window.DNDCore.getModule('campaignManager');
                const campaign = campaignManager.loadCampaign(campaignId);
                
                if (campaign) {
                    console.log('‚úÖ Campaign loaded successfully:', campaign.meta?.name || 'Unknown Campaign');
                    
                    // Set as current campaign for legacy systems
                    window.currentCampaign = campaign;
                    
                    // Show notification instead of alert
                    const ui = window.DNDCore.getModule('ui');
                    ui?.showNotification(`Campaign "${campaign.meta?.name || 'Unknown Campaign'}" loaded!`, 'success');
                    
                    // Navigate to appropriate screen based on campaign state
                    if (campaign.party?.characters && Object.keys(campaign.party.characters).length > 0) {
                        // Has characters - check if has active session
                        if (campaign.gameState?.timeline && campaign.gameState.timeline.length > 1) {
                            console.log('üìú Found existing session data - continuing adventure');
                            
                            // Show loading then go to game
                            ui?.showScreen('loading');
                            setTimeout(() => {
                                populateGameScreen();
                                ui?.showScreen('game');
                                
                                // Generate and display session recap
                                setTimeout(async () => {
                                    const recap = await generateSessionRecap(campaign.gameState);
                                    displaySessionRecap(recap);
                                }, 1000);
                            }, 1500);
                        } else {
                            console.log('üèÉ Has characters but no session data - setup API then continue');
                            ui?.showScreen('apiSetup');
                        }
                    } else {
                        console.log('üë• No characters found - start character creation');
                        ui?.showScreen('characterSetup');
                    }
                } else {
                    console.error('‚ùå Failed to load campaign');
                    const ui = window.DNDCore.getModule('ui');
                    ui?.showNotification('Failed to load campaign', 'error');
                }
            } else {
                console.warn('‚ö†Ô∏è Campaign manager not available - using fallback');
                // Fallback to legacy loading
                const campaigns = loadCampaigns();
                const campaign = campaigns.find(c => c.id === campaignId);
                
                if (campaign) {
                    console.log('Loading campaign (fallback):', campaign.name);
                    window.currentCampaign = campaign;
                    alert('Loaded campaign: ' + (campaign.name || 'Untitled Campaign'));
                    
                    // Navigate based on campaign state
                    if (campaign.characters && campaign.characters.length > 0) {
                        switchScreen('apiSetup');
                    } else {
                        switchScreen('characterSetup');
                    }
                } else {
                    alert('Campaign not found!');
                }
            }
        }
        
        // Delete a campaign
        function deleteCampaign(campaignId) {
            if (confirm('Are you sure you want to delete this campaign? This action cannot be undone.')) {
                let campaigns = loadCampaigns();
                campaigns = campaigns.filter(c => c.id !== campaignId);
                localStorage.setItem('dnd_campaigns', JSON.stringify(campaigns));
                
                // Refresh the campaign list
                showCampaignList();
                
                alert('Campaign deleted successfully.');
            }
        }
        
        // Continue to game function
        async function continueToGame() {
            console.log('Continuing to game...');
            
            // Initialize session tracking and auto-save
            initializeSession();
            
            // Save current party to campaign
            if (window.currentCampaign) {
                saveCurrentCampaignData();
            }
            
            // Populate game screen with party data
            populateGameScreen();
            
            // Switch to game screen
            switchScreen('game');
            
            // Check if campaign has existing session data
            const campaign = window.currentCampaign;
            if (campaign && campaign.gameState && campaign.gameState.conversationLog && campaign.gameState.conversationLog.length > 0) {
                console.log('Continuing existing session...');
                
                // Initialize AI DM with complete campaign context
                await initializeAIDMWithCampaignContext(campaign);
                
                // Load campaign state into memory (for AI context)
                loadCampaignSession(campaign);
                
                // Show session recap (episode-style introduction)
                await showSessionRecap(campaign);
            } else {
                console.log('Starting new session...');
                
                // Start the adventure with opening narration for new campaigns
                setTimeout(() => {
                    // Disabled - using startInitialStory() instead for proper scenario-based narration
                    // startAdventureNarration();
                }, 500);
            }
        }
        
        // Populate game screen with party data
        function populateGameScreen() {
            const gamePartyList = document.getElementById('game-party-list');
            if (gamePartyList && window.partyCharacters && window.partyCharacters.length > 0) {
                gamePartyList.innerHTML = '';
                window.partyCharacters.forEach(character => {
                    const partyMember = document.createElement('div');
                    partyMember.className = 'party-member';
                    partyMember.innerHTML = `
                        <div class="member-info">
                            <strong>${character.name}</strong>
                            <span>Level ${character.level} ${character.species} ${character.class}</span>
                        </div>
                        <div class="member-stats">
                            <span>AC: ${character.combat.armorClass}</span>
                            <span>HP: ${character.combat.hitPoints.current}/${character.combat.hitPoints.max}</span>
                        </div>
                    `;
                    gamePartyList.appendChild(partyMember);
                });
            }
            
            // Initialize the adventure conversation when game screen loads
            setTimeout(() => {
                initializeVoiceSystem();
                // Only initialize adventure if we're not starting a new campaign
                // (new campaigns already get narration from startAdventureNarration)
                const campaign = window.currentCampaign;
                const hasExistingSession = campaign && campaign.gameState && campaign.gameState.conversationLog && campaign.gameState.conversationLog.length > 0;
                if (hasExistingSession) {
                    console.log('Continuing existing session - showing recap only');
                    // Don't show old chat history - just clear it for the new session
                    const history = document.getElementById('conversation-history');
                    if (history) {
                        history.innerHTML = '';
                    }
                    
                    // The recap will be shown by showSessionRecap() in continueToGame()
                    // The AI DM has the context from DM_STATE.conversationHistory
                    console.log('Previous conversation is stored in DM_STATE for AI context');
                } else {
                    console.log('New session - initializing with proper scenario-based narration');
                    // Call initializeAdventure() for new campaigns to get proper goblin scenario narration
                    initializeAdventure();
                }
                
                // Initialize battlemap system and generate default content
                setTimeout(() => {
                    initializeBattlemap();
                    
                    // Generate a default village map for new campaigns
                    generateMap('village');
                    drawMap();
                    
                    // Also try to initialize the tactical battle map if available
                    if (window.DNDCore && window.DNDCore.getModule) {
                        const tacticalMap = window.DNDCore.getModule('tacticalBattleMap');
                        if (tacticalMap) {
                            console.log('üó∫Ô∏è Initializing tactical battle map with village');
                            tacticalMap.testVillageMap();
                        }
                    }
                    
                    // Add player tokens to map
                    const party = window.partyCharacters || [];
                    if (party.length > 0) {
                        party.forEach((char, index) => {
                            const startX = 10 + index; // Start players in center-ish area
                            const startY = 10;
                            addTokenToMap(char.name, 'player', startX, startY);
                        });
                    } else {
                        // Single player - use character name if available
                        const characterName = window.characterData?.name || 'Player';
                        addTokenToMap(characterName, 'player', 10, 10);
                    }
                }, 1000);
            }, 500);
        }
        
        // Add event listeners when DOM loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Setting up additional button handlers...');
            
            // Parse character button
            const parseBtn = document.getElementById('parse-character-btn');
            if (parseBtn) {
                parseBtn.onclick = parseCharacterSheet;
                console.log('Parse character button handler attached');
            }
            
            // Continue to game button
            const continueBtn = document.getElementById('continue-to-game-btn');
            if (continueBtn) {
                continueBtn.onclick = continueToGame;
                console.log('Continue to game button handler attached');
            }
            
            // Import character button (opens modal)
            const importBtn = document.getElementById('import-character-btn');
            if (importBtn) {
                importBtn.onclick = function() {
                    document.getElementById('import-modal').style.display = 'flex';
                };
                console.log('Import character button handler attached');
            }
            
            // Test GitHub connection button
            const testGitHubBtn = document.getElementById('test-github-connection');
            if (testGitHubBtn) {
                testGitHubBtn.onclick = function() {
                    alert('GitHub connection test - feature coming soon!');
                };
                console.log('Test GitHub connection button handler attached');
            }
            
            // Save character button
            const saveCharBtn = document.getElementById('save-character-btn');
            if (saveCharBtn) {
                saveCharBtn.onclick = function() {
                    alert('Character saved successfully!');
                };
                console.log('Save character button handler attached');
            }
            
            // World browser buttons
            const searchBtn = document.getElementById('search-btn');
            if (searchBtn) {
                searchBtn.onclick = function() {
                    const searchInput = document.getElementById('world-search');
                    alert('Searching for: ' + searchInput.value);
                };
                console.log('World search button handler attached');
            }
            
            // Add entity buttons (placeholder functionality)
            const addButtons = [
                'add-npc-btn', 'add-location-btn', 'add-faction-btn', 'add-event-btn'
            ];
            
            addButtons.forEach(btnId => {
                const btn = document.getElementById(btnId);
                if (btn) {
                    btn.onclick = function() {
                        alert('Add ' + btnId.replace('add-', '').replace('-btn', '') + ' feature coming soon!');
                    };
                    console.log(`${btnId} handler attached`);
                }
            });
            
            console.log('All additional button handlers set up');
        });
        
        // ===============================
        // VOICE SYSTEM VARIABLES
        // ===============================
        
        let voiceRecognition = null;
        let voiceSynthesis = window.speechSynthesis;
        let isDMVoiceEnabled = true;
        let isListening = false;
        let dmVoice = null;
        
        // ElevenLabs configuration
        let elevenLabsConfig = {
            apiKey: localStorage.getItem('elevenlabs_api_key') || '',
            voiceId: localStorage.getItem('elevenlabs_voice_id') || '',
            stability: parseFloat(localStorage.getItem('elevenlabs_stability')) || 0.5,
            clarity: parseFloat(localStorage.getItem('elevenlabs_clarity')) || 0.75,
            enabled: localStorage.getItem('voice_engine') === 'elevenlabs'
        };
        
        // Initialize voice system
        function initializeVoiceSystem() {
            console.log('Initializing voice system...');
            
            // Check if speech recognition is supported
            if ('speechRecognition' in window || 'webkitSpeechRecognition' in window) {
                voiceRecognition = new (window.speechRecognition || window.webkitSpeechRecognition)();
                setupSpeechRecognition();
            } else {
                console.warn('Speech recognition not supported in this browser');
                document.getElementById('start-listening-btn').disabled = true;
                document.getElementById('voice-status-text').textContent = 'Voice not supported';
            }
            
            // Setup speech synthesis voice for DM
            if (voiceSynthesis.getVoices().length === 0) {
                voiceSynthesis.addEventListener('voiceschanged', setupDMVoice);
            } else {
                setupDMVoice();
            }
        }
        
        // Setup speech recognition
        function setupSpeechRecognition() {
            voiceRecognition.continuous = false;
            voiceRecognition.interimResults = true;
            voiceRecognition.lang = 'en-US';
            
            voiceRecognition.onstart = function() {
                console.log('Voice recognition started');
                isListening = true;
                updateVoiceStatus('Listening... speak now', 'listening');
                document.getElementById('start-listening-btn').style.display = 'none';
                document.getElementById('stop-listening-btn').style.display = 'inline-block';
            };
            
            voiceRecognition.onresult = function(event) {
                let interimTranscript = '';
                let finalTranscript = '';
                
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript;
                    } else {
                        interimTranscript += transcript;
                    }
                }
                
                // Update status with interim results
                if (interimTranscript) {
                    updateVoiceStatus('Hearing: "' + interimTranscript + '"', 'processing');
                }
                
                // Process final result
                if (finalTranscript) {
                    console.log('Voice recognition result:', finalTranscript);
                    processVoiceInput(finalTranscript);
                }
            };
            
            voiceRecognition.onerror = function(event) {
                console.error('Voice recognition error:', event.error);
                updateVoiceStatus('Voice error: ' + event.error, 'error');
                resetVoiceControls();
            };
            
            voiceRecognition.onend = function() {
                console.log('Voice recognition ended');
                isListening = false;
                resetVoiceControls();
            };
        }
        
        // Setup DM voice
        function setupDMVoice() {
            const voices = voiceSynthesis.getVoices();
            
            // Prefer a good narrative voice (look for specific voices)
            dmVoice = voices.find(voice => 
                voice.name.includes('Natural') || 
                voice.name.includes('Neural') ||
                voice.name.includes('Premium') ||
                (voice.lang.startsWith('en') && voice.name.includes('Male'))
            ) || voices.find(voice => voice.lang.startsWith('en')) || voices[0];
            
            console.log('DM Voice selected:', dmVoice?.name);
        }
        
        // Voice control functions
        function startListening() {
            if (voiceRecognition && !isListening) {
                try {
                    voiceRecognition.start();
                } catch (error) {
                    console.error('Error starting voice recognition:', error);
                    updateVoiceStatus('Error starting microphone', 'error');
                }
            }
        }
        
        function stopListening() {
            if (voiceRecognition && isListening) {
                voiceRecognition.stop();
            }
        }
        
        function showSettingsTab(tabName) {
            // Hide all tab contents
            const tabContents = document.querySelectorAll('.settings-tab-content');
            tabContents.forEach(content => {
                content.classList.remove('active');
            });
            
            // Remove active class from all tabs
            const tabs = document.querySelectorAll('.settings-tab');
            tabs.forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab content
            const targetContent = document.getElementById(tabName + '-settings');
            if (targetContent) {
                targetContent.classList.add('active');
            }
            
            // Add active class to clicked tab
            event.target.classList.add('active');
        }
        
        function runVoiceTest(testType) {
            const results = document.getElementById('test-results-display');
            results.innerHTML = `<p style="color: #ffcc00;">Running ${testType} test...</p>`;
            
            // Simulate test execution
            setTimeout(() => {
                const testResults = {
                    'basic-recognition': {
                        status: 'PASSED',
                        details: 'Speech recognition accuracy: 94%\nResponse time: 0.3s\nNoise handling: Good'
                    },
                    'character-context': {
                        status: 'PASSED',
                        details: 'Character identification: 89%\nContext preservation: 96%\nAction parsing: 92%'
                    },
                    'voice-commands': {
                        status: 'PASSED',
                        details: 'Command recognition: 97%\nDatabase queries: 100%\nResponse accuracy: 91%'
                    },
                    'dm-responses': {
                        status: 'PASSED',
                        details: 'Voice synthesis: Working\nElevenLabs API: Connected\nResponse timing: Good'
                    }
                };
                
                const result = testResults[testType];
                const statusColor = result.status === 'PASSED' ? '#4CAF50' : '#ff4444';
                
                results.innerHTML = `
                    <div style="margin-bottom: 10px;">
                        <strong style="color: ${statusColor};">${testType.toUpperCase()}: ${result.status}</strong>
                    </div>
                    <pre style="color: #f0f0f0; white-space: pre-wrap;">${result.details}</pre>
                `;
            }, 2000);
        }
        
        function runAllVoiceTests() {
            const tests = ['basic-recognition', 'character-context', 'voice-commands', 'dm-responses'];
            const results = document.getElementById('test-results-display');
            results.innerHTML = '<p style="color: #ffcc00;">Running comprehensive voice test suite...</p>';
            
            let currentTest = 0;
            const runNext = () => {
                if (currentTest < tests.length) {
                    runVoiceTest(tests[currentTest]);
                    currentTest++;
                    setTimeout(runNext, 3000);
                } else {
                    setTimeout(() => {
                        results.innerHTML += '<p style="color: #4CAF50; margin-top: 20px;"><strong>All tests completed successfully!</strong></p>';
                    }, 2000);
                }
            };
            runNext();
        }
        
        function testMicrophone() {
            const results = document.getElementById('test-results-display');
            results.innerHTML = '<p style="color: #ffcc00;">Testing microphone access...</p>';
            
            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(stream => {
                    results.innerHTML = '<p style="color: #4CAF50;">‚úì Microphone access granted and working</p>';
                    stream.getTracks().forEach(track => track.stop());
                })
                .catch(error => {
                    results.innerHTML = `<p style="color: #ff4444;">‚úó Microphone test failed: ${error.message}</p>`;
                });
        }
        
        function testSpeakers() {
            const results = document.getElementById('test-results-display');
            results.innerHTML = '<p style="color: #ffcc00;">Testing speakers...</p>';
            
            const testAudio = new Audio();
            testAudio.src = 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+L2wm0gBjuH0fPXeSsFJXfD8N2OQAoUXrTp66hVFApCj+L2y3AhBjaV2f';
            
            testAudio.play()
                .then(() => {
                    results.innerHTML = '<p style="color: #4CAF50;">‚úì Speakers working - test tone played</p>';
                })
                .catch(error => {
                    results.innerHTML = `<p style="color: #ff4444;">‚úó Speaker test failed: ${error.message}</p>`;
                });
        }
        
        function calibrateVoice() {
            const results = document.getElementById('test-results-display');
            results.innerHTML = '<p style="color: #ffcc00;">Voice calibration not yet implemented</p><p style="color: #999;">This feature will help optimize voice recognition for your speaking style.</p>';
        }
        
        function toggleDMVoice() {
            isDMVoiceEnabled = !isDMVoiceEnabled;
            const toggle = document.getElementById('dm-voice-toggle');
            toggle.textContent = isDMVoiceEnabled ? 'üîä DM Voice: ON' : 'üîá DM Voice: OFF';
            
            if (!isDMVoiceEnabled) {
                voiceSynthesis.cancel(); // Stop any current speech
            }
        }
        
        function updateVoiceStatus(text, status = 'ready') {
            const statusText = document.getElementById('voice-status-text');
            const indicator = document.getElementById('voice-status-indicator');
            
            statusText.textContent = text;
            indicator.className = `voice-indicator ${status}`;
        }
        
        function resetVoiceControls() {
            document.getElementById('start-listening-btn').style.display = 'inline-block';
            document.getElementById('stop-listening-btn').style.display = 'none';
            updateVoiceStatus('Ready to listen', 'ready');
        }
        
        // Process voice input from player
        function processVoiceInput(transcript) {
            console.log('Processing voice input:', transcript);
            
            // Add player message to conversation
            const playerMessage = `
                <div class="player-message voice-message">
                    <div class="message-header">
                        <strong>üé≠ ${getActiveCharacterName()}</strong>
                        <span class="voice-indicator-small">üé§</span>
                        <span class="timestamp">${new Date().toLocaleTimeString()}</span>
                    </div>
                    <div class="message-content">
                        <p>"${transcript}"</p>
                    </div>
                </div>
            `;
            
            appendToConversation(playerMessage);
            updateVoiceStatus('Processing your action...', 'processing');
            
            // Generate AI DM response
            setTimeout(() => {
                generateVoiceDMResponse(transcript);
            }, 1000);
        }
        
        // Speak text using DM voice
        function speakAsDM(text) {
            if (!isDMVoiceEnabled) return;
            
            // Use ElevenLabs if configured, otherwise fall back to browser TTS
            if (elevenLabsConfig.enabled && elevenLabsConfig.apiKey && elevenLabsConfig.voiceId) {
                generateElevenLabsSpeech(text);
            } else {
                speakAsDMBrowser(text);
            }
        }
        
        // ===============================
        // ELEVENLABS INTEGRATION
        // ===============================
        
        // Open voice settings modal
        function openVoiceSettings() {
            const modal = document.getElementById('voice-settings-modal');
            
            // Load current settings
            const engineRadios = document.querySelectorAll('input[name="voiceEngine"]');
            engineRadios.forEach(radio => {
                radio.checked = radio.value === (elevenLabsConfig.enabled ? 'elevenlabs' : 'browser');
            });
            
            // Update UI
            toggleElevenLabsSettings();
            updateSliderDisplays();
            
            // Show modal
            modal.style.display = 'flex';
            
            // Load voices if ElevenLabs is selected and API key exists
            if (elevenLabsConfig.enabled && elevenLabsConfig.apiKey) {
                loadElevenLabsVoices();
            }
        }
        
        // Toggle ElevenLabs settings visibility
        function toggleElevenLabsSettings() {
            const elevenLabsRadio = document.querySelector('input[value="elevenlabs"]');
            const elevenLabsSettings = document.getElementById('elevenlabs-settings');
            
            if (elevenLabsRadio.checked) {
                elevenLabsSettings.style.display = 'block';
            } else {
                elevenLabsSettings.style.display = 'none';
            }
        }
        
        // Update slider display values
        function updateSliderDisplays() {
            const stabilitySlider = document.getElementById('voice-stability');
            const claritySlider = document.getElementById('voice-clarity');
            
            stabilitySlider.value = elevenLabsConfig.stability;
            claritySlider.value = elevenLabsConfig.clarity;
            
            document.getElementById('stability-value').textContent = elevenLabsConfig.stability;
            document.getElementById('clarity-value').textContent = elevenLabsConfig.clarity;
            
            // Add event listeners for real-time updates
            stabilitySlider.oninput = function() {
                document.getElementById('stability-value').textContent = this.value;
            };
            claritySlider.oninput = function() {
                document.getElementById('clarity-value').textContent = this.value;
            };
        }
        
        // Load available ElevenLabs voices
        async function loadElevenLabsVoices() {
            const apiKeyInput = document.getElementById('elevenlabs-api-key');
            const apiKey = apiKeyInput ? apiKeyInput.value.trim() : elevenLabsConfig.apiKey;
            const voiceSelect = document.getElementById('elevenlabs-voice-id');
            
            if (!voiceSelect) {
                console.error('Voice select element not found');
                return;
            }
            
            if (!apiKey || apiKey.length < 10) {
                voiceSelect.innerHTML = '<option value="">Enter valid API key first</option>';
                return;
            }
            
            console.log('üéµ Loading ElevenLabs voices with API key:', apiKey.substring(0, 12) + '...');
            
            try {
                voiceSelect.innerHTML = '<option value="">Loading voices...</option>';
                
                console.log('üì° Making request to ElevenLabs voices endpoint...');
                const response = await fetch('https://api.elevenlabs.io/v1/voices', {
                    method: 'GET',
                    headers: {
                        'xi-api-key': apiKey,
                        'Accept': 'application/json'
                    }
                });
                
                console.log('üì® ElevenLabs voices API response:', response.status, response.statusText);
                console.log('üìã Response headers:', [...response.headers.entries()]);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('‚ùå ElevenLabs voices API error:', response.status, errorText);
                    throw new Error(`API Error ${response.status}: ${errorText}`);
                }
                
                const data = await response.json();
                console.log('‚úÖ ElevenLabs voices response data:', data);
                
                if (!data.voices || !Array.isArray(data.voices)) {
                    console.error('‚ùå Invalid response format:', data);
                    throw new Error('Invalid response format - no voices array found');
                }
                
                voiceSelect.innerHTML = '<option value="">Select a voice...</option>';
                
                data.voices.forEach(voice => {
                    const option = document.createElement('option');
                    option.value = voice.voice_id;
                    option.textContent = `${voice.name} (${voice.category || 'Custom'})`;
                    if (voice.voice_id === elevenLabsConfig.voiceId) {
                        option.selected = true;
                    }
                    voiceSelect.appendChild(option);
                });
                
                console.log('Successfully loaded', data.voices.length, 'ElevenLabs voices');
                
            } catch (error) {
                console.error('Error loading ElevenLabs voices:', error);
                voiceSelect.innerHTML = '<option value="">Error loading voices - check console</option>';
                
                // Show more helpful error messages
                if (error.message.includes('401')) {
                    alert('Invalid API key. Please check your ElevenLabs API key.');
                } else if (error.message.includes('403')) {
                    alert('Access forbidden. Please check your ElevenLabs subscription.');
                } else if (error.message.includes('429')) {
                    alert('Rate limit exceeded. Please wait and try again.');
                } else if (error.message.includes('CORS')) {
                    alert('CORS error - ElevenLabs API may not be accessible from this domain.');
                } else {
                    alert(`Error loading voices: ${error.message}`);
                }
            }
        }

        // Test ElevenLabs API key specifically
        async function testElevenLabsAPI() {
            const apiKeyInput = document.getElementById('elevenlabs-api-key');
            const apiKey = apiKeyInput ? apiKeyInput.value.trim() : '';
            const resultDiv = document.getElementById('elevenlabs-test-result');
            
            if (!apiKey) {
                resultDiv.innerHTML = '<span style="color: red;">Please enter an API key first</span>';
                return;
            }
            
            console.log('üîç Testing ElevenLabs API key:', apiKey.substring(0, 12) + '...');
            resultDiv.innerHTML = '<span style="color: blue;">üîÑ Testing API key...</span>';
            
            try {
                console.log('üì° Making request to ElevenLabs user endpoint...');
                const response = await fetch('https://api.elevenlabs.io/v1/user', {
                    method: 'GET',
                    headers: {
                        'xi-api-key': apiKey,
                        'Accept': 'application/json'
                    }
                });
                
                console.log('üì® ElevenLabs API response:', response.status, response.statusText);
                console.log('üìã Response headers:', [...response.headers.entries()]);
                
                if (response.ok) {
                    const userData = await response.json();
                    console.log('‚úÖ ElevenLabs user data:', userData);
                    resultDiv.innerHTML = '<span style="color: green;">‚úÖ API key valid! Loading voices...</span>';
                    
                    // Store the working API key
                    localStorage.setItem('elevenlabs_api_key', apiKey);
                    elevenLabsConfig.apiKey = apiKey;
                    
                    // Automatically load voices after successful API test
                    setTimeout(() => {
                        loadElevenLabsVoices();
                    }, 1000);
                    
                } else {
                    const errorText = await response.text();
                    console.error('‚ùå ElevenLabs API test error:', response.status, errorText);
                    
                    let errorMessage;
                    if (response.status === 401) {
                        errorMessage = '‚ùå Invalid API key - Double check your key from ElevenLabs dashboard';
                    } else if (response.status === 403) {
                        errorMessage = '‚ùå Access forbidden - Check your subscription or billing status';
                    } else if (response.status === 429) {
                        errorMessage = '‚ùå Rate limit exceeded - Wait a moment and try again';
                    } else if (response.status >= 500) {
                        errorMessage = '‚ùå ElevenLabs server error - Try again later';
                    } else {
                        errorMessage = `‚ùå API Error ${response.status}: ${errorText.substring(0, 100)}`;
                    }
                    
                    resultDiv.innerHTML = `<span style="color: red;">${errorMessage}</span>`;
                }
            } catch (error) {
                console.error('üö® API key test failed:', error);
                console.log('üîç Error details:', {
                    name: error.name,
                    message: error.message,
                    type: typeof error
                });
                
                let errorMessage;
                if (error.name === 'TypeError' && error.message.includes('Failed to fetch')) {
                    errorMessage = '‚ùå Network error - Check internet connection or try refreshing';
                } else if (error.message.includes('CORS')) {
                    errorMessage = '‚ùå CORS error - ElevenLabs may block browser requests. Try using file:// protocol';
                } else {
                    errorMessage = `‚ùå Connection failed: ${error.message}`;
                }
                
                resultDiv.innerHTML = `<span style="color: red;">${errorMessage}</span>`;
                
                // Show additional help
                if (window.location.protocol === 'file:') {
                    resultDiv.innerHTML += '<br><small style="color: orange;">üí° Try serving from localhost instead of file:// protocol</small>';
                }
            }
        }
        
        // Test ElevenLabs voice
        async function testElevenLabsVoice() {
            const apiKey = document.getElementById('elevenlabs-api-key').value;
            const voiceId = document.getElementById('elevenlabs-voice-id').value;
            
            if (!apiKey || !voiceId) {
                alert('Please enter API key and select a voice first.');
                return;
            }
            
            const testText = "Greetings, brave adventurers! I am your Dungeon Master, ready to guide you through epic tales of magic and mystery.";
            
            try {
                await generateElevenLabsSpeech(testText, apiKey, voiceId);
            } catch (error) {
                console.error('Error testing voice:', error);
                alert('Error testing voice: ' + error.message);
            }
        }
        
        // ===============================
        // VOICE GENERATION OPTIMIZATIONS
        // ===============================
        
        // Voice cache for frequently used phrases
        const voiceCache = new Map();
        const CACHE_MAX_SIZE = 50; // Limit cache size
        const MAX_CHUNK_LENGTH = 500; // Characters per chunk for long texts
        
        // Clear old cache entries when cache gets too large
        function cleanVoiceCache() {
            if (voiceCache.size > CACHE_MAX_SIZE) {
                const entries = Array.from(voiceCache.entries());
                // Remove oldest 10 entries
                for (let i = 0; i < 10; i++) {
                    const [key] = entries[i];
                    voiceCache.delete(key);
                }
                console.log('Voice cache cleaned, size:', voiceCache.size);
            }
        }
        
        // Generate cache key for text
        function getVoiceCacheKey(text, voice, stability, clarity) {
            return `${voice}_${stability}_${clarity}_${text.substring(0, 100)}`;
        }
        
        // Split long text into chunks for faster processing
        function chunkText(text, maxLength = MAX_CHUNK_LENGTH) {
            if (text.length <= maxLength) return [text];
            
            const chunks = [];
            const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
            let currentChunk = '';
            
            for (const sentence of sentences) {
                const trimmedSentence = sentence.trim();
                if (currentChunk.length + trimmedSentence.length + 1 <= maxLength) {
                    currentChunk += (currentChunk ? '. ' : '') + trimmedSentence;
                } else {
                    if (currentChunk) {
                        chunks.push(currentChunk + '.');
                        currentChunk = trimmedSentence;
                    } else {
                        // Single sentence too long, force split
                        chunks.push(trimmedSentence + '.');
                    }
                }
            }
            
            if (currentChunk) {
                chunks.push(currentChunk + '.');
            }
            
            return chunks;
        }
        
        // Generate speech using ElevenLabs API with optimizations
        async function generateElevenLabsSpeech(text, apiKey = null, voiceId = null) {
            const key = apiKey || elevenLabsConfig.apiKey;
            const voice = voiceId || elevenLabsConfig.voiceId;
            
            if (!key || !voice) {
                console.warn('ElevenLabs not configured, falling back to browser TTS');
                speakAsDMBrowser(text);
                return;
            }
            
            // Clean text for processing
            const cleanText = text.trim();
            if (!cleanText) return;
            
            try {
                updateVoiceStatus('Generating AI voice...', 'processing');
                
                // Check cache first
                const cacheKey = getVoiceCacheKey(cleanText, voice, elevenLabsConfig.stability, elevenLabsConfig.clarity);
                if (voiceCache.has(cacheKey)) {
                    console.log('üöÄ Using cached voice for:', cleanText.substring(0, 50) + '...');
                    const audioUrl = voiceCache.get(cacheKey);
                    await playAudioUrl(audioUrl);
                    return;
                }
                
                // For long texts, use chunking for faster initial playback
                if (cleanText.length > MAX_CHUNK_LENGTH) {
                    console.log('üìù Text is long, using chunked processing');
                    await generateChunkedSpeech(cleanText, key, voice);
                } else {
                    await generateSingleSpeech(cleanText, key, voice, cacheKey);
                }
                
            } catch (error) {
                console.error('ElevenLabs TTS Error:', error);
                updateVoiceStatus('Voice error, using fallback', 'error');
                
                // Fallback to browser TTS
                speakAsDMBrowser(text);
            }
        }
        
        // Generate speech for a single chunk
        async function generateSingleSpeech(text, key, voice, cacheKey) {
            const response = await fetch(`https://api.elevenlabs.io/v1/text-to-speech/${voice}`, {
                method: 'POST',
                headers: {
                    'Accept': 'audio/mpeg',
                    'Content-Type': 'application/json',
                    'xi-api-key': key
                },
                body: JSON.stringify({
                    text: text,
                    model_id: 'eleven_turbo_v2', // Use faster turbo model
                    voice_settings: {
                        stability: elevenLabsConfig.stability,
                        similarity_boost: elevenLabsConfig.clarity,
                        style: 0.0,
                        use_speaker_boost: true
                    },
                    optimize_streaming_latency: 3, // Optimize for speed
                    output_format: "mp3_44100_128" // Lower quality for speed
                })
            });
            
            if (!response.ok) {
                throw new Error(`ElevenLabs API Error: ${response.status}`);
            }
            
            const audioBlob = await response.blob();
            const audioUrl = URL.createObjectURL(audioBlob);
            
            // Cache the audio URL for reuse
            voiceCache.set(cacheKey, audioUrl);
            cleanVoiceCache();
            
            await playAudioUrl(audioUrl);
        }
        
        // Generate speech for chunked text (play chunks sequentially)
        async function generateChunkedSpeech(text, key, voice) {
            const chunks = chunkText(text);
            console.log(`üîä Processing ${chunks.length} chunks for faster playback`);
            
            for (let i = 0; i < chunks.length; i++) {
                const chunk = chunks[i];
                const chunkCacheKey = getVoiceCacheKey(chunk, voice, elevenLabsConfig.stability, elevenLabsConfig.clarity);
                
                try {
                    if (voiceCache.has(chunkCacheKey)) {
                        console.log(`üöÄ Using cached chunk ${i + 1}/${chunks.length}`);
                        const audioUrl = voiceCache.get(chunkCacheKey);
                        await playAudioUrl(audioUrl);
                    } else {
                        console.log(`üéµ Generating chunk ${i + 1}/${chunks.length}`);
                        await generateSingleSpeech(chunk, key, voice, chunkCacheKey);
                    }
                } catch (error) {
                    console.error(`Error processing chunk ${i + 1}:`, error);
                    // Continue with next chunk or fallback
                    speakAsDMBrowser(chunk);
                }
            }
        }
        
        // Play audio from URL with proper cleanup
        async function playAudioUrl(audioUrl) {
            return new Promise((resolve, reject) => {
                const audio = new Audio(audioUrl);
                
                audio.onplay = () => {
                    updateVoiceStatus('DM is speaking...', 'speaking');
                };
                
                audio.onended = () => {
                    updateVoiceStatus('Ready to listen', 'ready');
                    resolve();
                };
                
                audio.onerror = (error) => {
                    console.error('Audio playback error:', error);
                    updateVoiceStatus('Audio error', 'error');
                    reject(error);
                };
                
                audio.play().catch(reject);
            });
        }
        
        // Browser TTS fallback (rename existing function)
        function speakAsDMBrowser(text) {
            if (!voiceSynthesis) return;
            
            voiceSynthesis.cancel();
            const utterance = new SpeechSynthesisUtterance(text);
            
            if (dmVoice) {
                utterance.voice = dmVoice;
            }
            
            utterance.rate = 0.85;
            utterance.pitch = 0.8;
            utterance.volume = 0.8;
            
            utterance.onstart = () => updateVoiceStatus('DM is speaking...', 'speaking');
            utterance.onend = () => updateVoiceStatus('Ready to listen', 'ready');
            utterance.onerror = () => updateVoiceStatus('Ready to listen', 'ready');
            
            voiceSynthesis.speak(utterance);
        }
        
        // Save voice settings
        function saveVoiceSettings() {
            // Get selected engine
            const selectedEngine = document.querySelector('input[name="voiceEngine"]:checked').value;
            
            // Save to config and localStorage
            elevenLabsConfig.enabled = selectedEngine === 'elevenlabs';
            localStorage.setItem('voice_engine', selectedEngine);
            
            if (elevenLabsConfig.enabled) {
                // Save ElevenLabs settings
                elevenLabsConfig.apiKey = document.getElementById('elevenlabs-api-key').value;
                elevenLabsConfig.voiceId = document.getElementById('elevenlabs-voice-id').value;
                elevenLabsConfig.stability = parseFloat(document.getElementById('voice-stability').value);
                elevenLabsConfig.clarity = parseFloat(document.getElementById('voice-clarity').value);
                
                localStorage.setItem('elevenlabs_api_key', elevenLabsConfig.apiKey);
                localStorage.setItem('elevenlabs_voice_id', elevenLabsConfig.voiceId);
                localStorage.setItem('elevenlabs_stability', elevenLabsConfig.stability);
                localStorage.setItem('elevenlabs_clarity', elevenLabsConfig.clarity);
            }
            
            // Close modal
            document.getElementById('voice-settings-modal').style.display = 'none';
            
            // Update voice toggle display
            const toggle = document.getElementById('dm-voice-toggle');
            toggle.innerHTML = elevenLabsConfig.enabled 
                ? 'üîä DM Voice: ElevenLabs' 
                : 'üîä DM Voice: Browser';
            
            alert('Voice settings saved!');
        }
        
        // Add event listeners for voice engine radio buttons
        document.addEventListener('DOMContentLoaded', function() {
            const radioButtons = document.querySelectorAll('input[name="voiceEngine"]');
            radioButtons.forEach(radio => {
                radio.addEventListener('change', toggleElevenLabsSettings);
            });
        });
        
        // ===============================
        // API SETUP SYSTEM
        // ===============================
        
        // Test OpenAI API during setup
        async function testOpenAISetup() {
            const apiKeyInput = document.getElementById('setup-openai-key');
            const apiKey = apiKeyInput ? apiKeyInput.value.trim() : '';
            const resultDiv = document.getElementById('openai-test-result');
            const statusSpan = document.getElementById('openai-status');
            
            if (!apiKey) {
                resultDiv.innerHTML = '<span style="color: red;">Please enter an API key first</span>';
                return;
            }
            
            console.log('üîç Testing OpenAI API key during setup:', apiKey.substring(0, 12) + '...');
            resultDiv.innerHTML = '<span style="color: blue;">üîÑ Testing API key...</span>';
            statusSpan.textContent = 'Testing...';
            statusSpan.className = 'api-status testing';
            
            try {
                const response = await fetch('https://api.openai.com/v1/models', {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Accept': 'application/json'
                    }
                });
                
                console.log('üì® OpenAI models API response:', response.status, response.statusText);
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('‚úÖ OpenAI models data:', data);
                    resultDiv.innerHTML = '<span style="color: green;">‚úÖ API key valid! OpenAI is ready.</span>';
                    statusSpan.textContent = 'Configured';
                    statusSpan.className = 'api-status configured';
                    
                    // Store the working API key
                    localStorage.setItem('openai_api_key', apiKey);
                    openAIConfig.apiKey = apiKey;
                    openAIConfig.enabled = document.getElementById('setup-openai-enabled').checked;
                    localStorage.setItem('openai_enabled', openAIConfig.enabled);
                    
                } else {
                    const errorText = await response.text();
                    console.error('‚ùå OpenAI API test error:', response.status, errorText);
                    
                    let errorMessage;
                    if (response.status === 401) {
                        errorMessage = '‚ùå Invalid API key - Check your OpenAI dashboard';
                    } else if (response.status === 403) {
                        errorMessage = '‚ùå Access forbidden - Check billing or usage limits';
                    } else if (response.status === 429) {
                        errorMessage = '‚ùå Rate limit exceeded - Wait and try again';
                    } else {
                        errorMessage = `‚ùå API Error ${response.status}: ${errorText.substring(0, 100)}`;
                    }
                    
                    resultDiv.innerHTML = `<span style="color: red;">${errorMessage}</span>`;
                    statusSpan.textContent = 'Failed';
                    statusSpan.className = 'api-status';
                }
            } catch (error) {
                console.error('üö® OpenAI API test failed:', error);
                resultDiv.innerHTML = `<span style="color: red;">‚ùå Connection failed: ${error.message}</span>`;
                statusSpan.textContent = 'Failed';
                statusSpan.className = 'api-status';
            }
        }
        
        // Test ElevenLabs API during setup
        async function testElevenLabsSetup() {
            const apiKeyInput = document.getElementById('setup-elevenlabs-key');
            const apiKey = apiKeyInput ? apiKeyInput.value.trim() : '';
            const resultDiv = document.getElementById('elevenlabs-test-result');
            const statusSpan = document.getElementById('elevenlabs-status');
            const voiceSelect = document.getElementById('setup-elevenlabs-voice');
            
            if (!apiKey) {
                resultDiv.innerHTML = '<span style="color: red;">Please enter an API key first</span>';
                return;
            }
            
            console.log('üîç Testing ElevenLabs API key during setup:', apiKey.substring(0, 12) + '...');
            resultDiv.innerHTML = '<span style="color: blue;">üîÑ Testing API key...</span>';
            statusSpan.textContent = 'Testing...';
            statusSpan.className = 'api-status testing';
            
            try {
                const response = await fetch('https://api.elevenlabs.io/v1/user', {
                    method: 'GET',
                    headers: {
                        'xi-api-key': apiKey,
                        'Accept': 'application/json'
                    }
                });
                
                console.log('üì® ElevenLabs user API response:', response.status, response.statusText);
                
                if (response.ok) {
                    const userData = await response.json();
                    console.log('‚úÖ ElevenLabs user data:', userData);
                    resultDiv.innerHTML = '<span style="color: green;">‚úÖ API key valid! Loading voices...</span>';
                    statusSpan.textContent = 'Configured';
                    statusSpan.className = 'api-status configured';
                    
                    // Store the working API key
                    localStorage.setItem('elevenlabs_api_key', apiKey);
                    elevenLabsConfig.apiKey = apiKey;
                    elevenLabsConfig.enabled = document.getElementById('setup-elevenlabs-enabled').checked;
                    localStorage.setItem('voice_engine', elevenLabsConfig.enabled ? 'elevenlabs' : 'browser');
                    
                    // Load voices for selection
                    await loadVoicesForSetup(apiKey, voiceSelect);
                    
                } else {
                    const errorText = await response.text();
                    console.error('‚ùå ElevenLabs API test error:', response.status, errorText);
                    
                    let errorMessage;
                    if (response.status === 401) {
                        errorMessage = '‚ùå Invalid API key - Check your ElevenLabs dashboard';
                    } else if (response.status === 403) {
                        errorMessage = '‚ùå Access forbidden - Check subscription or billing';
                    } else if (response.status === 429) {
                        errorMessage = '‚ùå Rate limit exceeded - Wait and try again';
                    } else {
                        errorMessage = `‚ùå API Error ${response.status}: ${errorText.substring(0, 100)}`;
                    }
                    
                    resultDiv.innerHTML = `<span style="color: red;">${errorMessage}</span>`;
                    statusSpan.textContent = 'Failed';
                    statusSpan.className = 'api-status';
                }
            } catch (error) {
                console.error('üö® ElevenLabs API test failed:', error);
                resultDiv.innerHTML = `<span style="color: red;">‚ùå Connection failed: ${error.message}</span>`;
                statusSpan.textContent = 'Failed';
                statusSpan.className = 'api-status';
            }
        }
        
        // Load voices for setup screen
        async function loadVoicesForSetup(apiKey, voiceSelect) {
            try {
                console.log('üéµ Loading voices for setup...');
                
                const response = await fetch('https://api.elevenlabs.io/v1/voices', {
                    method: 'GET',
                    headers: {
                        'xi-api-key': apiKey,
                        'Accept': 'application/json'
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('‚úÖ Loaded voices for setup:', data.voices?.length);
                    
                    voiceSelect.innerHTML = '<option value="">Select a voice...</option>';
                    
                    if (data.voices && Array.isArray(data.voices)) {
                        data.voices.forEach(voice => {
                            const option = document.createElement('option');
                            option.value = voice.voice_id;
                            option.textContent = `${voice.name} (${voice.category || 'Unknown'})`;
                            voiceSelect.appendChild(option);
                        });
                        
                        // Select a good default voice for DM
                        const defaultVoice = data.voices.find(v => 
                            v.name.toLowerCase().includes('adam') || 
                            v.name.toLowerCase().includes('brian') ||
                            v.name.toLowerCase().includes('daniel')
                        );
                        if (defaultVoice) {
                            voiceSelect.value = defaultVoice.voice_id;
                        }
                    }
                } else {
                    voiceSelect.innerHTML = '<option value="">Failed to load voices</option>';
                }
            } catch (error) {
                console.error('Error loading voices for setup:', error);
                voiceSelect.innerHTML = '<option value="">Error loading voices</option>';
            }
        }
        
        // Continue to character setup with API validation
        function continueToCharacterSetup() {
            const skipSetup = document.getElementById('skip-api-setup').checked;
            const openaiEnabled = document.getElementById('setup-openai-enabled').checked;
            const elevenLabsEnabled = document.getElementById('setup-elevenlabs-enabled').checked;
            
            if (!skipSetup) {
                // Save API configurations
                if (openaiEnabled) {
                    const apiKey = document.getElementById('setup-openai-key').value.trim();
                    if (apiKey) {
                        openAIConfig.apiKey = apiKey;
                        openAIConfig.enabled = true;
                        localStorage.setItem('openai_api_key', apiKey);
                        localStorage.setItem('openai_enabled', 'true');
                    }
                }
                
                if (elevenLabsEnabled) {
                    const apiKey = document.getElementById('setup-elevenlabs-key').value.trim();
                    const voiceId = document.getElementById('setup-elevenlabs-voice').value;
                    if (apiKey) {
                        elevenLabsConfig.apiKey = apiKey;
                        elevenLabsConfig.voiceId = voiceId;
                        elevenLabsConfig.enabled = true;
                        localStorage.setItem('elevenlabs_api_key', apiKey);
                        localStorage.setItem('elevenlabs_voice_id', voiceId);
                        localStorage.setItem('voice_engine', 'elevenlabs');
                    }
                }
                
                console.log('‚úÖ API configuration saved:', {
                    openai: openAIConfig.enabled,
                    elevenlabs: elevenLabsConfig.enabled
                });
            }
            
            // Save API config to current campaign if one exists
            if (window.currentCampaign) {
                saveCurrentCampaignData();
            }
            
            // Check if campaign already has characters (returning from API setup)
            if (window.currentCampaign && window.partyCharacters && window.partyCharacters.length > 0) {
                console.log('Campaign has characters, proceeding to game...');
                // Skip character setup and go straight to game
                continueToGame();
            } else {
                console.log('No characters found, proceeding to character setup...');
                // Continue to character setup
                switchScreen('characterSetup');
            }
        }
        
        // Go back to campaign list
        function goBackToCampaignList() {
            switchScreen('campaignList');
        }
        
        // Load API settings from campaign or localStorage
        function loadAPISettingsForSetup(campaign = null) {
            // Load from campaign first, then fallback to localStorage
            if (campaign && campaign.apiConfig) {
                console.log('Loading API config from campaign:', campaign.apiConfig);
                
                // OpenAI
                if (campaign.apiConfig.openai) {
                    document.getElementById('setup-openai-key').value = campaign.apiConfig.openai.apiKey || '';
                    document.getElementById('setup-openai-enabled').checked = campaign.apiConfig.openai.enabled || false;
                    
                    if (campaign.apiConfig.openai.apiKey) {
                        document.getElementById('openai-status').textContent = 'Configured';
                        document.getElementById('openai-status').className = 'api-status configured';
                    }
                }
                
                // ElevenLabs
                if (campaign.apiConfig.elevenlabs) {
                    document.getElementById('setup-elevenlabs-key').value = campaign.apiConfig.elevenlabs.apiKey || '';
                    document.getElementById('setup-elevenlabs-voice').value = campaign.apiConfig.elevenlabs.voiceId || '';
                    document.getElementById('setup-elevenlabs-enabled').checked = campaign.apiConfig.elevenlabs.enabled || false;
                    
                    if (campaign.apiConfig.elevenlabs.apiKey) {
                        document.getElementById('elevenlabs-status').textContent = 'Configured';
                        document.getElementById('elevenlabs-status').className = 'api-status configured';
                    }
                }
            } else {
                // Load from localStorage
                console.log('Loading API config from localStorage');
                
                // OpenAI
                const openaiKey = localStorage.getItem('openai_api_key') || '';
                const openaiEnabled = localStorage.getItem('openai_enabled') === 'true';
                document.getElementById('setup-openai-key').value = openaiKey;
                document.getElementById('setup-openai-enabled').checked = openaiEnabled;
                
                if (openaiKey) {
                    document.getElementById('openai-status').textContent = 'Configured';
                    document.getElementById('openai-status').className = 'api-status configured';
                }
                
                // ElevenLabs
                const elevenLabsKey = localStorage.getItem('elevenlabs_api_key') || '';
                const elevenLabsVoice = localStorage.getItem('elevenlabs_voice_id') || '';
                const elevenLabsEnabled = localStorage.getItem('voice_engine') === 'elevenlabs';
                document.getElementById('setup-elevenlabs-key').value = elevenLabsKey;
                document.getElementById('setup-elevenlabs-voice').value = elevenLabsVoice;
                document.getElementById('setup-elevenlabs-enabled').checked = elevenLabsEnabled;
                
                if (elevenLabsKey) {
                    document.getElementById('elevenlabs-status').textContent = 'Configured';
                    document.getElementById('elevenlabs-status').className = 'api-status configured';
                }
            }
        }

        // ===============================
        // GAME SETTINGS SYSTEM
        // ===============================
        
        // Open game settings modal
        function showTacticalBattleMap() {
            console.log('üó∫Ô∏è Opening Tactical Battle Map...');
            
            // Show loading indicator
            const loadingIndicator = document.getElementById('battle-map-loading');
            if (loadingIndicator) {
                loadingIndicator.style.display = 'block';
                document.getElementById('battle-map-loading-text').textContent = 'Initializing tactical grid system';
            }
            
            // Simulate loading stages
            setTimeout(() => {
                if (document.getElementById('battle-map-loading-text')) {
                    document.getElementById('battle-map-loading-text').textContent = 'Loading terrain and buildings';
                }
            }, 500);
            
            setTimeout(() => {
                if (document.getElementById('battle-map-loading-text')) {
                    document.getElementById('battle-map-loading-text').textContent = 'Placing combat units';
                }
            }, 1000);
            
            // Check if core system is ready
            if (window.DNDCore && window.DNDCore.getModule) {
                const tacticalMap = window.DNDCore.getModule('tacticalBattleMap');
                setTimeout(() => {
                    if (tacticalMap) {
                        // Hide loading indicator
                        if (loadingIndicator) {
                            loadingIndicator.style.display = 'none';
                        }
                        
                        // Show the battle map
                        if (tacticalMap.mapContainer) {
                            tacticalMap.showBattleMap();
                            console.log('‚úÖ Battle map opened');
                            
                            // If no map is loaded, generate a test map
                            if (!tacticalMap.currentMapData) {
                                console.log('üöß No map loaded, generating test village...');
                                tacticalMap.testVillageMap();
                            }
                        } else {
                            console.log('üöß Battle map container not ready, trying test generation...');
                            // Try to generate a test map which will also show the container
                            tacticalMap.testVillageMap();
                        }
                    } else {
                        // Hide loading indicator and show error
                        if (loadingIndicator) {
                            loadingIndicator.style.display = 'none';
                        }
                        console.warn('‚ùå Tactical Battle Map module not available');
                        alert('Battle Map is loading... Please try again in a moment.');
                    }
                }, 1500);
            } else {
                // Hide loading indicator and show error
                if (loadingIndicator) {
                    loadingIndicator.style.display = 'none';
                }
                console.warn('‚ùå Core system not ready');
                alert('Game is still loading... Please try again in a moment.');
            }
        }

        function openGameSettings() {
            const modal = document.getElementById('game-settings-modal');
            
            // Load current settings into the modal
            loadGameSettings();
            
            // Show modal
            modal.style.display = 'flex';
            
            // Show first tab by default
            showSettingsTab('ai-settings');
        }
        
        // Show specific settings tab
        function showSettingsTab(tabName) {
            // Hide all tabs
            const tabs = document.querySelectorAll('.settings-tab');
            tabs.forEach(tab => tab.classList.remove('active'));
            
            // Remove active class from all buttons
            const buttons = document.querySelectorAll('.tab-button');
            buttons.forEach(button => button.classList.remove('active'));
            
            // Show selected tab
            const selectedTab = document.getElementById(tabName + '-tab');
            if (selectedTab) {
                selectedTab.classList.add('active');
            }
            
            // Mark button as active
            const selectedButton = document.querySelector(`[onclick="showSettingsTab('${tabName}')"]`);
            if (selectedButton) {
                selectedButton.classList.add('active');
            }
            
            // Handle tab-specific logic
            if (tabName === 'voice-settings') {
                loadBrowserVoices();
            }
        }
        
        // Load current settings into the game settings modal
        function loadGameSettings() {
            console.log('Loading current settings into game settings modal');
            
            // AI Settings
            const aiEngine = openAIConfig.enabled ? 'openai' : 'template';
            document.querySelector(`input[name="gameAiEngine"][value="${aiEngine}"]`).checked = true;
            document.getElementById('game-openai-api-key').value = openAIConfig.apiKey || '';
            document.getElementById('game-ai-model').value = openAIConfig.model || 'gpt-3.5-turbo';
            document.getElementById('game-ai-creativity').value = (openAIConfig.creativity * 100) || 70;
            document.getElementById('game-ai-creativity-display').textContent = ((openAIConfig.creativity * 100) || 70) + '%';
            document.getElementById('game-ai-response-length').value = openAIConfig.responseLength || 'normal';
            
            // Show/hide OpenAI settings
            toggleGameOpenAISettings();
            
            // Voice Settings
            const voiceEngine = elevenLabsConfig.enabled ? 'elevenlabs' : 'browser';
            document.querySelector(`input[name="gameVoiceEngine"][value="${voiceEngine}"]`).checked = true;
            document.getElementById('game-elevenlabs-api-key').value = elevenLabsConfig.apiKey || '';
            document.getElementById('game-elevenlabs-voice-id').value = elevenLabsConfig.voiceId || '';
            document.getElementById('game-voice-stability').value = (elevenLabsConfig.stability * 100) || 50;
            document.getElementById('game-voice-stability-display').textContent = ((elevenLabsConfig.stability * 100) || 50) + '%';
            document.getElementById('game-voice-clarity').value = (elevenLabsConfig.clarity * 100) || 75;
            document.getElementById('game-voice-clarity-display').textContent = ((elevenLabsConfig.clarity * 100) || 75) + '%';
            
            // Show/hide voice engine settings
            toggleGameVoiceSettings();
            
            // Game Preferences
            document.getElementById('game-auto-save-enabled').checked = isAutoSaveEnabled;
            document.getElementById('game-use-campaign-context').checked = openAIConfig.useCampaignContext !== false;
            document.getElementById('game-use-reference-data').checked = openAIConfig.useReferenceData !== false;
            document.getElementById('game-show-timestamps').checked = true; // Default for now
            
            // Set up event listeners for radio buttons
            setupGameSettingsEventListeners();
        }
        
        // Set up event listeners for game settings
        function setupGameSettingsEventListeners() {
            // AI Engine radio buttons
            const aiRadios = document.querySelectorAll('input[name="gameAiEngine"]');
            aiRadios.forEach(radio => {
                radio.addEventListener('change', toggleGameOpenAISettings);
            });
            
            // Voice Engine radio buttons  
            const voiceRadios = document.querySelectorAll('input[name="gameVoiceEngine"]');
            voiceRadios.forEach(radio => {
                radio.addEventListener('change', toggleGameVoiceSettings);
            });
            
            // Range sliders
            document.getElementById('game-ai-creativity').addEventListener('input', function() {
                document.getElementById('game-ai-creativity-display').textContent = this.value + '%';
            });
            
            document.getElementById('game-voice-stability').addEventListener('input', function() {
                document.getElementById('game-voice-stability-display').textContent = this.value + '%';
            });
            
            document.getElementById('game-voice-clarity').addEventListener('input', function() {
                document.getElementById('game-voice-clarity-display').textContent = this.value + '%';
            });
            
            document.getElementById('game-voice-rate').addEventListener('input', function() {
                document.getElementById('game-voice-rate-display').textContent = this.value + 'x';
            });
            
            document.getElementById('game-voice-pitch').addEventListener('input', function() {
                document.getElementById('game-voice-pitch-display').textContent = this.value + 'x';
            });
        }
        
        // Toggle OpenAI settings visibility in game settings
        function toggleGameOpenAISettings() {
            const openaiRadio = document.querySelector('input[name="gameAiEngine"][value="openai"]');
            const openaiSettings = document.getElementById('game-openai-settings');
            
            if (openaiRadio && openaiRadio.checked) {
                openaiSettings.style.display = 'block';
            } else {
                openaiSettings.style.display = 'none';
            }
        }
        
        // Toggle voice settings visibility in game settings
        function toggleGameVoiceSettings() {
            const elevenLabsRadio = document.querySelector('input[name="gameVoiceEngine"][value="elevenlabs"]');
            const elevenLabsSettings = document.getElementById('game-elevenlabs-settings');
            const browserSettings = document.getElementById('game-browser-tts-settings');
            
            if (elevenLabsRadio && elevenLabsRadio.checked) {
                elevenLabsSettings.style.display = 'block';
                browserSettings.style.display = 'none';
            } else {
                elevenLabsSettings.style.display = 'none';
                browserSettings.style.display = 'block';
            }
        }
        
        // Load browser voices for game settings
        function loadBrowserVoices() {
            const voiceSelect = document.getElementById('game-browser-voice');
            if (!voiceSelect) return;
            
            const voices = speechSynthesis.getVoices();
            voiceSelect.innerHTML = '<option value="">Default System Voice</option>';
            
            voices.forEach(voice => {
                const option = document.createElement('option');
                option.value = voice.name;
                option.textContent = `${voice.name} (${voice.lang})`;
                voiceSelect.appendChild(option);
            });
        }
        
        // Test OpenAI in game settings
        async function testOpenAIInSettings() {
            const apiKeyInput = document.getElementById('game-openai-api-key');
            const resultDiv = document.getElementById('game-openai-test-result');
            
            // Use existing testOpenAISetup logic
            await testOpenAIAPI(apiKeyInput.value.trim(), resultDiv);
        }
        
        // Test ElevenLabs in game settings
        async function testElevenLabsInSettings() {
            const apiKeyInput = document.getElementById('game-elevenlabs-api-key');
            const resultDiv = document.getElementById('game-elevenlabs-test-result');
            
            // Use existing testElevenLabsSetup logic
            await testElevenLabsAPI(apiKeyInput.value.trim(), resultDiv);
        }
        
        // Load ElevenLabs voices in game settings
        async function loadElevenLabsVoicesInSettings() {
            const apiKey = document.getElementById('game-elevenlabs-api-key').value.trim();
            const voiceSelect = document.getElementById('game-elevenlabs-voice-id');
            
            if (!apiKey) {
                voiceSelect.innerHTML = '<option value="">Enter API key first</option>';
                return;
            }
            
            await loadVoicesForSetup(apiKey, voiceSelect);
        }
        
        // Test ElevenLabs voice in game settings
        async function testElevenLabsVoiceInSettings() {
            const apiKey = document.getElementById('game-elevenlabs-api-key').value.trim();
            const voiceId = document.getElementById('game-elevenlabs-voice-id').value;
            
            if (!apiKey || !voiceId) {
                alert('Please enter API key and select a voice first.');
                return;
            }
            
            const testText = "Greetings, adventurers! Welcome to your epic quest!";
            
            try {
                await generateElevenLabsSpeech(testText, apiKey, voiceId);
            } catch (error) {
                console.error('Error testing voice:', error);
                alert('Error testing voice: ' + error.message);
            }
        }
        
        // Helper function to test OpenAI API
        async function testOpenAIAPI(apiKey, resultDiv) {
            if (!apiKey) {
                resultDiv.innerHTML = '<span style="color: red;">Please enter an API key first</span>';
                return;
            }
            
            resultDiv.innerHTML = '<span style="color: blue;">üîÑ Testing API key...</span>';
            
            try {
                const response = await fetch('https://api.openai.com/v1/models', {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Accept': 'application/json'
                    }
                });
                
                if (response.ok) {
                    resultDiv.innerHTML = '<span style="color: green;">‚úÖ API key valid!</span>';
                } else {
                    const errorText = await response.text();
                    resultDiv.innerHTML = `<span style="color: red;">‚ùå API Error ${response.status}: ${errorText.substring(0, 100)}</span>`;
                }
            } catch (error) {
                resultDiv.innerHTML = `<span style="color: red;">‚ùå Connection failed: ${error.message}</span>`;
            }
        }
        
        // Helper function to test ElevenLabs API
        async function testElevenLabsAPI(apiKey, resultDiv) {
            if (!apiKey) {
                resultDiv.innerHTML = '<span style="color: red;">Please enter an API key first</span>';
                return;
            }
            
            resultDiv.innerHTML = '<span style="color: blue;">üîÑ Testing API key...</span>';
            
            try {
                const response = await fetch('https://api.elevenlabs.io/v1/user', {
                    method: 'GET',
                    headers: {
                        'xi-api-key': apiKey,
                        'Accept': 'application/json'
                    }
                });
                
                if (response.ok) {
                    resultDiv.innerHTML = '<span style="color: green;">‚úÖ API key valid! Loading voices...</span>';
                    
                    // Auto-load voices after successful test
                    setTimeout(async () => {
                        const voiceSelect = document.getElementById('game-elevenlabs-voice-id');
                        await loadVoicesForSetup(apiKey, voiceSelect);
                    }, 1000);
                    
                } else {
                    const errorText = await response.text();
                    resultDiv.innerHTML = `<span style="color: red;">‚ùå API Error ${response.status}: ${errorText.substring(0, 100)}</span>`;
                }
            } catch (error) {
                resultDiv.innerHTML = `<span style="color: red;">‚ùå Connection failed: ${error.message}</span>`;
            }
        }
        
        // Save game settings
        function saveGameSettings() {
            console.log('Saving game settings...');
            
            // AI Settings
            const aiEngine = document.querySelector('input[name="gameAiEngine"]:checked').value;
            openAIConfig.enabled = aiEngine === 'openai';
            
            if (openAIConfig.enabled) {
                openAIConfig.apiKey = document.getElementById('game-openai-api-key').value.trim();
                openAIConfig.model = document.getElementById('game-ai-model').value;
                openAIConfig.creativity = parseFloat(document.getElementById('game-ai-creativity').value) / 100;
                openAIConfig.responseLength = document.getElementById('game-ai-response-length').value;
                
                // Save to localStorage
                localStorage.setItem('openai_api_key', openAIConfig.apiKey);
                localStorage.setItem('openai_model', openAIConfig.model);
                localStorage.setItem('openai_creativity', openAIConfig.creativity);
                localStorage.setItem('openai_response_length', openAIConfig.responseLength);
                localStorage.setItem('openai_enabled', 'true');
            } else {
                localStorage.setItem('openai_enabled', 'false');
            }
            
            // Voice Settings
            const voiceEngine = document.querySelector('input[name="gameVoiceEngine"]:checked').value;
            elevenLabsConfig.enabled = voiceEngine === 'elevenlabs';
            
            if (elevenLabsConfig.enabled) {
                elevenLabsConfig.apiKey = document.getElementById('game-elevenlabs-api-key').value.trim();
                elevenLabsConfig.voiceId = document.getElementById('game-elevenlabs-voice-id').value;
                elevenLabsConfig.stability = parseFloat(document.getElementById('game-voice-stability').value) / 100;
                elevenLabsConfig.clarity = parseFloat(document.getElementById('game-voice-clarity').value) / 100;
                
                // Save to localStorage
                localStorage.setItem('elevenlabs_api_key', elevenLabsConfig.apiKey);
                localStorage.setItem('elevenlabs_voice_id', elevenLabsConfig.voiceId);
                localStorage.setItem('elevenlabs_stability', elevenLabsConfig.stability);
                localStorage.setItem('elevenlabs_clarity', elevenLabsConfig.clarity);
                localStorage.setItem('voice_engine', 'elevenlabs');
            } else {
                localStorage.setItem('voice_engine', 'browser');
            }
            
            // Game Preferences
            const autoSaveEnabled = document.getElementById('game-auto-save-enabled').checked;
            setAutoSave(autoSaveEnabled);
            
            openAIConfig.useCampaignContext = document.getElementById('game-use-campaign-context').checked;
            openAIConfig.useReferenceData = document.getElementById('game-use-reference-data').checked;
            localStorage.setItem('openai_use_context', openAIConfig.useCampaignContext);
            localStorage.setItem('openai_use_reference', openAIConfig.useReferenceData);
            
            // Save to current campaign
            if (window.currentCampaign) {
                saveCurrentCampaignData();
            }
            
            // Update UI elements
            updateDMVoiceToggle();
            
            // Close modal
            document.getElementById('game-settings-modal').style.display = 'none';
            
            // Show success message
            showNotification('Settings saved successfully!', 'success', 3000);
            
            console.log('‚úÖ Game settings saved:', {
                openai: openAIConfig.enabled,
                elevenlabs: elevenLabsConfig.enabled,
                autoSave: autoSaveEnabled
            });
        }
        
        // Update DM Voice toggle button text
        function updateDMVoiceToggle() {
            const toggle = document.getElementById('dm-voice-toggle');
            if (toggle) {
                if (elevenLabsConfig.enabled && elevenLabsConfig.apiKey) {
                    toggle.textContent = 'üîä DM Voice: ElevenLabs';
                } else {
                    toggle.textContent = 'üîä DM Voice: Browser';
                }
            }
        }

        // ===============================
        // AI DM CONVERSATION SYSTEM
        // ===============================
        
        // Initialize conversation when game starts
        function initializeAdventure() {
            console.log('Initializing adventure...');
            
            // Clear any existing conversation
            const history = document.getElementById('conversation-history');
            if (history) {
                history.innerHTML = '';
            }
            
            // Start with the initial story beat
            startInitialStory();
        }
        
        // Get scenario-specific opening based on selected scenario
        function getScenarioOpening(scenario) {
            const scenarioOpenings = {
                mysterious_caravan: {
                    setting: "at the last known location of a missing merchant caravan",
                    description: "Wagon tracks lead off the main road into dense woods, and scattered coins glint in the mud. The silence is unsettling.",
                    hook: "You must discover what happened to the caravan and its valuable cargo."
                },
                goblin_raids: {
                    setting: "on the outskirts of Millhaven village",
                    description: "Smoke rises from burned farms, and frightened villagers huddle behind hastily built barricades. Goblin war cries echo in the distance.",
                    hook: "The villagers desperately need your help to drive back the goblin raiders."
                },
                ancient_ruins: {
                    setting: "before the entrance to long-forgotten ruins",
                    description: "Ancient stone archways covered in mysterious runes loom before you. Strange magical energies pulse from within the depths.",
                    hook: "Legend speaks of powerful artifacts hidden within these dangerous ruins."
                },
                political_intrigue: {
                    setting: "in the grand halls of the royal palace",
                    description: "Nobles in fine clothing whisper in shadowy corners, their words dripping with hidden meanings. Trust is a luxury you cannot afford.",
                    hook: "You must navigate the treacherous waters of court politics to uncover a conspiracy."
                }
            };
            
            return scenarioOpenings[scenario] || scenarioOpenings.mysterious_caravan;
        }
        
        // Get varied prompts instead of always "What do you do?"
        function getVariedPrompt() {
            const prompts = [
                "The choice is yours...",
                "How will you proceed?",
                "The moment hangs in the air...",
                "Your next move could change everything.",
                "The path forward awaits your decision.",
                "What happens next is up to you.",
                "The adventure continues...",
                "Your response will shape what comes next.",
                "The scene awaits your action.",
                "How do you respond?"
            ];
            return prompts[Math.floor(Math.random() * prompts.length)];
        }

        // Start the initial story
        function startInitialStory() {
            const campaign = window.currentCampaign;
            const characters = window.partyCharacters || [];
            const scenarioInfo = getScenarioOpening(campaign?.startingScenario || 'mysterious_caravan');
            
            // Create spoken version (cleaner for voice)
            const spokenIntro = `Welcome, brave adventurers, to ${campaign?.name || 'your epic adventure'}! 
                You find yourselves in the ${campaign?.startingRegion || 'Sword Coast'}, ${scenarioInfo.setting}. 
                ${scenarioInfo.description} 
                ${characters.length > 0 ? `Your party consists of ${characters.map(c => `${c.name}, a level ${c.level} ${c.species} ${c.class}`).join(', ')}.` : 'Your character stands ready to begin this journey.'}
                ${scenarioInfo.hook}`;
            
            let initialStory = `
                <div class="dm-message voice-message">
                    <div class="message-header">
                        <strong>üé≠ Dungeon Master</strong>
                        <span class="voice-indicator-small">üîä</span>
                        <span class="timestamp">${new Date().toLocaleTimeString()}</span>
                    </div>
                    <div class="message-content">
                        <p>Welcome, brave adventurers, to <strong>${campaign?.name || 'your epic adventure'}</strong>!</p>
                        
                        <p>You find yourselves in the <strong>${campaign?.startingRegion || 'Sword Coast'}</strong>, ${scenarioInfo.setting}.</p>
                        
                        <p>${scenarioInfo.description}</p>
                        
                        ${characters.length > 0 ? `<p>Your party consists of:</p><ul>${characters.map(c => `<li><strong>${c.name}</strong> - Level ${c.level} ${c.species} ${c.class}</li>`).join('')}</ul>` : '<p>Your character stands ready to begin this journey.</p>'}
                        
                        <p><strong>${scenarioInfo.hook}</strong></p>
                        
                        <p class="dm-prompt"><em>${getVariedPrompt()}</em></p>
                    </div>
                </div>
            `;
            
            appendToConversation(initialStory);
            
            // Speak the introduction
            setTimeout(() => {
                speakAsDM(spokenIntro);
            }, 1000);
            
            // Update game status and DM state with proper context
            const actualLocation = campaign?.startingScenario === 'goblin_raids' ? 'Millhaven village' : (campaign?.startingRegion || 'Ancient Forest');
            updateGameStatus(actualLocation, 'Morning', 'Clear skies');
            
            // CRITICAL: Set DM state to match the actual scenario
            DM_STATE.currentLocation = actualLocation;
            DM_STATE.currentScene = campaign?.startingScenario === 'goblin_raids' ? 'combat_imminent' : 'exploration';
            
            // Add initial context to conversation history
            DM_STATE.conversationHistory.push({
                type: 'dm_response',
                content: `Setting: ${actualLocation}. Scenario: ${scenarioInfo.description} ${scenarioInfo.hook}`,
                timestamp: Date.now()
            });
            
            console.log('DM State initialized:', {
                location: DM_STATE.currentLocation,
                scene: DM_STATE.currentScene,
                scenario: campaign?.startingScenario
            });
        }
        
        
        // Send player action
        function sendPlayerAction() {
            const input = document.getElementById('player-input');
            const action = input.value.trim();
            
            if (!action) {
                alert('Please enter an action first!');
                return;
            }
            
            // Check if we're waiting for initiative
            if (DM_STATE.waitingForInitiative) {
                processInitiativeResponse(action);
                input.value = '';
                return;
            }
            
            // Process movement commands and show visual feedback
            const movementResult = processMovementCommand(action);
            if (movementResult) {
                // Add movement confirmation to chat
                const movementMessage = `
                    <div class="system-message">
                        <div class="message-header">
                            <strong>üó∫Ô∏è Battlemap</strong>
                            <span class="timestamp">${new Date().toLocaleTimeString()}</span>
                        </div>
                        <div class="message-content">
                            <p>${movementResult}</p>
                        </div>
                    </div>
                `;
                appendToConversation(movementMessage);
                input.value = '';
                return; // Don't send to DM if it was just movement
            }
            
            // Add player message to conversation
            const playerMessage = `
                <div class="player-message">
                    <div class="message-header">
                        <strong>üé≠ ${getActiveCharacterName()}</strong>
                        <span class="timestamp">${new Date().toLocaleTimeString()}</span>
                    </div>
                    <div class="message-content">
                        <p>${action}</p>
                    </div>
                </div>
            `;
            
            appendToConversation(playerMessage);
            
            // Clear input
            input.value = '';
            
            // Generate AI DM response
            setTimeout(() => {
                generateDMResponse(action);
            }, 1000);
        }
        
        // Check if DM response indicates combat should start
        function checkForCombatInitiation(dmResponse, playerAction) {
            // Don't start combat if already in combat
            if (combatState.active) return;
            
            const responseLower = dmResponse.toLowerCase();
            
            // Combat trigger phrases from DM
            const combatTriggers = [
                'roll for initiative',
                'roll initiative', 
                'initiative!',
                'combat begins',
                'battle is joined',
                'weapons are drawn',
                'attacks you',
                'lunges at you',
                'charges toward',
                'hostile intent',
                'combat has begun',
                'fight breaks out'
            ];
            
            // Check if DM is initiating combat
            const dmInitiatingCombat = combatTriggers.some(trigger => responseLower.includes(trigger));
            
            if (dmInitiatingCombat) {
                console.log('‚öîÔ∏è Combat detected! Starting combat sequence...');
                
                // Extract enemies from the DM response (look for common enemy mentions)
                const enemies = extractEnemiesFromResponse(dmResponse);
                
                // Start the combat initialization
                initiateCombatWithEnemies(enemies);
            }
        }
        
        // Extract enemy information from DM response
        function extractEnemiesFromResponse(dmResponse) {
            const enemies = [];
            const responseLower = dmResponse.toLowerCase();
            
            // Common enemy patterns
            const enemyPatterns = [
                { pattern: /(\d+)\s+(goblin|goblins)/i, name: 'Goblin', hp: 7, ac: 15 },
                { pattern: /(\d+)\s+(orc|orcs)/i, name: 'Orc', hp: 15, ac: 13 },
                { pattern: /(\d+)\s+(bandit|bandits)/i, name: 'Bandit', hp: 11, ac: 12 },
                { pattern: /(\d+)\s+(wolf|wolves)/i, name: 'Wolf', hp: 11, ac: 13 },
                { pattern: /(\d+)\s+(skeleton|skeletons)/i, name: 'Skeleton', hp: 13, ac: 13 },
                { pattern: /(\d+)\s+(zombie|zombies)/i, name: 'Zombie', hp: 22, ac: 8 }
            ];
            
            // Try to extract enemies from response
            enemyPatterns.forEach(({ pattern, name, hp, ac }) => {
                const match = dmResponse.match(pattern);
                if (match) {
                    const count = parseInt(match[1]) || 1;
                    for (let i = 1; i <= count; i++) {
                        enemies.push({
                            name: count > 1 ? `${name} ${i}` : name,
                            baseType: name,
                            hp: hp,
                            maxHp: hp,
                            ac: ac,
                            initiative: 0,
                            type: 'enemy'
                        });
                    }
                }
            });
            
            // If no specific enemies found, create generic enemies
            if (enemies.length === 0) {
                enemies.push(
                    { name: 'Enemy 1', hp: 10, maxHp: 10, ac: 13, initiative: 0, type: 'enemy' },
                    { name: 'Enemy 2', hp: 10, maxHp: 10, ac: 13, initiative: 0, type: 'enemy' }
                );
            }
            
            return enemies;
        }
        
        // Initiate combat with identified enemies
        function initiateCombatWithEnemies(enemies) {
            // Roll initiative for all enemies
            enemies.forEach(enemy => {
                const roll = Math.floor(Math.random() * 20) + 1;
                const dexMod = enemy.baseType === 'Zombie' ? -1 : 
                             enemy.baseType === 'Wolf' ? 2 : 
                             enemy.baseType === 'Goblin' ? 2 : 0;
                enemy.initiative = roll + dexMod;
                console.log(`üé≤ ${enemy.name} rolled ${roll} + ${dexMod} = ${enemy.initiative} for initiative`);
            });
            
            // Store enemies temporarily
            window.combatEnemies = enemies;
            
            // Now ask players for their initiative
            const party = window.partyCharacters || [];
            
            if (party.length === 0) {
                // Single player
                askForPlayerInitiative();
            } else {
                // Multiple party members
                askForPartyInitiative(party);
            }
        }
        
        // Ask single player for initiative
        function askForPlayerInitiative() {
            const promptHTML = `
                <div class="dm-message combat-prompt">
                    <div class="message-header">
                        <strong>üé≠ Dungeon Master</strong>
                        <span class="timestamp">${new Date().toLocaleTimeString()}</span>
                    </div>
                    <div class="message-content">
                        <p><strong>‚öîÔ∏è Roll for Initiative!</strong></p>
                        <p>Roll 1d20 and add your Dexterity modifier. What did you get?</p>
                        <p class="example-text">Say: "I rolled 15" or "17 for initiative"</p>
                    </div>
                </div>
            `;
            
            appendToConversation(promptHTML);
            DM_STATE.waitingForInitiative = true;
            DM_STATE.waitingForPlayer = 'single';
        }
        
        // Ask multiple party members for initiative
        function askForPartyInitiative(party) {
            window.partyInitiatives = [];
            window.currentInitiativeIndex = 0;
            
            // Ask for first character's initiative
            askNextCharacterInitiative();
        }
        
        // Ask for next character's initiative
        function askNextCharacterInitiative() {
            const party = window.partyCharacters || [];
            const currentChar = party[window.currentInitiativeIndex];
            
            if (!currentChar) {
                // All initiatives collected, start combat
                finalizeCombatInitiatives();
                return;
            }
            
            const dexMod = Math.floor((currentChar.abilities?.dexterity?.score || 10) / 2) - 5;
            
            const promptHTML = `
                <div class="dm-message combat-prompt">
                    <div class="message-header">
                        <strong>üé≠ Dungeon Master</strong>
                        <span class="timestamp">${new Date().toLocaleTimeString()}</span>
                    </div>
                    <div class="message-content">
                        <p><strong>${currentChar.name}</strong>, roll for initiative!</p>
                        <p>Roll 1d20 and add ${dexMod >= 0 ? '+' : ''}${dexMod} (DEX modifier)</p>
                        <p class="example-text">Say: "I rolled 15" or "${currentChar.name} got 17"</p>
                    </div>
                </div>
            `;
            
            appendToConversation(promptHTML);
            DM_STATE.waitingForInitiative = true;
            DM_STATE.waitingForPlayer = currentChar.name;
        }
        
        // Process initiative response from player
        function processInitiativeResponse(playerMessage) {
            // Extract number from response
            const match = playerMessage.match(/\d+/);
            if (!match) {
                appendToConversation(`
                    <div class="dm-message">
                        <div class="message-header">
                            <strong>üé≠ Dungeon Master</strong>
                        </div>
                        <div class="message-content">
                            <p>I need a number for your initiative roll. What did you get?</p>
                        </div>
                    </div>
                `);
                return;
            }
            
            const initiative = parseInt(match[0]);
            
            if (DM_STATE.waitingForPlayer === 'single') {
                // Single player initiative
                window.playerInitiative = initiative;
                finalizeCombatInitiatives();
            } else {
                // Party member initiative
                const party = window.partyCharacters || [];
                const currentChar = party[window.currentInitiativeIndex];
                
                window.partyInitiatives.push({
                    character: currentChar,
                    initiative: initiative
                });
                
                console.log(`üìù ${currentChar.name} initiative: ${initiative}`);
                
                // Move to next character
                window.currentInitiativeIndex++;
                askNextCharacterInitiative();
            }
        }
        
        // Finalize combat with all initiatives
        function finalizeCombatInitiatives() {
            const allCombatants = [];
            
            // Add enemies
            if (window.combatEnemies) {
                allCombatants.push(...window.combatEnemies);
            }
            
            // Add party members
            if (window.partyInitiatives && window.partyInitiatives.length > 0) {
                window.partyInitiatives.forEach(pi => {
                    allCombatants.push({
                        ...pi.character,
                        name: pi.character.name,
                        initiative: pi.initiative,
                        hp: pi.character.combat?.hitPoints?.current || 10,
                        maxHp: pi.character.combat?.hitPoints?.max || 10,
                        ac: pi.character.combat?.armorClass || 10,
                        type: 'player'
                    });
                });
            } else if (window.playerInitiative) {
                // Single player
                allCombatants.push({
                    name: 'Player',
                    initiative: window.playerInitiative,
                    hp: 20,
                    maxHp: 20,
                    ac: 15,
                    type: 'player'
                });
            }
            
            // Sort by initiative (highest first)
            allCombatants.sort((a, b) => b.initiative - a.initiative);
            
            // Store in combat state
            combatState.active = true;
            combatState.combatants = allCombatants;
            combatState.round = 1;
            combatState.currentTurn = 0;
            
            // Display the initiative tracker
            displayInitiativeTracker();
            
            // Clean up temporary variables
            DM_STATE.waitingForInitiative = false;
            DM_STATE.waitingForPlayer = null;
            delete window.combatEnemies;
            delete window.partyInitiatives;
            delete window.currentInitiativeIndex;
            delete window.playerInitiative;
        }
        
        // Display visual initiative tracker
        function displayInitiativeTracker() {
            const trackerHTML = `
                <div class="initiative-tracker-display">
                    <div class="tracker-header">
                        <h3>‚öîÔ∏è Initiative Order - Round ${combatState.round}</h3>
                    </div>
                    <div class="tracker-list">
                        ${combatState.combatants.map((c, index) => `
                            <div class="tracker-entry ${c.type} ${index === combatState.currentTurn ? 'current-turn' : ''}">
                                <div class="entry-info">
                                    <span class="entry-name">${c.type === 'enemy' ? 'üëπ' : 'üõ°Ô∏è'} ${c.name}</span>
                                    <span class="entry-hp">HP: ${c.hp}/${c.maxHp}</span>
                                </div>
                                <div class="entry-initiative">
                                    <span class="init-value">${c.initiative}</span>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                    <div class="tracker-footer">
                        <p>Current Turn: <strong>${combatState.combatants[combatState.currentTurn].name}</strong></p>
                    </div>
                </div>
            `;
            
            appendToConversation(trackerHTML);
            
            // Also create a persistent tracker on the side
            updatePersistentInitiativeTracker();
            
            // Announce combat start
            const firstCombatant = combatState.combatants[0];
            const startMessage = `
                <div class="dm-message">
                    <div class="message-header">
                        <strong>üé≠ Dungeon Master</strong>
                        <span class="timestamp">${new Date().toLocaleTimeString()}</span>
                    </div>
                    <div class="message-content">
                        <p><strong>Combat begins!</strong></p>
                        <p>${firstCombatant.name} goes first with initiative ${firstCombatant.initiative}!</p>
                        ${firstCombatant.type === 'player' ? 
                            '<p>What do you do for your turn?</p>' : 
                            '<p>The enemy prepares to attack...</p>'}
                    </div>
                </div>
            `;
            
            appendToConversation(startMessage);
        }
        
        // Update persistent initiative tracker (sidebar)
        function updatePersistentInitiativeTracker() {
            // Check if we have a combat sidebar element
            let tracker = document.getElementById('persistent-initiative-tracker');
            
            if (!tracker) {
                // Create it if it doesn't exist
                const gameScreen = document.getElementById('game-screen');
                if (gameScreen) {
                    const trackerDiv = document.createElement('div');
                    trackerDiv.id = 'persistent-initiative-tracker';
                    trackerDiv.className = 'persistent-tracker';
                    trackerDiv.style.cssText = `
                        position: fixed;
                        right: 20px;
                        top: 100px;
                        width: 250px;
                        background: rgba(26, 26, 26, 0.95);
                        border: 2px solid #8B4513;
                        border-radius: 10px;
                        padding: 15px;
                        z-index: 100;
                        box-shadow: 0 4px 6px rgba(0,0,0,0.3);
                    `;
                    gameScreen.appendChild(trackerDiv);
                    tracker = trackerDiv;
                }
            }
            
            if (tracker) {
                tracker.innerHTML = `
                    <h4 style="color: #FFD700; margin: 0 0 10px 0;">‚öîÔ∏è Combat - Round ${combatState.round}</h4>
                    <div class="mini-tracker-list">
                        ${combatState.combatants.map((c, index) => `
                            <div style="
                                padding: 5px;
                                margin: 2px 0;
                                background: ${index === combatState.currentTurn ? '#4a4a2e' : 'rgba(0,0,0,0.3)'};
                                border-radius: 5px;
                                display: flex;
                                justify-content: space-between;
                                align-items: center;
                                ${index === combatState.currentTurn ? 'border: 1px solid #FFD700;' : ''}
                            ">
                                <span style="color: ${c.type === 'enemy' ? '#ff6b6b' : '#4fc3f7'};">
                                    ${c.name}
                                </span>
                                <span style="color: #FFD700; font-weight: bold;">
                                    ${c.initiative}
                                </span>
                            </div>
                        `).join('')}
                    </div>
                    <button onclick="endCombat()" style="
                        width: 100%;
                        margin-top: 10px;
                        padding: 5px;
                        background: #8B4513;
                        color: white;
                        border: none;
                        border-radius: 5px;
                        cursor: pointer;
                    ">End Combat</button>
                `;
            }
        }
        
        // End combat
        function endCombat() {
            combatState.active = false;
            combatState.combatants = [];
            combatState.round = 0;
            combatState.currentTurn = 0;
            
            // Remove persistent tracker
            const tracker = document.getElementById('persistent-initiative-tracker');
            if (tracker) {
                tracker.remove();
            }
            
            appendToConversation(`
                <div class="dm-message">
                    <div class="message-header">
                        <strong>üé≠ Dungeon Master</strong>
                        <span class="timestamp">${new Date().toLocaleTimeString()}</span>
                    </div>
                    <div class="message-content">
                        <p><strong>Combat has ended.</strong></p>
                        <p>The dust settles and calm returns to the area.</p>
                    </div>
                </div>
            `);
        }
        
        // Prompt players to roll initiative
        function promptForInitiativeRolls() {
            const party = window.partyCharacters || [];
            
            if (party.length === 0) {
                alert('No party members found! Add characters to your party first.');
                return;
            }
            
            // Create initiative roll dialog
            const initiativeHTML = `
                <div class="initiative-dialog">
                    <h3>üé≤ Roll Initiative</h3>
                    <p>Roll 1d20 + DEX modifier for each character:</p>
                    <div class="initiative-rolls">
                        ${party.map(char => {
                            const dexMod = Math.floor((char.abilities?.dexterity?.score || 10) / 2) - 5;
                            return `
                                <div class="character-initiative">
                                    <label>${char.name} (DEX ${dexMod >= 0 ? '+' : ''}${dexMod}):</label>
                                    <input type="number" id="init-${char.id}" placeholder="Total roll" min="1" max="30">
                                    <button onclick="rollInitiativeFor('${char.id}')">üé≤ Roll</button>
                                </div>
                            `;
                        }).join('')}
                    </div>
                    <button class="primary-button" onclick="submitInitiativeRolls()">Start Combat</button>
                </div>
            `;
            
            // Display as modal or in conversation
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.innerHTML = `
                <div class="modal-content">
                    ${initiativeHTML}
                </div>
            `;
            document.body.appendChild(modal);
        }
        
        // Roll initiative for a specific character
        function rollInitiativeFor(characterId) {
            const char = window.partyCharacters.find(c => c.id === characterId);
            if (!char) return;
            
            const dexMod = Math.floor((char.abilities?.dexterity?.score || 10) / 2) - 5;
            const roll = Math.floor(Math.random() * 20) + 1;
            const total = roll + dexMod;
            
            document.getElementById(`init-${characterId}`).value = total;
            
            // Show roll result
            const rollMessage = `üé≤ ${char.name} rolled ${roll} + ${dexMod} = ${total} for initiative`;
            console.log(rollMessage);
        }
        
        // Submit all initiative rolls and start combat
        function submitInitiativeRolls() {
            const party = window.partyCharacters || [];
            const initiativeResults = [];
            
            // Collect all initiative values
            party.forEach(char => {
                const input = document.getElementById(`init-${char.id}`);
                const initiative = parseInt(input?.value || 10);
                initiativeResults.push({
                    character: char,
                    initiative: initiative
                });
            });
            
            // Close modal
            document.querySelector('.modal-overlay')?.remove();
            
            // Start proper D&D combat with these initiatives
            startProperCombat(initiativeResults);
        }
        
        // Start combat with proper D&D rules
        function startProperCombat(playerInitiatives) {
            console.log('‚öîÔ∏è Starting proper D&D combat with initiatives:', playerInitiatives);
            
            // Initialize combat state
            combatState.active = true;
            combatState.round = 1;
            combatState.currentTurn = 0;
            
            // Add player characters with their rolled initiatives
            combatState.combatants = playerInitiatives.map(pi => ({
                ...pi.character,
                type: 'player',
                initiative: pi.initiative,
                hp: pi.character.combat?.hitPoints?.current || 10,
                maxHp: pi.character.combat?.hitPoints?.max || 10,
                ac: pi.character.combat?.armorClass || 10,
                conditions: []
            }));
            
            // DM will add enemies with their initiatives
            const combatStartMessage = `
                <div class="dm-message">
                    <div class="message-header">
                        <strong>üé≠ Dungeon Master</strong>
                        <span class="timestamp">${new Date().toLocaleTimeString()}</span>
                    </div>
                    <div class="message-content">
                        <p><strong>‚öîÔ∏è Combat has begun!</strong></p>
                        <p>Initiative order will be established once all combatants have rolled.</p>
                        <p>Waiting for enemy initiatives...</p>
                    </div>
                </div>
            `;
            
            appendToConversation(combatStartMessage);
            
            // Ask DM to roll for enemies
            DM_STATE.waitingForEnemyInitiative = true;
            
            // Update DM state
            DM_STATE.combatActive = true;
            DM_STATE.combatPending = false;
            DM_STATE.waitingForInitiative = false;
        }

        // ===============================
        // DYNAMIC BATTLEMAP SYSTEM
        // ===============================

        const BATTLEMAP = {
            canvas: null,
            ctx: null,
            scale: 1,
            offsetX: 0,
            offsetY: 0,
            gridSize: 30,
            showGrid: true,
            tokens: new Map(),
            currentMap: null,
            mapData: {
                type: 'town', // town, forest, dungeon, tavern, etc.
                width: 20,
                height: 20,
                features: [] // walls, trees, buildings, etc.
            }
        };

        // Initialize battlemap system
        function initializeBattlemap() {
            const canvas = document.getElementById('map-canvas');
            if (!canvas) return;
            
            BATTLEMAP.canvas = canvas;
            BATTLEMAP.ctx = canvas.getContext('2d');
            
            // Set proper canvas dimensions with extra space for token names
            const container = document.getElementById('battlemap');
            const rect = container.getBoundingClientRect();
            canvas.width = rect.width - 4; // Account for border
            canvas.height = rect.height - 4;
            
            // Ensure text rendering is crisp and visible
            const ctx = BATTLEMAP.ctx;
            ctx.textBaseline = 'alphabetic';
            ctx.imageSmoothingEnabled = true;
            ctx.textRenderingOptimization = 'optimizeQuality';
            
            // Debug: Log canvas setup
            console.log('üó∫Ô∏è Canvas setup:', { width: canvas.width, height: canvas.height, gridSize: BATTLEMAP.gridSize });
            
            // Handle resize with debouncing
            window.addEventListener('resize', () => {
                setTimeout(() => {
                    const rect = container.getBoundingClientRect();
                    canvas.width = rect.width - 4;
                    canvas.height = rect.height - 4;
                    drawMap();
                }, 100);
            });
            
            // Generate initial map based on story context
            generateMap('village');
            drawMap();
            
            console.log('üó∫Ô∏è Battlemap system initialized');
        }

        // Generate map based on location type
        function generateMap(locationType) {
            BATTLEMAP.mapData.type = locationType;
            BATTLEMAP.mapData.features = [];
            
            switch(locationType.toLowerCase()) {
                case 'village':
                case 'town':
                case 'millhaven':
                    generateTownMap();
                    break;
                case 'forest':
                case 'woods':
                    generateForestMap();
                    break;
                case 'dungeon':
                case 'cave':
                    generateDungeonMap();
                    break;
                case 'tavern':
                case 'inn':
                    generateTavernMap();
                    break;
                default:
                    generateGenericMap();
            }
            
            // Update map location display (if element exists)
            const mapLocationElement = document.getElementById('map-location-name');
            if (mapLocationElement) {
                mapLocationElement.textContent = locationType.charAt(0).toUpperCase() + locationType.slice(1);
            } else {
                console.log(`üó∫Ô∏è Generated ${locationType} battle map`);
            }
        }

        // Generate town/village map
        function generateTownMap() {
            BATTLEMAP.mapData.width = 20;
            BATTLEMAP.mapData.height = 20;
            
            // Add buildings
            const buildings = [
                {type: 'building', x: 2, y: 3, width: 3, height: 3, name: 'Tavern'},
                {type: 'building', x: 7, y: 2, width: 2, height: 4, name: 'Shop'},
                {type: 'building', x: 12, y: 4, width: 4, height: 2, name: 'House'},
                {type: 'building', x: 3, y: 8, width: 2, height: 2, name: 'House'},
                {type: 'building', x: 14, y: 8, width: 3, height: 3, name: 'Temple'},
                {type: 'building', x: 8, y: 12, width: 4, height: 3, name: 'Barracks'}
            ];
            
            // Add roads/paths
            const roads = [
                {type: 'road', x: 0, y: 10, width: 20, height: 1}, // Main road
                {type: 'road', x: 10, y: 0, width: 1, height: 20}, // Cross road
            ];
            
            // Add some trees/decoration
            const nature = [
                {type: 'tree', x: 1, y: 1},
                {type: 'tree', x: 18, y: 2},
                {type: 'tree', x: 16, y: 16},
                {type: 'tree', x: 2, y: 18}
            ];
            
            BATTLEMAP.mapData.features = [...buildings, ...roads, ...nature];
        }

        // Generate forest map
        function generateForestMap() {
            BATTLEMAP.mapData.width = 20;
            BATTLEMAP.mapData.height = 20;
            
            const features = [];
            
            // Random trees
            for (let i = 0; i < 30; i++) {
                features.push({
                    type: 'tree',
                    x: Math.floor(Math.random() * 18) + 1,
                    y: Math.floor(Math.random() * 18) + 1
                });
            }
            
            // Some clearings
            features.push({type: 'clearing', x: 8, y: 8, width: 4, height: 4});
            features.push({type: 'clearing', x: 14, y: 3, width: 3, height: 3});
            
            BATTLEMAP.mapData.features = features;
        }

        // Generate dungeon map
        function generateDungeonMap() {
            BATTLEMAP.mapData.width = 15;
            BATTLEMAP.mapData.height = 15;
            
            const features = [];
            
            // Walls around perimeter
            for (let x = 0; x < 15; x++) {
                features.push({type: 'wall', x: x, y: 0});
                features.push({type: 'wall', x: x, y: 14});
            }
            for (let y = 0; y < 15; y++) {
                features.push({type: 'wall', x: 0, y: y});
                features.push({type: 'wall', x: 14, y: y});
            }
            
            // Interior walls
            features.push({type: 'wall', x: 5, y: 3, width: 1, height: 8});
            features.push({type: 'wall', x: 9, y: 5, width: 1, height: 6});
            
            // Doors
            features.push({type: 'door', x: 5, y: 7});
            features.push({type: 'door', x: 9, y: 8});
            
            BATTLEMAP.mapData.features = features;
        }

        // Generate tavern interior
        function generateTavernMap() {
            BATTLEMAP.mapData.width = 12;
            BATTLEMAP.mapData.height = 10;
            
            const features = [
                // Walls
                {type: 'wall', x: 0, y: 0, width: 12, height: 1},
                {type: 'wall', x: 0, y: 9, width: 12, height: 1},
                {type: 'wall', x: 0, y: 0, width: 1, height: 10},
                {type: 'wall', x: 11, y: 0, width: 1, height: 10},
                
                // Bar
                {type: 'furniture', x: 8, y: 2, width: 3, height: 1, name: 'Bar'},
                
                // Tables
                {type: 'furniture', x: 2, y: 3, width: 1, height: 1, name: 'Table'},
                {type: 'furniture', x: 5, y: 4, width: 1, height: 1, name: 'Table'},
                {type: 'furniture', x: 2, y: 7, width: 1, height: 1, name: 'Table'},
                
                // Door
                {type: 'door', x: 5, y: 9}
            ];
            
            BATTLEMAP.mapData.features = features;
        }

        // Generate generic outdoor map
        function generateGenericMap() {
            BATTLEMAP.mapData.width = 16;
            BATTLEMAP.mapData.height = 16;
            
            const features = [];
            
            // Some random terrain features
            for (let i = 0; i < 8; i++) {
                const featureType = ['tree', 'rock', 'bush'][Math.floor(Math.random() * 3)];
                features.push({
                    type: featureType,
                    x: Math.floor(Math.random() * 14) + 1,
                    y: Math.floor(Math.random() * 14) + 1
                });
            }
            
            BATTLEMAP.mapData.features = features;
        }

        // Draw the entire map
        function drawMap() {
            if (!BATTLEMAP.ctx) return;
            
            const ctx = BATTLEMAP.ctx;
            const canvas = BATTLEMAP.canvas;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background
            ctx.fillStyle = getMapBackgroundColor();
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            if (BATTLEMAP.showGrid) {
                drawGrid();
            }
            
            // Draw map features
            drawMapFeatures();
            
            // Draw tokens
            drawTokens();
        }

        // Get background color based on map type
        function getMapBackgroundColor() {
            switch(BATTLEMAP.mapData.type) {
                case 'forest': return '#2d4a2d';
                case 'dungeon': return '#1a1a1a';
                case 'tavern': return '#3d2f1f';
                case 'town': case 'village': return '#4a4a3a';
                default: return '#3a4a3a';
            }
        }

        // Draw grid
        function drawGrid() {
            const ctx = BATTLEMAP.ctx;
            const canvas = BATTLEMAP.canvas;
            const gridSize = BATTLEMAP.gridSize * BATTLEMAP.scale;
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            
            // Vertical lines
            for (let x = 0; x <= canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // Horizontal lines
            for (let y = 0; y <= canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        // Draw map features
        function drawMapFeatures() {
            const ctx = BATTLEMAP.ctx;
            const features = BATTLEMAP.mapData.features;
            
            features.forEach(feature => {
                drawFeature(feature);
            });
        }

        // Draw individual feature
        function drawFeature(feature) {
            const ctx = BATTLEMAP.ctx;
            const x = feature.x * BATTLEMAP.gridSize * BATTLEMAP.scale;
            const y = feature.y * BATTLEMAP.gridSize * BATTLEMAP.scale;
            const size = BATTLEMAP.gridSize * BATTLEMAP.scale;
            const width = (feature.width || 1) * size;
            const height = (feature.height || 1) * size;
            
            switch(feature.type) {
                case 'building':
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(x, y, width, height);
                    ctx.strokeStyle = '#654321';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, y, width, height);
                    break;
                    
                case 'wall':
                    ctx.fillStyle = '#333333';
                    ctx.fillRect(x, y, width, height);
                    break;
                    
                case 'door':
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(x, y, size, size);
                    break;
                    
                case 'tree':
                    ctx.fillStyle = '#228B22';
                    ctx.beginPath();
                    ctx.arc(x + size/2, y + size/2, size/3, 0, 2 * Math.PI);
                    ctx.fill();
                    break;
                    
                case 'road':
                    ctx.fillStyle = '#8B7D6B';
                    ctx.fillRect(x, y, width, height);
                    break;
                    
                case 'furniture':
                    ctx.fillStyle = '#654321';
                    ctx.fillRect(x, y, width, height);
                    break;
                    
                case 'rock':
                    ctx.fillStyle = '#696969';
                    ctx.fillRect(x, y, size, size);
                    break;
                    
                case 'clearing':
                    ctx.fillStyle = '#90EE90';
                    ctx.fillRect(x, y, width, height);
                    break;
            }
        }

        // Draw tokens (players, NPCs, enemies)
        function drawTokens() {
            BATTLEMAP.tokens.forEach((token, id) => {
                drawToken(token);
            });
        }

        // Draw individual token
        function drawToken(token) {
            const ctx = BATTLEMAP.ctx;
            const x = token.x * BATTLEMAP.gridSize * BATTLEMAP.scale;
            const y = token.y * BATTLEMAP.gridSize * BATTLEMAP.scale;
            const size = BATTLEMAP.gridSize * BATTLEMAP.scale;
            
            // Debug: Log token drawing
            console.log('ü™ô Drawing token:', { name: token.name, x: token.x, y: token.y, screenX: x, screenY: y, size: size });
            
            // Token background
            ctx.fillStyle = getTokenColor(token.type);
            ctx.beginPath();
            ctx.arc(x + size/2, y + size/2, size/3, 0, 2 * Math.PI);
            ctx.fill();
            
            // Token border
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Token initial letter
            ctx.fillStyle = '#ffffff';
            ctx.font = `${Math.floor(size/4)}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText(token.name.charAt(0).toUpperCase(), x + size/2, y + size/2 + size/12);
            
            // Token name underneath - make it MUCH more visible
            const fontSize = Math.max(14, Math.floor(size/3)); // Much larger font
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.textAlign = 'center';
            
            // Position name well below token to avoid clipping
            const nameY = y + size + fontSize + 8;
            
            // Draw thick black outline for better visibility
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 4;
            ctx.strokeText(token.name, x + size/2, nameY);
            
            // Draw bright white text on top
            ctx.fillStyle = '#ffffff';
            ctx.fillText(token.name, x + size/2, nameY);
            
            // Debug: Log name rendering
            console.log('üìù Token name rendered:', { name: token.name, nameX: x + size/2, nameY: nameY, fontSize: fontSize });
        }

        // Get token color based on type
        function getTokenColor(type) {
            switch(type) {
                case 'player': return '#4169E1';
                case 'npc': return '#32CD32';
                case 'enemy': return '#DC143C';
                default: return '#808080';
            }
        }

        // Add token to map
        function addTokenToMap(name, type, x, y) {
            const token = {
                name: name,
                type: type,
                x: x,
                y: y
            };
            BATTLEMAP.tokens.set(name, token);
            console.log(`ü™ô Added ${type} token: ${name} at (${x}, ${y})`, token);
            console.log('üó∫Ô∏è Current tokens:', Array.from(BATTLEMAP.tokens.entries()));
            drawMap();
        }

        // Move token
        function moveToken(name, newX, newY) {
            const token = BATTLEMAP.tokens.get(name);
            if (token) {
                token.x = newX;
                token.y = newY;
                drawMap();
                console.log(`üö∂ Moved ${name} to (${newX}, ${newY})`);
            }
        }

        // Remove token
        function removeToken(name) {
            BATTLEMAP.tokens.delete(name);
            drawMap();
            console.log(`üö´ Removed token: ${name}`);
        }
        
        // Manual redraw function for debugging
        function forceRedrawBattlemap() {
            console.log('üîÑ Force redrawing battlemap...');
            console.log('üìä Current tokens:', Array.from(BATTLEMAP.tokens.entries()));
            if (BATTLEMAP.ctx) {
                drawMap();
                console.log('‚úÖ Battlemap redrawn');
            } else {
                console.log('‚ùå No canvas context available');
            }
        }
        
        // Make debugging functions globally accessible
        window.forceRedrawBattlemap = forceRedrawBattlemap;
        window.BATTLEMAP = BATTLEMAP;

        // ===== ENHANCED BATTLE MAP GENERATION FROM DM RESPONSES =====
        
        // Check if DM response indicates a new location that needs a battle map
        function checkIfMapNeeded(dmResponse) {
            if (!dmResponse || typeof dmResponse !== 'string') return false;
            
            const response = dmResponse.toLowerCase();
            
            // Location keywords that trigger map generation
            const locationKeywords = [
                'enter', 'arrive', 'approach', 'find yourself', 'you see', 'before you', 
                'room', 'chamber', 'hall', 'corridor', 'tavern', 'inn', 'temple', 'cave',
                'forest', 'clearing', 'village', 'town', 'bridge', 'crossroads', 'market',
                'dungeon', 'tower', 'castle', 'ruins', 'underground', 'basement', 'attic',
                'courtyard', 'garden', 'library', 'laboratory', 'throne room', 'jail', 'prison'
            ];
            
            // Combat keywords that definitely need maps
            const combatKeywords = [
                'combat', 'fight', 'battle', 'attack', 'initiative', 'enemies', 'monsters',
                'bandits', 'goblins', 'orcs', 'undead', 'wolves', 'bears', 'dragon'
            ];
            
            const hasLocationKeyword = locationKeywords.some(keyword => response.includes(keyword));
            const hasCombatKeyword = combatKeywords.some(keyword => response.includes(keyword));
            
            return hasLocationKeyword || hasCombatKeyword;
        }
        
        // Generate battle map based on DM description with loading indicator
        function generateBattleMapFromDMDescription(dmResponse) {
            console.log('üó∫Ô∏è DM described a scene - generating battle map...');
            
            // Show loading indicator
            showBattleMapLoading('Reading DM\'s scene description...');
            
            // Analyze the description to determine map type
            const mapType = analyzeSceneForMapType(dmResponse);
            
            setTimeout(() => {
                updateBattleMapLoading('Generating terrain layout...');
                
                // Generate the appropriate map
                setTimeout(() => {
                    generateMap(mapType);
                    
                    updateBattleMapLoading('Adding environmental details...');
                    
                    setTimeout(() => {
                        drawMap();
                        
                        updateBattleMapLoading('Finalizing battle grid...');
                        
                        // Also initialize tactical battle map if available
                        setTimeout(() => {
                            if (window.DNDCore && window.DNDCore.getModule) {
                                const tacticalMap = window.DNDCore.getModule('tacticalBattleMap');
                                if (tacticalMap) {
                                    console.log('üó∫Ô∏è Updating tactical battle map based on DM description');
                                    
                                    // Choose appropriate test map based on scene
                                    if (mapType === 'dungeon') {
                                        tacticalMap.testDungeonMap();
                                    } else if (mapType === 'forest') {
                                        tacticalMap.testForestMap();  
                                    } else {
                                        tacticalMap.testVillageMap();
                                    }
                                }
                            }
                            
                            // Hide loading indicator
                            setTimeout(() => {
                                hideBattleMapLoading();
                                console.log('‚úÖ Battle map generated from DM scene description');
                            }, 800);
                            
                        }, 600);
                    }, 800);
                }, 1000);
            }, 500);
        }
        
        // Analyze DM response to determine appropriate map type
        function analyzeSceneForMapType(dmResponse) {
            const response = dmResponse.toLowerCase();
            
            // Specific environment detection
            if (response.includes('dungeon') || response.includes('underground') || 
                response.includes('cave') || response.includes('crypt') || response.includes('tomb')) {
                return 'dungeon';
            }
            
            if (response.includes('forest') || response.includes('woods') || 
                response.includes('trees') || response.includes('clearing')) {
                return 'forest';
            }
            
            if (response.includes('village') || response.includes('town') || 
                response.includes('tavern') || response.includes('inn') || response.includes('market')) {
                return 'village';
            }
            
            if (response.includes('castle') || response.includes('tower') || 
                response.includes('fortress') || response.includes('keep')) {
                return 'castle';
            }
            
            if (response.includes('temple') || response.includes('shrine') || 
                response.includes('church') || response.includes('altar')) {
                return 'temple';
            }
            
            // Default to village for general scenes
            return 'village';
        }
        
        // Enhanced battle map loading functions
        function showBattleMapLoading(message = 'Loading Battle Map...') {
            const loadingIndicator = document.getElementById('battle-map-loading');
            const loadingText = document.getElementById('battle-map-loading-text');
            
            if (loadingIndicator && loadingText) {
                loadingIndicator.style.display = 'block';
                loadingText.textContent = message;
                console.log('üîÑ ' + message);
            }
        }
        
        function updateBattleMapLoading(message) {
            const loadingText = document.getElementById('battle-map-loading-text');
            if (loadingText) {
                loadingText.textContent = message;
                console.log('üîÑ ' + message);
            }
        }
        
        function hideBattleMapLoading() {
            const loadingIndicator = document.getElementById('battle-map-loading');
            if (loadingIndicator) {
                loadingIndicator.style.display = 'none';
            }
        }

        // Map control functions
        function zoomIn() {
            BATTLEMAP.scale = Math.min(BATTLEMAP.scale * 1.2, 3);
            drawMap();
        }

        function zoomOut() {
            BATTLEMAP.scale = Math.max(BATTLEMAP.scale / 1.2, 0.5);
            drawMap();
        }

        function resetMapView() {
            BATTLEMAP.scale = 1;
            BATTLEMAP.offsetX = 0;
            BATTLEMAP.offsetY = 0;
            drawMap();
        }

        function toggleGrid() {
            BATTLEMAP.showGrid = document.getElementById('show-grid').checked;
            drawMap();
        }

        // Update map based on story context
        function updateMapFromStory(location, description) {
            // Generate new map if location changed significantly
            const currentType = BATTLEMAP.mapData.type;
            let newType = determineMapType(location, description);
            
            if (newType !== currentType) {
                generateMap(newType);
                drawMap();
                console.log(`üó∫Ô∏è Generated new ${newType} map`);
            }
            
            // Add/update NPCs and enemies based on description
            updateTokensFromDescription(description);
        }

        // Determine map type from location and description
        function determineMapType(location, description) {
            const locationLower = location.toLowerCase();
            const descriptionLower = description.toLowerCase();
            
            if (locationLower.includes('village') || locationLower.includes('town') || locationLower.includes('millhaven')) {
                return 'village';
            } else if (locationLower.includes('forest') || locationLower.includes('woods') || descriptionLower.includes('trees')) {
                return 'forest';
            } else if (locationLower.includes('tavern') || locationLower.includes('inn')) {
                return 'tavern';
            } else if (locationLower.includes('dungeon') || locationLower.includes('cave')) {
                return 'dungeon';
            }
            
            return 'generic';
        }

        // Update tokens based on description
        function updateTokensFromDescription(description) {
            // Look for enemy mentions and add tokens
            const enemyMatches = [
                { pattern: /(\d+)?\s*(goblin|goblins)/i, name: 'Goblin' },
                { pattern: /(\d+)?\s*(orc|orcs)/i, name: 'Orc' },
                { pattern: /(\d+)?\s*(bandit|bandits)/i, name: 'Bandit' }
            ];
            
            enemyMatches.forEach(({ pattern, name }) => {
                const match = description.match(pattern);
                if (match) {
                    const count = parseInt(match[1]) || 1;
                    for (let i = 1; i <= count; i++) {
                        const tokenName = count > 1 ? `${name} ${i}` : name;
                        if (!BATTLEMAP.tokens.has(tokenName)) {
                            // Place enemy at random location
                            const x = Math.floor(Math.random() * (BATTLEMAP.mapData.width - 2)) + 1;
                            const y = Math.floor(Math.random() * (BATTLEMAP.mapData.height - 2)) + 1;
                            addTokenToMap(tokenName, 'enemy', x, y);
                        }
                    }
                }
            });
        }

        // Process movement commands from voice/text
        function processMovementCommand(playerAction) {
            const actionLower = playerAction.toLowerCase();
            
            // Look for movement patterns
            const movePatterns = [
                { pattern: /(?:i\s+)?move\s+(?:to|towards?)\s+(?:the\s+)?(.+)/i, type: 'move_to' },
                { pattern: /(?:i\s+)?go\s+(?:to|towards?)\s+(?:the\s+)?(.+)/i, type: 'move_to' },
                { pattern: /(?:i\s+)?approach\s+(?:the\s+)?(.+)/i, type: 'move_to' },
                { pattern: /(?:i\s+)?walk\s+(?:to|towards?)\s+(?:the\s+)?(.+)/i, type: 'move_to' },
                { pattern: /(?:i\s+)?move\s+(north|south|east|west|up|down|left|right)/i, type: 'move_direction' },
                { pattern: /(?:i\s+)?go\s+(north|south|east|west|up|down|left|right)/i, type: 'move_direction' },
                { pattern: /(?:i\s+)?step\s+(north|south|east|west|up|down|left|right|forward|back|backward)/i, type: 'move_direction' }
            ];
            
            for (const { pattern, type } of movePatterns) {
                const match = playerAction.match(pattern);
                if (match) {
                    if (type === 'move_to') {
                        return handleMoveToTarget(match[1].trim());
                    } else if (type === 'move_direction') {
                        return handleMoveDirection(match[1].trim());
                    }
                }
            }
            
            return null; // No movement command detected
        }

        // Handle move to target
        function handleMoveToTarget(target) {
            // For multi-character parties, try to determine which character is moving
            const party = window.partyCharacters || [];
            let playerToken = null;
            
            if (party.length > 1) {
                // Check if any character name is mentioned in the command
                playerToken = Array.from(BATTLEMAP.tokens.values()).find(t => 
                    t.type === 'player' && 
                    party.some(char => char.name.toLowerCase() === t.name.toLowerCase())
                );
            }
            
            // Default to first player token if not specified
            if (!playerToken) {
                playerToken = Array.from(BATTLEMAP.tokens.values()).find(t => t.type === 'player');
            }
            if (!playerToken) {
                return "No player token found on the map.";
            }
            
            const targetLower = target.toLowerCase();
            
            // Find target token
            const targetToken = Array.from(BATTLEMAP.tokens.values()).find(t => 
                t.name.toLowerCase().includes(targetLower) || 
                targetLower.includes(t.name.toLowerCase())
            );
            
            if (targetToken) {
                // Calculate direction to move adjacent to target
                const deltaX = targetToken.x - playerToken.x;
                const deltaY = targetToken.y - playerToken.y;
                
                // Move one space toward the target
                let newX = playerToken.x;
                let newY = playerToken.y;
                
                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                    // Move horizontally first
                    newX = deltaX > 0 ? Math.min(playerToken.x + 1, BATTLEMAP.mapData.width - 1) : Math.max(playerToken.x - 1, 0);
                } else if (deltaY !== 0) {
                    // Move vertically
                    newY = deltaY > 0 ? Math.min(playerToken.y + 1, BATTLEMAP.mapData.height - 1) : Math.max(playerToken.y - 1, 0);
                }
                
                // If already adjacent, stay in place
                const distance = Math.abs(deltaX) + Math.abs(deltaY);
                if (distance <= 1) {
                    return `${playerToken.name} is already next to ${targetToken.name}.`;
                }
                
                moveToken(playerToken.name, newX, newY);
                const newDistance = Math.abs(targetToken.x - newX) + Math.abs(targetToken.y - newY);
                
                if (newDistance <= 1) {
                    return `üö∂ ${playerToken.name} moves adjacent to ${targetToken.name}.`;
                } else {
                    return `üö∂ ${playerToken.name} moves toward ${targetToken.name}.`;
                }
            }
            
            // Check for map features/buildings
            const feature = BATTLEMAP.mapData.features.find(f => 
                (f.name && f.name.toLowerCase().includes(targetLower)) ||
                targetLower.includes(f.type)
            );
            
            if (feature) {
                const featureX = feature.x + Math.floor((feature.width || 1) / 2);
                const featureY = feature.y + Math.floor((feature.height || 1) / 2);
                
                // Move toward the feature
                const deltaX = featureX - playerToken.x;
                const deltaY = featureY - playerToken.y;
                
                let newX = playerToken.x;
                let newY = playerToken.y;
                
                if (Math.abs(deltaX) > Math.abs(deltaY) && deltaX !== 0) {
                    newX = deltaX > 0 ? Math.min(playerToken.x + 1, BATTLEMAP.mapData.width - 1) : Math.max(playerToken.x - 1, 0);
                } else if (deltaY !== 0) {
                    newY = deltaY > 0 ? Math.min(playerToken.y + 1, BATTLEMAP.mapData.height - 1) : Math.max(playerToken.y - 1, 0);
                }
                
                moveToken(playerToken.name, newX, newY);
                return `üö∂ ${playerToken.name} moves toward the ${feature.name || feature.type}.`;
            }
            
            return `‚ùì Could not find "${target}" to move toward.`;
        }

        // Handle directional movement
        function handleMoveDirection(direction) {
            const playerToken = Array.from(BATTLEMAP.tokens.values()).find(t => t.type === 'player');
            if (!playerToken) {
                return "No player token found on the map.";
            }
            
            const oldX = playerToken.x;
            const oldY = playerToken.y;
            let newX = oldX;
            let newY = oldY;
            let directionName = direction.toLowerCase();
            
            switch(directionName) {
                case 'north': case 'up': 
                    newY = Math.max(0, newY - 1); 
                    directionName = 'north';
                    break;
                case 'south': case 'down': 
                    newY = Math.min(BATTLEMAP.mapData.height - 1, newY + 1); 
                    directionName = 'south';
                    break;
                case 'east': case 'right': 
                    newX = Math.min(BATTLEMAP.mapData.width - 1, newX + 1); 
                    directionName = 'east';
                    break;
                case 'west': case 'left': 
                    newX = Math.max(0, newX - 1); 
                    directionName = 'west';
                    break;
                case 'forward':
                    // Move north by default for forward
                    newY = Math.max(0, newY - 1);
                    directionName = 'forward (north)';
                    break;
                case 'back': case 'backward':
                    // Move south by default for back
                    newY = Math.min(BATTLEMAP.mapData.height - 1, newY + 1);
                    directionName = 'back (south)';
                    break;
                default:
                    return `‚ùì Unknown direction: ${direction}`;
            }
            
            // Check if movement actually happened (wasn't blocked by map edge)
            if (newX === oldX && newY === oldY) {
                return `üö´ ${playerToken.name} cannot move ${directionName} - reached map boundary.`;
            }
            
            moveToken(playerToken.name, newX, newY);
            return `üö∂ ${playerToken.name} moves ${directionName} to (${newX}, ${newY}).`;
        }

        // Enhanced DM personality and game state
        const DM_STATE = {
            combatActive: false,
            currentLocation: window.currentCampaign?.startingRegion || 'Millhaven village', // Track current scene location
            currentScene: 'social_interaction', // Track scene type
            npcsNearby: [], // Track active NPCs
            activeNPCs: new Map(), // Detailed NPC tracking with names and context
            recentEvents: [],
            conversationHistory: [], // Track recent conversation for continuity
            lastPlayerAction: '', // Remember what player just did
            tensionLevel: 1,
            reference: null // Will hold the DM reference data
        };

        // Load DM reference data
        async function loadDMReference() {
            try {
                const response = await fetch('dm-reference.json');
                if (response.ok) {
                    DM_STATE.reference = await response.json();
                    console.log('DM Reference loaded successfully');
                    return true;
                } else {
                    console.warn('DM Reference file not found, using default responses');
                    return false;
                }
            } catch (error) {
                console.warn('Could not load DM reference:', error);
                return false;
            }
        }

        // Initialize DM reference on page load
        loadDMReference();

        // ===============================
        // CONTEXT TRACKING SYSTEM
        // ===============================
        
        // Add NPC to current scene
        function addNPCToScene(name, description, personality = null) {
            DM_STATE.activeNPCs.set(name.toLowerCase(), {
                name: name,
                description: description,
                personality: personality,
                firstMet: Date.now(),
                lastInteraction: Date.now(),
                relationshipLevel: 'neutral',
                conversationTopics: []
            });
            
            if (!DM_STATE.npcsNearby.includes(name)) {
                DM_STATE.npcsNearby.push(name);
            }
        }

        // Update scene context
        function updateSceneContext(location, sceneType, description = '') {
            DM_STATE.currentLocation = location;
            DM_STATE.currentScene = sceneType;
            
            // Add to conversation history
            if (description) {
                addToConversationHistory('scene_change', description);
            }
        }

        // Add to conversation history for continuity
        function addToConversationHistory(type, content, speaker = null) {
            DM_STATE.conversationHistory.push({
                type: type, // 'player_action', 'dm_response', 'npc_dialogue', 'scene_change'
                content: content,
                speaker: speaker,
                timestamp: Date.now(),
                location: DM_STATE.currentLocation,
                npcsPresent: [...DM_STATE.npcsNearby]
            });
            
            // Keep only last 10 entries to avoid bloat
            if (DM_STATE.conversationHistory.length > 10) {
                DM_STATE.conversationHistory = DM_STATE.conversationHistory.slice(-10);
            }
        }

        // Get recent context for AI prompts
        function getRecentContext(maxEntries = 5) {
            return DM_STATE.conversationHistory
                .slice(-maxEntries)
                .map(entry => {
                    if (entry.type === 'player_action') {
                        return `Player: ${entry.content}`;
                    } else if (entry.type === 'dm_response') {
                        return `DM: ${entry.content}`;
                    } else if (entry.type === 'npc_dialogue') {
                        return `${entry.speaker}: ${entry.content}`;
                    } else if (entry.type === 'scene_change') {
                        return `Scene: ${entry.content}`;
                    }
                    return `${entry.type}: ${entry.content}`;
                }).join('\n');
        }

        // Check if player action should change scene
        function shouldChangeScene(playerAction) {
            const action = playerAction.toLowerCase();
            
            // Don't change scene if just talking to NPCs in current location
            if (action.includes('say') || action.includes('ask') || action.includes('tell') || 
                action.includes('talk') || action.includes('speak')) {
                return false;
            }
            
            // Only change scene if player explicitly moves or the action requires it
            if (action.includes('go to') || action.includes('leave') || action.includes('exit') ||
                action.includes('head to') || action.includes('travel')) {
                return true;
            }
            
            return false;
        }

        // Auto-detect NPCs mentioned in DM responses
        function detectAndTrackNPCs(dmResponse) {
            if (!dmResponse || typeof dmResponse !== 'string') {
                console.warn('Invalid DM response for NPC detection:', dmResponse);
                return;
            }
            
            try {
                // Look for common NPC introduction patterns
                const npcPatterns = [
                    /(?:a|an|the)\s+(\w+)\s+(?:dwarf|elf|human|halfling|orc|goblin|merchant|guard|innkeeper|bartender|knight|warrior|mage|wizard|priest|cleric)/gi,
                    /(?:named?|called)\s+([A-Z]\w+)/g,
                    /([A-Z]\w+)(?:\s+(?:the|a|an)\s+\w+)?\s+(?:says?|grumbles?|whispers?|shouts?|replies?)/g,
                    /"[^"]*"\s+(?:says?|grumbles?)\s+([A-Z]\w+)/g
                ];
                
                for (const pattern of npcPatterns) {
                    try {
                        const matches = [...dmResponse.matchAll(pattern)];
                        for (const match of matches) {
                            const npcName = match[1];
                            if (npcName && npcName.length > 2 && npcName !== 'What') { // Filter out common false positives
                                const description = extractNPCDescription(dmResponse, npcName);
                                addNPCToScene(npcName, description);
                                console.log(`Auto-detected NPC: ${npcName}`);
                            }
                        }
                    } catch (patternError) {
                        console.warn('Error processing NPC pattern:', pattern, patternError);
                    }
                }
            } catch (error) {
                console.error('Error in detectAndTrackNPCs:', error);
            }
        }

        // Extract NPC description from DM response
        function extractNPCDescription(text, npcName) {
            // Find sentences containing the NPC name and extract description
            const sentences = text.split(/[.!?]+/);
            for (const sentence of sentences) {
                if (sentence.includes(npcName)) {
                    // Look for descriptive words
                    if (sentence.includes('dwarf')) return 'dwarf';
                    if (sentence.includes('elf')) return 'elf';
                    if (sentence.includes('human')) return 'human';
                    if (sentence.includes('halfling')) return 'halfling';
                    if (sentence.includes('merchant')) return 'merchant';
                    if (sentence.includes('innkeeper')) return 'innkeeper';
                    if (sentence.includes('bartender')) return 'bartender';
                    if (sentence.includes('guard')) return 'guard';
                    if (sentence.includes('grizzled')) return 'grizzled warrior';
                    if (sentence.includes('burly')) return 'burly fighter';
                }
            }
            return 'person';
        }

        // Update scene context based on DM response and player action
        function updateSceneFromResponse(dmResponse, playerAction) {
            const action = playerAction.toLowerCase();
            const response = dmResponse.toLowerCase();
            
            // Don't change scene unless player action clearly indicates movement
            if (shouldChangeScene(playerAction)) {
                // Player wants to move - let the AI handle the scene change
                if (action.includes('fight') && !response.includes('tavern') && !response.includes('inn')) {
                    // Only if the response actually moved to combat
                    if (response.includes('forest') || response.includes('outside') || response.includes('goblins')) {
                        updateSceneContext('forest', 'combat', 'Moving to combat with goblins');
                        DM_STATE.combatActive = true;
                        DM_STATE.npcsNearby = []; // Clear NPCs when leaving location
                    }
                }
            }
            
            // Detect if we're still in the same location with NPCs
            if (response.includes('tavern') || response.includes('inn')) {
                DM_STATE.currentLocation = 'tavern';
                DM_STATE.currentScene = 'social_interaction';
            }
        }

        // ===============================
        // OPENAI INTEGRATION
        // ===============================
        
        // OpenAI configuration
        const openAIConfig = {
            enabled: false,
            apiKey: localStorage.getItem('openai_api_key') || '',
            model: localStorage.getItem('openai_model') || 'gpt-3.5-turbo',
            creativity: parseInt(localStorage.getItem('openai_creativity') || '70'),
            responseLength: localStorage.getItem('openai_response_length') || 'normal',
            useCampaignContext: localStorage.getItem('openai_use_context') !== 'false',
            useReferenceData: localStorage.getItem('openai_use_reference') !== 'false'
        };

        // Open AI DM Settings modal
        function openAIDMSettings() {
            const modal = document.getElementById('ai-dm-settings-modal');
            
            // Load current settings
            const engineRadios = document.querySelectorAll('input[name="aiEngine"]');
            engineRadios.forEach(radio => {
                radio.checked = radio.value === (openAIConfig.enabled ? 'openai' : 'templates');
            });
            
            // Set form values
            document.getElementById('openai-api-key').value = openAIConfig.apiKey;
            document.getElementById('openai-model').value = openAIConfig.model;
            document.getElementById('ai-creativity').value = openAIConfig.creativity;
            document.getElementById('ai-creativity-display').textContent = openAIConfig.creativity + '%';
            document.getElementById('ai-response-length').value = openAIConfig.responseLength;
            document.getElementById('ai-use-campaign-context').checked = openAIConfig.useCampaignContext;
            document.getElementById('ai-use-reference-data').checked = openAIConfig.useReferenceData;
            
            // Toggle OpenAI settings visibility
            const openaiRadio = document.querySelector('input[value="openai"]:checked');
            const openaiSettings = document.getElementById('openai-settings');
            if (openaiSettings) {
                openaiSettings.style.display = openaiRadio ? 'block' : 'none';
            }
            
            // Show modal
            modal.style.display = 'flex';
        }

        // Toggle OpenAI settings visibility
        function toggleOpenAISettings() {
            const openaiRadio = document.querySelector('input[value="openai"]:checked');
            const openaiSettings = document.getElementById('openai-settings');
            
            if (openaiRadio) {
                openaiSettings.style.display = 'block';
            } else {
                openaiSettings.style.display = 'none';
            }
        }

        // Save AI DM Settings
        function saveAIDMSettings() {
            const engineRadio = document.querySelector('input[name="aiEngine"]:checked');
            openAIConfig.enabled = engineRadio.value === 'openai';
            
            if (openAIConfig.enabled) {
                openAIConfig.apiKey = document.getElementById('openai-api-key').value;
                openAIConfig.model = document.getElementById('openai-model').value;
                openAIConfig.creativity = parseInt(document.getElementById('ai-creativity').value);
                openAIConfig.responseLength = document.getElementById('ai-response-length').value;
                openAIConfig.useCampaignContext = document.getElementById('ai-use-campaign-context').checked;
                openAIConfig.useReferenceData = document.getElementById('ai-use-reference-data').checked;
                
                // Save to localStorage
                localStorage.setItem('openai_enabled', 'true');
                localStorage.setItem('openai_api_key', openAIConfig.apiKey);
                localStorage.setItem('openai_model', openAIConfig.model);
                localStorage.setItem('openai_creativity', openAIConfig.creativity);
                localStorage.setItem('openai_response_length', openAIConfig.responseLength);
                localStorage.setItem('openai_use_context', openAIConfig.useCampaignContext);
                localStorage.setItem('openai_use_reference', openAIConfig.useReferenceData);
            } else {
                localStorage.setItem('openai_enabled', 'false');
            }
            
            // Close modal
            document.getElementById('ai-dm-settings-modal').style.display = 'none';
            
            alert('AI DM settings saved!');
        }

        // Test OpenAI connection
        async function testOpenAIConnection() {
            const apiKey = document.getElementById('openai-api-key').value;
            const resultDiv = document.getElementById('openai-test-result');
            
            if (!apiKey) {
                resultDiv.innerHTML = '<span style="color: red;">Please enter an API key</span>';
                return;
            }
            
            resultDiv.innerHTML = '<span style="color: yellow;">Testing connection...</span>';
            
            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gpt-3.5-turbo',
                        messages: [
                            {
                                role: 'system',
                                content: 'You are a helpful assistant. Respond with: "Connection successful!"'
                            },
                            {
                                role: 'user',
                                content: 'Test'
                            }
                        ],
                        max_tokens: 10
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    resultDiv.innerHTML = '<span style="color: green;">‚úÖ Connection successful! API key is valid.</span>';
                } else {
                    const error = await response.json();
                    resultDiv.innerHTML = `<span style="color: red;">‚ùå Error: ${error.error?.message || 'Invalid API key'}</span>`;
                }
            } catch (error) {
                resultDiv.innerHTML = `<span style="color: red;">‚ùå Connection failed: ${error.message}</span>`;
            }
        }

        // Generate DM response using OpenAI
        async function generateOpenAIDMResponse(playerAction, context = {}) {
            if (!openAIConfig.apiKey) {
                console.warn('OpenAI API key not configured');
                return null;
            }
            
            // Track this player action
            addToConversationHistory('player_action', playerAction);
            DM_STATE.lastPlayerAction = playerAction;
            
            // Build the system prompt with enhanced context
            let systemPrompt = `You are an expert Dungeons & Dragons 5e Dungeon Master running an ongoing campaign. 

CRITICAL CONTEXT RULES:
- Current Location: ${DM_STATE.currentLocation} - DO NOT CHANGE LOCATIONS unless player explicitly moves
- Current Scenario: ${window.currentCampaign?.startingScenario || 'adventure'} 
- You have the FULL conversation history - use it to maintain perfect continuity
- NEVER ignore what was just said or change topics abruptly  
- If the scene is about goblin raids on Millhaven village, EVERYTHING happens in that context
- If a player looks for a stick, they find it IN THE CURRENT LOCATION (not a random tavern!)
- ALWAYS acknowledge and respond to the player's EXACT action IN THE CURRENT CONTEXT
- Build on the immediately previous exchange - don't jump to new scenarios
- The very first message established the setting - RESPECT IT`;
            
            // Add combat detection and rules
            systemPrompt += `
COMBAT INITIATION RULES:
- Recognize when combat should start based on context:
  * Player says they attack something
  * Hostile creature appears and is aggressive
  * NPCs become hostile due to failed diplomacy
  * Ambush or surprise attack occurs
  * Player provokes combat through aggressive actions
- When combat should start, say "Roll for initiative!" or similar
- Describe the combat situation and enemies present
- DO NOT run combat without initiative being rolled first

            `;
            
            // Add combat rules enforcement if already in combat
            if (combatState.active) {
                systemPrompt += ` COMBAT RULES ENFORCEMENT: The party is currently in combat. Each character gets ONE action, ONE bonus action (if applicable), and movement per turn. Players cannot attack multiple times or take multiple actions unless they have specific abilities that allow it. If a player tries to do more than their action economy allows, remind them of the rules and ask them to choose one action. Track initiative order and ensure proper turn-based combat. `;
                systemPrompt += ` Current turn: ${combatState.combatants[combatState.currentTurn]?.name || 'Unknown'}. Round: ${combatState.round}. `;
            }
            
            // If waiting for initiative
            if (DM_STATE.waitingForInitiative) {
                systemPrompt += ` WAITING FOR INITIATIVE: Players need to roll initiative. Don't proceed with combat actions until initiative is established. `;
            }
            
            // Add current scene context
            systemPrompt += ` Current location: ${DM_STATE.currentLocation}. `;
            systemPrompt += ` Scene type: ${DM_STATE.currentScene}. `;
            
            // Add active NPCs if any
            if (DM_STATE.npcsNearby.length > 0) {
                systemPrompt += `NPCs present: ${DM_STATE.npcsNearby.join(', ')}. `;
                
                // Add detailed NPC info
                const npcDetails = [];
                for (const npcName of DM_STATE.npcsNearby) {
                    const npc = DM_STATE.activeNPCs.get(npcName.toLowerCase());
                    if (npc) {
                        npcDetails.push(`${npc.name} (${npc.description})`);
                    }
                }
                if (npcDetails.length > 0) {
                    systemPrompt += `NPC details: ${npcDetails.join('; ')}. `;
                }
            }
            
            // Add campaign context if enabled
            if (openAIConfig.useCampaignContext && window.currentCampaign) {
                const campaign = window.currentCampaign;
                systemPrompt += `Campaign: ${campaign.scenario || 'fantasy'}. `;
                systemPrompt += `Tone: ${campaign.tone || 'balanced'}. `;
                systemPrompt += `Party: ${window.partyCharacters?.length || 1} adventurers. `;
            }
            
            // Add reference data context if enabled
            if (openAIConfig.useReferenceData && DM_STATE.reference) {
                systemPrompt += `You have access to D&D 5e rules, monsters, items, and encounters. `;
            }
            
            // Add story state
            if (STORY_STATE.plotThreads.length > 0) {
                systemPrompt += `Active plot: ${STORY_STATE.plotThreads[0].description}. `;
            }
            
            // Response length guidelines
            const lengthGuides = {
                brief: 'Keep responses to 1-2 sentences.',
                normal: 'Keep responses to 2-4 sentences.',
                detailed: 'Provide detailed responses of 4-6 sentences.',
                verbose: 'Give rich, descriptive responses of 6+ sentences.'
            };
            systemPrompt += lengthGuides[openAIConfig.responseLength];
            
            systemPrompt += ` 
ENDING YOUR RESPONSES - CRITICAL RULES:
- DO NOT ask "What do you do?" or similar UNLESS the situation is genuinely ambiguous
- Most of the time, just END with the scene description or NPC dialogue
- Let the scene breathe - players know it's their turn without being asked
- Only prompt for action if: 
  * Multiple urgent choices present themselves simultaneously
  * A critical decision point with unclear options
  * The party seems genuinely stuck
- Good endings: Scene descriptions, NPC dialogue trailing off, environmental details, sounds, smells
- Bad endings: "What do you do?", "What's your choice?", "How do you proceed?" (avoid these!)
- Remember: This is collaborative storytelling - players will act when ready`;
            
            // Build proper conversation messages for OpenAI with full context
            const messages = [{ role: 'system', content: systemPrompt }];
            
            // Add recent conversation history as alternating user/assistant messages
            const recentHistory = DM_STATE.conversationHistory.slice(-8); // Last 8 exchanges
            
            for (const entry of recentHistory) {
                if (entry.type === 'player_action') {
                    messages.push({ role: 'user', content: entry.content });
                } else if (entry.type === 'dm_response') {
                    messages.push({ role: 'assistant', content: entry.content });
                }
                // Skip other entry types to maintain clean conversation flow
            }
            
            // Add the current player action as the final user message
            messages.push({ role: 'user', content: playerAction });
            
            console.log('üß† Sending to AI with proper conversation context:', messages.length - 1, 'history messages');
            console.log('üìñ Full message thread:', messages.map(m => `${m.role}: ${m.content.substring(0, 100)}...`));
            
            try {
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${openAIConfig.apiKey}`
                    },
                    body: JSON.stringify({
                        model: openAIConfig.model,
                        messages: messages,
                        temperature: openAIConfig.creativity / 100, // Convert to 0-1 scale
                        max_tokens: 300 // Increased for better responses
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    const dmResponse = data.choices[0].message.content;
                    
                    // Track the DM response for continuity
                    addToConversationHistory('dm_response', dmResponse);
                    
                    console.log('‚úÖ AI Response received and logged:', dmResponse.substring(0, 100) + '...');
                    console.log('üìä Conversation history now has', DM_STATE.conversationHistory.length, 'entries');
                    
                    // Auto-detect and track NPCs mentioned in the response
                    detectAndTrackNPCs(dmResponse);
                    
                    // Update scene context if needed
                    updateSceneFromResponse(dmResponse, playerAction);
                    
                    // Check if combat should be initiated based on DM response
                    checkForCombatInitiation(dmResponse, playerAction);
                    
                    // Update battlemap based on story
                    updateMapFromStory(DM_STATE.currentLocation, dmResponse);
                    
                    return {
                        response: dmResponse,
                        voice: dmResponse,
                        source: 'openai'
                    };
                } else {
                    console.error('OpenAI API error:', await response.text());
                    return null;
                }
            } catch (error) {
                console.error('Failed to generate OpenAI response:', error);
                return null;
            }
        }

        // Get a random encounter based on location and difficulty
        function getRandomEncounter(location = 'forest', difficulty = 'easy') {
            if (!DM_STATE.reference?.encounter_tables) return null;
            
            const encounters = DM_STATE.reference.encounter_tables[location]?.[difficulty];
            if (!encounters) return null;
            
            return encounters[Math.floor(Math.random() * encounters.length)];
        }

        // Generate a random NPC with personality
        function generateNPC() {
            if (!DM_STATE.reference?.npc_generation) return null;
            
            const npc = DM_STATE.reference.npc_generation;
            return {
                personality: npc.personalities[Math.floor(Math.random() * npc.personalities.length)],
                motivation: npc.motivations[Math.floor(Math.random() * npc.motivations.length)],
                quirk: npc.quirks[Math.floor(Math.random() * npc.quirks.length)]
            };
        }

        // Get monster stats
        function getMonsterStats(monsterName) {
            if (!DM_STATE.reference?.monsters) return null;
            
            // Search through all CR categories
            for (const crCategory of Object.values(DM_STATE.reference.monsters)) {
                if (crCategory[monsterName]) {
                    return crCategory[monsterName];
                }
            }
            return null;
        }

        // Determine skill check DC based on difficulty
        function getSkillCheckDC(difficulty = 'medium') {
            if (!DM_STATE.reference?.skill_checks?.dc_guidelines) {
                // Fallback DCs if reference not loaded
                const fallbackDCs = {
                    very_easy: 5,
                    easy: 10,
                    medium: 15,
                    hard: 20,
                    very_hard: 25
                };
                return fallbackDCs[difficulty] || 15;
            }
            
            return DM_STATE.reference.skill_checks.dc_guidelines[difficulty] || 15;
        }

        // ===============================
        // DYNAMIC STORY GENERATION SYSTEM
        // ===============================
        
        // Story state tracking
        const STORY_STATE = {
            currentChapter: 'opening',
            plotThreads: [],
            activeQuests: [],
            completedEvents: [],
            worldState: {},
            narrativeTension: 1,
            storyBeats: []
        };

        // Generate dynamic story hooks based on context
        function generateStoryHook() {
            const hooks = [
                {
                    type: 'mystery',
                    hooks: [
                        "Strange disappearances have plagued the nearby village - livestock vanishing without a trace, and now people...",
                        "An ancient map was discovered in the wall of the old tavern during renovations, marking a location that shouldn't exist...",
                        "Every full moon, ghostly music echoes from the abandoned manor on the hill. Last night wasn't a full moon..."
                    ]
                },
                {
                    type: 'danger',
                    hooks: [
                        "Smoke rises on the horizon - the peaceful hamlet you were heading to appears to be under attack!",
                        "A blood-curdling scream pierces the night, followed by an unnatural silence that sets your teeth on edge...",
                        "The bridge ahead has been destroyed, and fresh tracks suggest it wasn't an accident. Someone doesn't want you to cross..."
                    ]
                },
                {
                    type: 'opportunity',
                    hooks: [
                        "A wealthy merchant's caravan lies overturned beside the road, goods scattered but no bodies in sight...",
                        "You stumble upon a hidden entrance behind a waterfall, ancient runes glowing faintly around its edges...",
                        "A dying knight presses a sealed letter into your hands, gasping 'The king... must not... know...' before expiring..."
                    ]
                },
                {
                    type: 'social',
                    hooks: [
                        "Two rival factions approach your group simultaneously, each demanding you choose a side in their conflict...",
                        "A mysterious figure in fine robes has been asking about you by name in every tavern in town...",
                        "The local lord has heard of your exploits and 'requests' your presence at court immediately..."
                    ]
                }
            ];
            
            const selectedType = hooks[Math.floor(Math.random() * hooks.length)];
            const selectedHook = selectedType.hooks[Math.floor(Math.random() * selectedType.hooks.length)];
            
            return {
                type: selectedType.type,
                description: selectedHook
            };
        }

        // Create opening narration based on campaign scenario
        function startAdventureNarration() {
            const campaign = window.currentCampaign || {};
            const scenario = campaign.scenario || 'forgotten_realms';
            const party = window.partyCharacters || [];
            
            // Build personalized opening based on scenario
            let opening = "";
            let voiceOpening = "";
            
            // Scenario-specific openings
            const scenarioOpenings = {
                forgotten_realms: {
                    text: "The sun rises over the Sword Coast as your party gathers at the crossroads outside Waterdeep. The morning mist clings to the cobblestones, and merchants are already hawking their wares.",
                    voice: "Welcome, brave adventurers, to the Forgotten Realms! The sun rises over the Sword Coast as your party gathers at the crossroads outside Waterdeep. The morning mist clings to the ancient cobblestones, and merchants are already hawking their wares. The city of splendors awaits, but your destiny lies elsewhere..."
                },
                ravenloft: {
                    text: "The mists part reluctantly, revealing a land shrouded in perpetual twilight. Barovia stretches before you, a realm where hope itself seems a distant memory.",
                    voice: "Welcome... to Barovia. The mists have chosen you, though whether for salvation or damnation remains to be seen. The land itself watches your every move, and somewhere in the distance, a wolf howls - or was it something worse? You stand at the gates of a realm where nightmares walk freely..."
                },
                eberron: {
                    text: "The lightning rail hisses to a stop at Sharn Station. The City of Towers stretches impossibly high above and deep below, magical lights dancing between the spires.",
                    voice: "Welcome to Eberron, where magic and technology intertwine! The lightning rail hisses to a stop at Sharn Station. The City of Towers stretches impossibly high above you and deep below, with bridges of magical force connecting the massive spires. Adventure awaits in every shadow of this city of wonders!"
                },
                spelljammer: {
                    text: "Your spelljamming vessel drifts through the phlogiston, the rainbow-colored chaotic matter swirling outside the crystal sphere. A new world awaits.",
                    voice: "Greetings, spacefarers! Your spelljamming vessel glides through the rainbow chaos of the phlogiston. The helm thrums with magical energy beneath your feet, and through the viewport, you can see a new crystal sphere approaching. What wonders and terrors await in this uncharted realm of wildspace?"
                },
                custom: {
                    text: "Your adventure begins at a crossroads, both literal and metaphorical. The path ahead promises danger, glory, and discoveries beyond imagination.",
                    voice: "Welcome, heroes, to a world of infinite possibilities! Your journey begins here, at this fateful moment when ordinary lives transform into legend. The very air seems to thrum with potential. What tale will you write in the annals of history?"
                }
            };
            
            const selectedOpening = scenarioOpenings[scenario] || scenarioOpenings.custom;
            opening = selectedOpening.text;
            voiceOpening = selectedOpening.voice;
            
            // Add a story hook
            const hook = generateStoryHook();
            opening += ` ${hook.description}`;
            voiceOpening += ` ${hook.description}`;
            
            // Add party-specific flavor
            if (party.length > 0) {
                const partySize = party.length === 1 ? "alone" : `as a party of ${party.length}`;
                const partyClasses = party.map(c => c.class).join(", ");
                opening += ` You stand ${partySize}, ready to face whatever comes.`;
                voiceOpening += ` You stand ${partySize} - ${partyClasses} - ready to face whatever destiny awaits.`;
            } else {
                opening += " The adventure begins.";
                voiceOpening += " Your journey begins here.";
            }
            
            // Display the opening narration
            const openingMessage = `
                <div class="dm-message voice-message opening-narration">
                    <div class="message-header">
                        <strong>üé≠ Dungeon Master</strong>
                        <span class="voice-indicator-small">üîä</span>
                        <span class="timestamp">${new Date().toLocaleTimeString()}</span>
                    </div>
                    <div class="message-content">
                        <p class="opening-text">${opening}</p>
                        <p class="dm-prompt"><em>What do you do?</em></p>
                    </div>
                </div>
            `;
            
            appendToConversation(openingMessage);
            
            // Store the hook in story state
            STORY_STATE.plotThreads.push(hook);
            STORY_STATE.currentChapter = 'adventure_start';
            
            // Initialize the starting scene context
            DM_STATE.currentLocation = 'village';
            DM_STATE.currentScene = 'quest_start';
            
            // Speak the opening
            setTimeout(() => {
                speakAsDM(voiceOpening);
            }, 500);
        }

        // Generate dynamic story developments based on player actions
        function generateStoryDevelopment(playerAction, context = {}) {
            const action = playerAction.toLowerCase();
            const currentTension = STORY_STATE.narrativeTension;
            
            // Check if action relates to existing plot threads
            const relevantThread = STORY_STATE.plotThreads.find(thread => 
                action.includes(thread.type) || 
                thread.keywords?.some(keyword => action.includes(keyword))
            );
            
            // Generate consequences that build on previous events
            if (STORY_STATE.completedEvents.length > 0) {
                const lastEvent = STORY_STATE.completedEvents[STORY_STATE.completedEvents.length - 1];
                
                // Create callbacks to previous events
                if (Math.random() < 0.3) { // 30% chance of callback
                    return {
                        text: `Your actions remind you of ${lastEvent.description}. The consequences of that choice echo here...`,
                        voice: `Interesting... your current choice mirrors what happened when ${lastEvent.description}. The threads of fate are weaving together. How will you handle it differently this time?`,
                        continuity: true
                    };
                }
            }
            
            // Escalate tension naturally
            if (currentTension < 5 && Math.random() < 0.4) {
                STORY_STATE.narrativeTension++;
                return generateComplication();
            }
            
            // Resolution opportunities at high tension
            if (currentTension >= 7 && Math.random() < 0.5) {
                return generateClimax();
            }
            
            // Default to contextual development
            return generateContextualDevelopment(playerAction, context);
        }

        // Generate complications to raise stakes
        function generateComplication() {
            const complications = [
                {
                    text: "Suddenly, things take an unexpected turn! A new threat emerges from an unforeseen direction.",
                    voice: "Wait! Something's not right here. You notice movement in the shadows - you're not alone! This just became much more dangerous. How do you respond to this new threat?"
                },
                {
                    text: "Your action has unintended consequences! The situation grows more complex.",
                    voice: "Oh, this is interesting! Your action has triggered something unexpected. The simple task has become a web of complications. What started as straightforward is now anything but! What's your next move?"
                },
                {
                    text: "A moral dilemma presents itself - the right choice is no longer clear.",
                    voice: "Hold on... this situation is more complex than it appeared. You're faced with a choice where any action could have serious consequences for innocent people. There's no perfect solution here. What will you prioritize?"
                }
            ];
            
            return complications[Math.floor(Math.random() * complications.length)];
        }

        // Generate climactic moments
        function generateClimax() {
            const climaxes = [
                {
                    text: "This is it - the moment of truth! Everything has led to this critical juncture.",
                    voice: "THIS IS IT! The moment of truth has arrived! Everything you've done has led to this crucial moment. The fate of everyone involved hangs in the balance. This is your chance to be heroes!"
                },
                {
                    text: "The tension reaches its breaking point! The situation demands immediate decisive action.",
                    voice: "The tension snaps like a bowstring! No more time for deliberation - the moment demands action NOW! Success or failure, glory or disaster, it all comes down to this. Make your choice!"
                }
            ];
            
            STORY_STATE.narrativeTension = Math.max(1, STORY_STATE.narrativeTension - 3); // Reset tension after climax
            return climaxes[Math.floor(Math.random() * climaxes.length)];
        }

        // Generate contextual story based on action type
        function generateContextualDevelopment(playerAction, context) {
            // This will evolve the story based on what the player does
            const developments = {
                explore: [
                    "Your exploration reveals more than expected - the plot thickens!",
                    "As you investigate, you uncover clues that connect to earlier events.",
                    "Your discovery opens new possibilities and raises new questions."
                ],
                combat: [
                    "The battle reveals the true stakes - this is bigger than you thought!",
                    "Victory brings new information, but also new enemies.",
                    "The fight changes everything - alliances shift and secrets are revealed."
                ],
                social: [
                    "Your words have more impact than expected - relationships permanently change.",
                    "The conversation reveals hidden motivations and secret alliances.",
                    "Your diplomatic approach opens unexpected doors - or closes them forever."
                ],
                puzzle: [
                    "Solving this reveals a piece of a larger mystery.",
                    "The solution brings knowledge, but knowledge can be dangerous.",
                    "Your success here cascades into new opportunities elsewhere."
                ]
            };
            
            // Determine action category
            let category = 'explore'; // default
            if (playerAction.includes('attack') || playerAction.includes('fight')) category = 'combat';
            if (playerAction.includes('talk') || playerAction.includes('persuade')) category = 'social';
            if (playerAction.includes('solve') || playerAction.includes('figure')) category = 'puzzle';
            
            const options = developments[category];
            const selected = options[Math.floor(Math.random() * options.length)];
            
            // Add it to story beats
            STORY_STATE.storyBeats.push({
                action: playerAction,
                development: selected,
                timestamp: Date.now()
            });
            
            return {
                text: selected,
                voice: `${selected}`,
                category: category
            };
        }

        // Generate voice-enabled DM response with real DM personality
        async function generateVoiceDMResponse(playerAction) {
            const action = playerAction.toLowerCase();
            const campaign = window.currentCampaign || {};
            
            // Try OpenAI first if enabled and configured
            if (openAIConfig.enabled && openAIConfig.apiKey) {
                try {
                    updateVoiceStatus('AI DM thinking...', 'processing');
                    const aiResponse = await generateOpenAIDMResponse(playerAction);
                    if (aiResponse) {
                        // Add story development tracking
                        if (Math.random() < 0.3) { // 30% chance to add story development
                            const storyDev = generateStoryDevelopment(playerAction);
                            if (storyDev) {
                                STORY_STATE.completedEvents.push({
                                    action: playerAction,
                                    development: storyDev.text,
                                    timestamp: Date.now()
                                });
                            }
                        }
                        
                        displayDMResponse(aiResponse.response, aiResponse.voice);
                        updateVoiceStatus('Ready to listen', 'ready');
                        return;
                    }
                } catch (error) {
                    console.error('OpenAI generation failed, falling back to templates:', error);
                    updateVoiceStatus('AI failed, using templates...', 'processing');
                }
            }
            
            // Combat responses - much more engaging
            if (action.includes('attack') || action.includes('fight') || action.includes('combat') || action.includes('hit') || action.includes('strike')) {
                const combatResponses = [
                    {
                        response: "Your blade flashes in the light as you move to strike! Roll for initiative - we're entering combat! What's your target?",
                        voice: "Steel rings as weapons are drawn! Roll for initiative everyone! Who or what are you attacking, and describe your approach!",
                        requiresDMRoll: true,
                        rollType: 'initiative'
                    },
                    {
                        response: "Violence erupts! The air crackles with tension as battle is joined! Everyone roll initiative!",
                        voice: "The peaceful moment shatters into chaos! Weapons drawn, spells at the ready - roll for initiative! Describe your opening move!",
                        requiresDMRoll: true,
                        rollType: 'initiative'
                    },
                    {
                        response: "Your hostile intent is clear! Combat begins - roll initiative and tell me your first action!",
                        voice: "Battle is joined! The clash of combat echoes through the area! Roll initiative and tell me - how does your character react in this critical moment?",
                        requiresDMRoll: true,
                        rollType: 'initiative'
                    }
                ];
                DM_STATE.combatActive = true;
                return combatResponses[Math.floor(Math.random() * combatResponses.length)];
            }
            
            // Investigation/Perception - more descriptive
            if (action.includes('look') || action.includes('search') || action.includes('investigate') || action.includes('examine') || action.includes('inspect')) {
                const investigateResponses = [
                    {
                        response: "Your trained eye scans the area methodically. Roll Investigation or Perception - d20 plus your modifier!",
                        voice: "You focus intently, your senses sharpening as you examine every detail. Roll an Investigation or Perception check - what specifically draws your attention?",
                        requiresDMRoll: true,
                        rollType: 'perception'
                    },
                    {
                        response: "Something about this place feels... different. Make an Investigation check to see what you discover!",
                        voice: "The hairs on your neck stand up - something here deserves closer inspection. Roll Investigation and tell me where you're focusing your search!",
                        requiresDMRoll: true,
                        rollType: 'investigation'
                    },
                    {
                        response: "You take a moment to carefully observe your surroundings. Roll Perception and add your Wisdom modifier!",
                        voice: "Time seems to slow as you take in every detail around you. Roll a Perception check - are you looking for danger, treasure, or something else?",
                        requiresDMRoll: true,
                        rollType: 'perception'
                    }
                ];
                return investigateResponses[Math.floor(Math.random() * investigateResponses.length)];
            }
            
            // Social interactions - more nuanced
            if (action.includes('talk') || action.includes('speak') || action.includes('say') || action.includes('ask') || action.includes('tell')) {
                const socialResponses = [
                    {
                        response: "The figure turns to face you, eyebrow raised. Your words will matter here - make a Persuasion, Deception, or Intimidation check!",
                        voice: "The figure's full attention locks onto you, weighing every word. How are you approaching this - with honeyed words, clever lies, or implied threats? Roll the appropriate Charisma check!",
                        requiresDMRoll: true,
                        rollType: 'charisma'
                    },
                    {
                        response: "Your voice cuts through the tension. The NPC's reaction depends on your approach - roll a Charisma-based skill check!",
                        voice: "Your words hang heavy in the air between you. I can see the gears turning in their mind. Are you being persuasive, deceptive, or intimidating? Make your roll and tell me your exact words!",
                        requiresDMRoll: true,
                        rollType: 'charisma'
                    }
                ];
                return socialResponses[Math.floor(Math.random() * socialResponses.length)];
            }
            
            // Movement and exploration - more atmospheric
            if (action.includes('go') || action.includes('move') || action.includes('walk') || action.includes('enter') || action.includes('leave')) {
                const moveResponses = [
                    {
                        response: "You move forward, each step taking you deeper into the unknown. The atmosphere shifts noticeably...",
                        voice: "Your footsteps echo as you advance. The air grows thick with possibility. Are you moving cautiously or boldly? And keep your eyes open - this place holds secrets!",
                        requiresDMRoll: false
                    },
                    {
                        response: "The path ahead beckons. As you progress, new details emerge from the shadows. Roll Perception to see what you notice!",
                        voice: "You press onward, the environment changing subtly around you. Roll a Perception check as you move - something here might be worth your attention. How quickly are you traveling?",
                        requiresDMRoll: true,
                        rollType: 'perception'
                    }
                ];
                return moveResponses[Math.floor(Math.random() * moveResponses.length)];
            }
            
            // Stealth actions - tension building
            if (action.includes('sneak') || action.includes('hide') || action.includes('stealth') || action.includes('quiet')) {
                return {
                    response: "You become one with the shadows, moving like a ghost. Roll Stealth - d20 plus Dexterity modifier!",
                    voice: "Silent as death itself, you slip into concealment. Your heart pounds but your movements are smooth. Roll a Stealth check and tell me - what are you trying to avoid being noticed by?",
                    requiresDMRoll: true,
                    rollType: 'stealth'
                };
            }
            
            // Spellcasting - magical flair
            if (action.includes('cast') || action.includes('spell') || action.includes('magic') || action.includes('cantrip')) {
                return {
                    response: "Arcane energy crackles around your fingers as you begin the incantation! What spell are you casting?",
                    voice: "The Weave responds to your call! Mystical energy swirls around you as reality bends to your will! What spell are you casting, at what level, and who or what is your target? Describe the casting!",
                    requiresDMRoll: false,
                    spellcasting: true
                };
            }
            
            // Skill checks and abilities
            if (action.includes('climb') || action.includes('jump') || action.includes('swim') || action.includes('lift')) {
                return {
                    response: "Your muscles tense as you attempt this physical feat. Roll Athletics - d20 plus Strength modifier!",
                    voice: "Time to test your physical prowess! Your body coils like a spring ready to release. Roll an Athletics check and describe your technique - are you going for power or finesse?",
                    requiresDMRoll: true,
                    rollType: 'athletics'
                };
            }
            
            // Rest and recovery
            if (action.includes('rest') || action.includes('sleep') || action.includes('camp')) {
                return {
                    response: "You find a suitable spot to rest. Are you taking a short rest (1 hour) or a long rest (8 hours)? Roll Perception to ensure the area is safe!",
                    voice: "Exhaustion weighs on you, and rest is needed. You scout for a defensible position. Will this be a short rest to catch your breath, or a long rest to fully recover? Roll Perception to check for danger while you rest!",
                    requiresDMRoll: true,
                    rollType: 'perception'
                };
            }
            
            // Default responses - still engaging
            const defaultResponses = [
                {
                    response: "That's an interesting approach! The world responds to your actions in unexpected ways. Tell me more about what you're trying to accomplish.",
                    voice: "Now that's thinking outside the box! Your action sets events in motion that even I didn't anticipate. Give me more details about your plan - what's your end goal here?",
                    requiresDMRoll: Math.random() < 0.4
                },
                {
                    response: "Your choice ripples through the scene like a stone in still water. Something is about to happen...",
                    voice: "Bold move! The consequences of your action are already beginning to manifest. The tension in the air is palpable. What are you prepared to do if this goes sideways?",
                    requiresDMRoll: Math.random() < 0.5
                },
                {
                    response: "The dice of fate are rolling behind the cosmic screen! Your action triggers a chain of events...",
                    voice: "Ah, the plot thickens! Your decision opens new possibilities I hadn't considered. The story takes an interesting turn here. How committed are you to this course of action?",
                    requiresDMRoll: Math.random() < 0.3
                }
            ];
            
            const selected = defaultResponses[Math.floor(Math.random() * defaultResponses.length)];
            
            // Add campaign flavor
            if (campaign.scenario === 'ravenloft' && Math.random() < 0.3) {
                selected.response += " The mists seem to thicken around you...";
                selected.voice += " And I should mention - the dark mists of Barovia seem to be taking notice of your actions...";
            } else if (campaign.scenario === 'spelljammer' && Math.random() < 0.3) {
                selected.response += " The stars above seem to shift slightly...";
                selected.voice += " The cosmic void around your ship seems to pulse with energy...";
            }
            
            // Incorporate dynamic story development
            const storyDev = generateStoryDevelopment(playerAction);
            if (storyDev && Math.random() < 0.6) { // 60% chance to add story development
                selected.response += ` ${storyDev.text}`;
                selected.voice += ` ${storyDev.voice}`;
            }
            
            // Handle dice rolls
            if (selected.requiresDMRoll) {
                handleDMDiceRoll(selected, playerAction);
            } else {
                displayDMResponse(selected.response, selected.voice);
            }
        }
        
        // Handle DM dice rolling
        function handleDMDiceRoll(responseObj, playerAction) {
            const rollTypes = {
                investigation: { die: 20, modifier: 0, description: "Investigation check" },
                initiative: { die: 20, modifier: 2, description: "Initiative roll" },
                persuasion: { die: 20, modifier: 1, description: "Reaction roll" },
                random: { die: 20, modifier: 0, description: "Outcome roll" }
            };
            
            const rollType = rollTypes[responseObj.rollType] || rollTypes.random;
            const roll = Math.floor(Math.random() * rollType.die) + 1;
            const total = roll + rollType.modifier;
            
            // Display the initial response
            displayDMResponse(responseObj.response, responseObj.voice);
            
            // Add DM dice roll after a delay
            setTimeout(() => {
                const rollMessage = `
                    <div class="dm-roll">
                        <div class="message-header">
                            <strong>üé≤ DM Roll</strong>
                            <span class="timestamp">${new Date().toLocaleTimeString()}</span>
                        </div>
                        <div class="message-content">
                            <p><strong>${rollType.description}:</strong> d${rollType.die} + ${rollType.modifier} = <span class="roll-result">${total}</span> (rolled ${roll})</p>
                        </div>
                    </div>
                `;
                
                appendToConversation(rollMessage);
                
                // Generate follow-up response based on roll result
                setTimeout(() => {
                    generateRollBasedResponse(rollType.description, total, playerAction);
                }, 1500);
                
            }, 2000);
        }
        
        // Generate response based on DM dice roll result with proper D&D flair
        function generateRollBasedResponse(rollDescription, total, originalAction) {
            let followupResponse = "";
            let followupVoice = "";
            const rollType = rollDescription.toLowerCase();
            
            // Natural 20 - Critical Success!
            if (total === 20 || total >= 25) {
                const criticalSuccesses = [
                    {
                        response: "NATURAL 20! Critical Success! The dice gods smile upon you! Your action succeeds spectacularly, creating an opportunity for advantage!",
                        voice: "NATURAL TWENTY! Critical success! The fates themselves conspire in your favor! Not only does your action succeed brilliantly, but you've created an opening for something more! Describe your moment of triumph!"
                    },
                    {
                        response: "CRIT! Legendary success! Your action succeeds so well that it becomes the stuff of tavern tales!",
                        voice: "CRITICAL HIT on the skill check! This is the kind of moment bards write songs about! Your success is so complete it changes the situation entirely in your favor! How does your character celebrate this incredible moment?"
                    }
                ];
                const crit = criticalSuccesses[Math.floor(Math.random() * criticalSuccesses.length)];
                followupResponse = crit.response;
                followupVoice = crit.voice;
            }
            // High Success (18-19)
            else if (total >= 18) {
                if (rollType.includes('stealth')) {
                    followupResponse = "Like a shadow given form, you move completely undetected. You're practically invisible!";
                    followupVoice = "You've become one with the shadows themselves! No one has any idea you're there. You have complete tactical advantage - what's your next move from the shadows?";
                } else if (rollType.includes('perception') || rollType.includes('investigation')) {
                    followupResponse = "Your keen senses reveal hidden details others would miss! You notice something very important...";
                    followupVoice = "Your sharp eyes catch every detail! Not only do you see what you were looking for, but you notice something else entirely - something that changes everything! What catches your attention most?";
                } else if (rollType.includes('persuasion') || rollType.includes('charisma')) {
                    followupResponse = "Your words strike the perfect chord! The NPC is not just convinced - they're eager to help!";
                    followupVoice = "Your silver tongue works its magic perfectly! The NPC's entire demeanor shifts - they're not just willing to help, they're enthusiastic about it! They lean in closer and say...";
                } else if (rollType.includes('initiative')) {
                    followupResponse = "Lightning reflexes! You act before anyone else can even blink! You have the drop on your enemies!";
                    followupVoice = "Incredible reflexes! Time seems to slow as you spring into action before anyone else can react! You have complete control of the battlefield's opening moments - make them count!";
                } else {
                    followupResponse = "Exceptional success! Fortune favors the bold, and you've proven very bold indeed!";
                    followupVoice = "Outstanding! Your skill and luck combine for a truly exceptional result! The dice love you today! How do you capitalize on this golden opportunity?";
                }
            }
            // Good Success (15-17)
            else if (total >= 15) {
                if (rollType.includes('combat') || rollType.includes('attack')) {
                    followupResponse = "Solid hit! Your attack finds its mark with satisfying impact!";
                    followupVoice = "A clean hit! Your strike lands true, and you can see the effect immediately! Your enemy staggers - press the advantage!";
                } else {
                    followupResponse = "Success! Your action achieves exactly what you intended, clean and effective!";
                    followupVoice = "Well done! Your approach works perfectly, achieving your goal with style! The path forward is clear - what's your next step?";
                }
            }
            // Moderate Success (10-14)
            else if (total >= 10) {
                followupResponse = "You succeed, but it's not pretty. The job gets done with a few complications along the way.";
                followupVoice = "Success, but barely! You manage to accomplish your goal, though not without drawing some unwanted attention or creating a new problem. How do you handle the complication?";
            }
            // Close Failure (5-9)
            else if (total >= 5) {
                followupResponse = "So close! You almost succeed, but fall just short. However, all is not lost - you might try a different approach.";
                followupVoice = "Almost! You were so close to success, but not quite there. The good news is you learned something from the attempt. Want to try a different tactic, or double down on this one?";
            }
            // Natural 1 or Critical Failure
            else if (total === 1 || total <= 4) {
                const criticalFailures = [
                    {
                        response: "NATURAL 1! Critical failure! The dice betray you spectacularly! This is going to hurt...",
                        voice: "OOF! Natural one! Critical failure! Not only does your action fail, but it fails in the most spectacular way possible! Something has gone terribly, hilariously wrong! How does your character react to this disaster?"
                    },
                    {
                        response: "Catastrophic failure! Your action backfires completely, creating a whole new problem!",
                        voice: "Oh no! That's a critical failure! Your attempt goes so wrong it actually makes things worse! The universe itself seems to be laughing at you! Everything starts going sideways..."
                    }
                ];
                const fail = criticalFailures[Math.floor(Math.random() * criticalFailures.length)];
                followupResponse = fail.response;
                followupVoice = fail.voice;
            }
            // Regular Failure
            else {
                followupResponse = "Failure. Your action doesn't work as intended, and the situation remains challenging.";
                followupVoice = "That's a failure. Your attempt doesn't achieve what you hoped, and you'll need to reconsider your approach. The situation is getting tense - what's plan B?";
            }
            
            displayDMResponse(followupResponse, followupVoice);
        }
        
        // Display DM response with voice and trigger battle map generation
        function displayDMResponse(textResponse, voiceResponse) {
            const responseMessage = `
                <div class="dm-message voice-message">
                    <div class="message-header">
                        <strong>üé≠ Dungeon Master</strong>
                        <span class="voice-indicator-small">üîä</span>
                        <span class="timestamp">${new Date().toLocaleTimeString()}</span>
                    </div>
                    <div class="message-content">
                        <p>${textResponse}</p>
                        <p class="dm-prompt"><em>${getVariedPrompt()}</em></p>
                    </div>
                </div>
            `;
            
            appendToConversation(responseMessage);
            
            // Check if DM response describes a new location and generate battle map
            setTimeout(() => {
                const shouldGenerateMap = checkIfMapNeeded(textResponse);
                if (shouldGenerateMap) {
                    generateBattleMapFromDMDescription(textResponse);
                }
            }, 800);
            
            // Speak the response
            setTimeout(() => {
                speakAsDM(voiceResponse || textResponse);
            }, 500);
        }
        
        // Legacy text-only function (fallback)
        function generateDMResponse(playerAction) {
            const responses = [
                {
                    condition: playerAction.toLowerCase().includes('left') || playerAction.toLowerCase().includes('forest'),
                    response: "You venture deeper into the forest. The strange lights dance between the ancient trees, leading you to a hidden clearing where an old stone altar sits covered in glowing runes. A soft humming fills the air."
                },
                {
                    condition: playerAction.toLowerCase().includes('right') || playerAction.toLowerCase().includes('settlement'),
                    response: "You approach the settlement, which turns out to be a small trading post. A weathered innkeeper greets you warmly, offering hot food and tales of recent strange happenings in the region."
                },
                {
                    condition: playerAction.toLowerCase().includes('investigate') || playerAction.toLowerCase().includes('examine'),
                    response: "Your investigation reveals more than you initially expected. Roll a d20 + your Investigation modifier to see what you discover!"
                },
                {
                    condition: playerAction.toLowerCase().includes('attack') || playerAction.toLowerCase().includes('fight'),
                    response: "Combat begins! Roll for initiative! The tension in the air is palpable as weapons are drawn and spells are prepared."
                },
                {
                    condition: playerAction.toLowerCase().includes('talk') || playerAction.toLowerCase().includes('speak'),
                    response: "Your words carry weight in this moment. The NPC listens intently, their expression shifting as they consider your words carefully."
                }
            ];
            
            // Find matching response or use default
            let dmResponse = responses.find(r => r.condition)?.response || 
                "Interesting choice! The consequences of your action begin to unfold before you. The world reacts to your decision in ways both expected and surprising.";
            
            // Add some dynamic elements based on campaign
            const campaign = window.currentCampaign;
            if (campaign?.moralComplexity === 'morally_gray') {
                dmResponse += " The moral implications of this choice are not immediately clear...";
            }
            
            const responseMessage = `
                <div class="dm-message">
                    <div class="message-header">
                        <strong>üé≠ Dungeon Master</strong>
                        <span class="timestamp">${new Date().toLocaleTimeString()}</span>
                    </div>
                    <div class="message-content">
                        <p>${dmResponse}</p>
                        <p class="dm-prompt"><em>${getVariedPrompt()}</em></p>
                    </div>
                </div>
            `;
            
            appendToConversation(responseMessage);
        }
        
        // Roll dice
        function rollDice() {
            const dice = ['d4', 'd6', 'd8', 'd10', 'd12', 'd20'];
            const selectedDie = prompt('Which die do you want to roll? (d4, d6, d8, d10, d12, d20)', 'd20');
            
            if (dice.includes(selectedDie)) {
                const sides = parseInt(selectedDie.substring(1));
                const result = Math.floor(Math.random() * sides) + 1;
                
                const rollMessage = `
                    <div class="dice-roll">
                        <div class="message-header">
                            <strong>üé≤ Dice Roll</strong>
                            <span class="timestamp">${new Date().toLocaleTimeString()}</span>
                        </div>
                        <div class="message-content">
                            <p><strong>${getActiveCharacterName()}</strong> rolled a <strong>${selectedDie}</strong>: <span class="roll-result">${result}</span></p>
                        </div>
                    </div>
                `;
                
                appendToConversation(rollMessage);
            }
        }
        
        // Initiate quick actions
        function initiateAction(actionType) {
            const actions = {
                combat: "I want to initiate combat!",
                explore: "I want to explore the area more thoroughly.",
                rest: "I want to take a rest to recover.",
                inventory: "I want to check my inventory and equipment."
            };
            
            const input = document.getElementById('player-input');
            input.value = actions[actionType] || "I want to take an action.";
            sendPlayerAction();
        }
        
        // Helper functions
        function getActiveCharacterName() {
            const characters = window.partyCharacters || [];
            return characters.length > 0 ? characters[0].name : 'Adventurer';
        }
        
        function appendToConversation(messageHTML) {
            const history = document.getElementById('conversation-history');
            if (history) {
                history.innerHTML += messageHTML;
                history.scrollTop = history.scrollHeight;
                
                // Save conversation to campaign
                if (window.currentCampaign) {
                    saveCurrentCampaignData();
                }
            }
        }
        
        function updateGameStatus(location, time, weather) {
            document.getElementById('current-location').textContent = location;
            document.getElementById('current-time').textContent = time;
            document.getElementById('current-weather').textContent = weather;
        }

        // ===============================
        // COMBAT SYSTEM - D&D 5E RULES
        // ===============================
        
        // Combat state management
        let combatState = {
            active: false,
            combatants: [],
            currentTurn: 0,
            round: 1,
            mapZoom: 1,
            actionEconomy: {
                action: true,
                bonusAction: true,
                movement: 30,
                reaction: true
            }
        };

        // Modified initiateAction function to properly handle combat
        function initiateAction(actionType) {
            if (actionType === 'combat') {
                // Check if already in combat
                if (combatState.active) {
                    switchScreen('combat');
                    return;
                }
                
                // Start combat encounter
                startCombatEncounter();
            } else {
                const actions = {
                    explore: "I want to explore the area more thoroughly.",
                    rest: "I want to take a rest to recover.",
                    inventory: "I want to check my inventory and equipment."
                };

                if (actions[actionType]) {
                    document.getElementById('player-input').value = actions[actionType];
                    sendPlayerAction();
                }
            }
        }

        // Start a combat encounter
        function startCombatEncounter() {
            // Initialize combat with party characters and some enemies
            const partyMembers = window.partyCharacters || [];
            const enemies = generateEnemies();
            
            combatState.combatants = [
                ...partyMembers.map(char => ({
                    ...char,
                    type: 'player',
                    initiative: 0,
                    position: { x: 100 + Math.random() * 100, y: 200 + Math.random() * 100 },
                    conditions: []
                })),
                ...enemies
            ];
            
            // Roll initiative for all combatants
            rollInitiative();
            
            // Show combat screen
            combatState.active = true;
            switchScreen('combat');
            
            // Initialize battle map
            initializeBattleMap();
            
            // Add combat message
            addCombatMessage('Combat has begun! Rolling initiative...', 'system');
        }

        // Generate random enemies for the encounter
        function generateEnemies() {
            const enemyTemplates = [
                { name: 'Goblin', hp: 7, ac: 15, initiative: 0, type: 'enemy' },
                { name: 'Orc', hp: 15, ac: 13, initiative: 0, type: 'enemy' },
                { name: 'Bandit', hp: 11, ac: 12, initiative: 0, type: 'enemy' }
            ];
            
            const numEnemies = Math.min(3, Math.max(1, (window.partyCharacters?.length || 1)));
            const enemies = [];
            
            for (let i = 0; i < numEnemies; i++) {
                const template = enemyTemplates[Math.floor(Math.random() * enemyTemplates.length)];
                enemies.push({
                    ...template,
                    name: template.name + (numEnemies > 1 ? ` ${i + 1}` : ''),
                    position: { x: 300 + Math.random() * 200, y: 150 + Math.random() * 200 },
                    conditions: [],
                    combat: {
                        hitPoints: { current: template.hp, max: template.hp },
                        armorClass: template.ac
                    }
                });
            }
            
            return enemies;
        }

        // Roll initiative for all combatants
        function rollInitiative() {
            combatState.combatants.forEach(combatant => {
                // Roll d20 + DEX modifier
                const dexMod = Math.floor((combatant.abilities?.dexterity?.score || 10) / 2) - 5;
                combatant.initiative = Math.floor(Math.random() * 20) + 1 + dexMod;
            });
            
            // Sort by initiative (highest first)
            combatState.combatants.sort((a, b) => {
                if (b.initiative !== a.initiative) {
                    return b.initiative - a.initiative;
                }
                // Tie-breaker: higher DEX score wins
                const aDex = a.abilities?.dexterity?.score || 10;
                const bDex = b.abilities?.dexterity?.score || 10;
                return bDex - aDex;
            });
            
            combatState.currentTurn = 0;
            updateInitiativeDisplay();
            updateActionEconomy();
        }

        // Update the initiative tracker display
        function updateInitiativeDisplay() {
            const initiativeList = document.getElementById('initiative-list');
            if (!initiativeList) return;
            
            initiativeList.innerHTML = '';
            
            combatState.combatants.forEach((combatant, index) => {
                const entry = document.createElement('div');
                entry.className = `initiative-entry ${combatant.type}`;
                if (index === combatState.currentTurn) {
                    entry.classList.add('current-turn');
                }
                
                const hpDisplay = combatant.combat?.hitPoints ? 
                    `${combatant.combat.hitPoints.current}/${combatant.combat.hitPoints.max} HP` : '';
                
                entry.innerHTML = `
                    <div>
                        <div class="initiative-name">${combatant.name}</div>
                        <div style="font-size: 0.8rem; color: var(--color-text-secondary);">${hpDisplay}</div>
                    </div>
                    <div class="initiative-value">${combatant.initiative}</div>
                `;
                
                initiativeList.appendChild(entry);
            });
        }

        // Update action economy display
        function updateActionEconomy() {
            const currentCombatant = combatState.combatants[combatState.currentTurn];
            if (!currentCombatant || currentCombatant.type !== 'player') {
                // Hide action economy for non-player turns
                return;
            }
            
            document.getElementById('action-status').textContent = 
                combatState.actionEconomy.action ? 'Available' : 'Used';
            document.getElementById('action-status').className = 
                combatState.actionEconomy.action ? 'available' : 'used';
                
            document.getElementById('bonus-action-status').textContent = 
                combatState.actionEconomy.bonusAction ? 'Available' : 'Used';
            document.getElementById('bonus-action-status').className = 
                combatState.actionEconomy.bonusAction ? 'available' : 'used';
                
            document.getElementById('movement-status').textContent = 
                `${combatState.actionEconomy.movement} ft`;
            document.getElementById('movement-status').className = 
                combatState.actionEconomy.movement > 0 ? 'available' : 'used';
                
            document.getElementById('reaction-status').textContent = 
                combatState.actionEconomy.reaction ? 'Available' : 'Used';
            document.getElementById('reaction-status').className = 
                combatState.actionEconomy.reaction ? 'available' : 'used';
        }

        // Handle combat actions with D&D 5e rules
        function combatAction(actionType) {
            const currentCombatant = combatState.combatants[combatState.currentTurn];
            
            if (!currentCombatant || currentCombatant.type !== 'player') {
                addCombatMessage("It's not your turn!", 'system');
                return;
            }
            
            switch (actionType) {
                case 'attack':
                    if (!combatState.actionEconomy.action) {
                        addCombatMessage("You've already used your action this turn!", 'system');
                        return;
                    }
                    handleAttackAction(currentCombatant);
                    combatState.actionEconomy.action = false;
                    break;
                    
                case 'dodge':
                    if (!combatState.actionEconomy.action) {
                        addCombatMessage("You've already used your action this turn!", 'system');
                        return;
                    }
                    currentCombatant.conditions = currentCombatant.conditions || [];
                    currentCombatant.conditions.push('dodging');
                    addCombatMessage(`${currentCombatant.name} takes the Dodge action. Attacks against you have disadvantage until your next turn.`, 'system');
                    combatState.actionEconomy.action = false;
                    break;
                    
                case 'dash':
                    if (!combatState.actionEconomy.action) {
                        addCombatMessage("You've already used your action this turn!", 'system');
                        return;
                    }
                    const speed = currentCombatant.speed || 30;
                    combatState.actionEconomy.movement += speed;
                    addCombatMessage(`${currentCombatant.name} takes the Dash action. Movement increased by ${speed} ft.`, 'system');
                    combatState.actionEconomy.action = false;
                    break;
                    
                case 'help':
                    if (!combatState.actionEconomy.action) {
                        addCombatMessage("You've already used your action this turn!", 'system');
                        return;
                    }
                    addCombatMessage(`${currentCombatant.name} uses the Help action. Choose an ally to give them advantage on their next ability check or attack.`, 'system');
                    combatState.actionEconomy.action = false;
                    break;
                    
                case 'hide':
                    if (!combatState.actionEconomy.action) {
                        addCombatMessage("You've already used your action this turn!", 'system');
                        return;
                    }
                    const stealthRoll = Math.floor(Math.random() * 20) + 1;
                    const stealthMod = Math.floor((currentCombatant.abilities?.dexterity?.score || 10) / 2) - 5;
                    const total = stealthRoll + stealthMod;
                    addCombatMessage(`${currentCombatant.name} attempts to hide. Stealth check: ${stealthRoll} + ${stealthMod} = ${total}`, 'system');
                    combatState.actionEconomy.action = false;
                    break;
                    
                case 'ready':
                    if (!combatState.actionEconomy.action) {
                        addCombatMessage("You've already used your action this turn!", 'system');
                        return;
                    }
                    addCombatMessage(`${currentCombatant.name} readies an action. Describe your trigger and action.`, 'system');
                    combatState.actionEconomy.action = false;
                    break;
                    
                case 'disengage':
                    if (!combatState.actionEconomy.action) {
                        addCombatMessage("You've already used your action this turn!", 'system');
                        return;
                    }
                    addCombatMessage(`${currentCombatant.name} takes the Disengage action. You can move without provoking opportunity attacks.`, 'system');
                    combatState.actionEconomy.action = false;
                    break;
            }
            
            updateActionEconomy();
        }

        // Handle attack action with proper D&D 5e mechanics
        function handleAttackAction(attacker) {
            // Find available targets (enemies for players, players for enemies)
            const targets = combatState.combatants.filter(c => 
                c.type !== attacker.type && 
                (c.combat?.hitPoints?.current || 0) > 0
            );
            
            if (targets.length === 0) {
                addCombatMessage("No valid targets for attack!", 'system');
                return;
            }
            
            // For simplicity, attack the first available target
            const target = targets[0];
            
            // Roll attack
            const attackRoll = Math.floor(Math.random() * 20) + 1;
            const attackBonus = Math.floor((attacker.abilities?.strength?.score || 10) / 2) - 5 + 2; // +2 proficiency
            const totalAttack = attackRoll + attackBonus;
            
            const targetAC = target.combat?.armorClass || 10;
            
            if (attackRoll === 20) {
                // Critical hit!
                const damage = Math.floor(Math.random() * 8) + 1 + Math.floor(Math.random() * 8) + 1; // 2d8 for crit
                const strMod = Math.floor((attacker.abilities?.strength?.score || 10) / 2) - 5;
                const totalDamage = Math.max(1, damage + strMod);
                
                target.combat.hitPoints.current = Math.max(0, target.combat.hitPoints.current - totalDamage);
                
                addCombatMessage(`CRITICAL HIT! ${attacker.name} rolls a natural 20 and deals ${totalDamage} damage to ${target.name}!`, 'attack');
            } else if (attackRoll === 1) {
                // Critical miss!
                addCombatMessage(`CRITICAL MISS! ${attacker.name} rolls a natural 1 and misses spectacularly!`, 'attack');
            } else if (totalAttack >= targetAC) {
                // Hit!
                const damage = Math.floor(Math.random() * 8) + 1; // 1d8
                const strMod = Math.floor((attacker.abilities?.strength?.score || 10) / 2) - 5;
                const totalDamage = Math.max(1, damage + strMod);
                
                target.combat.hitPoints.current = Math.max(0, target.combat.hitPoints.current - totalDamage);
                
                addCombatMessage(`${attacker.name} hits ${target.name} for ${totalDamage} damage! (AC ${targetAC}, rolled ${totalAttack})`, 'attack');
            } else {
                // Miss!
                addCombatMessage(`${attacker.name} attacks ${target.name} but misses! (AC ${targetAC}, rolled ${totalAttack})`, 'attack');
            }
            
            // Check if target is defeated
            if (target.combat.hitPoints.current <= 0) {
                addCombatMessage(`${target.name} is defeated!`, 'system');
                target.conditions = target.conditions || [];
                target.conditions.push('defeated');
            }
            
            updateInitiativeDisplay();
            updateBattleMap();
        }

        // Advance to next turn
        function nextTurn() {
            if (!combatState.active) return;
            
            // Reset action economy
            combatState.actionEconomy = {
                action: true,
                bonusAction: true,
                movement: 30,
                reaction: true
            };
            
            // Clear temporary conditions
            const currentCombatant = combatState.combatants[combatState.currentTurn];
            if (currentCombatant.conditions) {
                currentCombatant.conditions = currentCombatant.conditions.filter(c => c !== 'dodging');
            }
            
            // Advance turn
            combatState.currentTurn++;
            if (combatState.currentTurn >= combatState.combatants.length) {
                combatState.currentTurn = 0;
                combatState.round++;
                addCombatMessage(`--- Round ${combatState.round} ---`, 'system');
            }
            
            const newCombatant = combatState.combatants[combatState.currentTurn];
            addCombatMessage(`${newCombatant.name}'s turn!`, 'system');
            
            updateInitiativeDisplay();
            updateActionEconomy();
            updateBattleMap();
            
            // Handle AI turns for non-player characters
            if (newCombatant.type !== 'player') {
                setTimeout(() => handleAITurn(newCombatant), 1000);
            }
        }

        // Handle AI turns for enemies and allies
        function handleAITurn(combatant) {
            if ((combatant.combat?.hitPoints?.current || 0) <= 0) {
                addCombatMessage(`${combatant.name} is defeated and cannot act.`, 'system');
                nextTurn();
                return;
            }
            
            // Simple AI: attack if possible, otherwise do nothing
            const targets = combatState.combatants.filter(c => 
                c.type !== combatant.type && 
                (c.combat?.hitPoints?.current || 0) > 0
            );
            
            if (targets.length > 0) {
                handleAttackAction(combatant);
            } else {
                addCombatMessage(`${combatant.name} has no valid targets.`, 'system');
            }
            
            setTimeout(() => nextTurn(), 1500);
        }

        // Initialize the battle map
        function initializeBattleMap() {
            const map = document.getElementById('battle-map');
            const combatantsLayer = document.getElementById('combatants-layer');
            
            if (!map || !combatantsLayer) return;
            
            // Clear existing tokens
            combatantsLayer.innerHTML = '';
            
            // Add combatant tokens
            combatState.combatants.forEach((combatant, index) => {
                const token = document.createElement('div');
                token.className = `combatant-token ${combatant.type}`;
                token.textContent = combatant.name.charAt(0).toUpperCase();
                token.title = combatant.name;
                token.style.left = combatant.position.x + 'px';
                token.style.top = combatant.position.y + 'px';
                token.dataset.combatantIndex = index;
                
                if (index === combatState.currentTurn) {
                    token.classList.add('current-turn');
                }
                
                // Add drag functionality for player characters on their turn
                if (combatant.type === 'player' && index === combatState.currentTurn) {
                    token.draggable = true;
                    token.style.cursor = 'move';
                    
                    token.addEventListener('dragstart', (e) => {
                        e.dataTransfer.setData('text/plain', index);
                        token.style.opacity = '0.5';
                    });
                    
                    token.addEventListener('dragend', (e) => {
                        token.style.opacity = '1';
                    });
                }
                
                combatantsLayer.appendChild(token);
            });
            
            // Add drop zone functionality to the battle map
            map.addEventListener('dragover', (e) => {
                e.preventDefault();
            });
            
            map.addEventListener('drop', (e) => {
                e.preventDefault();
                const combatantIndex = parseInt(e.dataTransfer.getData('text/plain'));
                const mapRect = map.getBoundingClientRect();
                const newX = e.clientX - mapRect.left - 20; // Center the token
                const newY = e.clientY - mapRect.top - 20;
                
                // Calculate movement distance
                const combatant = combatState.combatants[combatantIndex];
                const oldX = combatant.position.x;
                const oldY = combatant.position.y;
                const distance = Math.sqrt((newX - oldX) ** 2 + (newY - oldY) ** 2);
                const feetMoved = Math.round(distance / 10) * 5; // Convert pixels to 5-foot squares
                
                if (feetMoved <= combatState.actionEconomy.movement) {
                    // Valid move
                    combatant.position.x = Math.max(0, Math.min(newX, map.clientWidth - 40));
                    combatant.position.y = Math.max(0, Math.min(newY, map.clientHeight - 40));
                    combatState.actionEconomy.movement -= feetMoved;
                    
                    addCombatMessage(`${combatant.name} moves ${feetMoved} feet. ${combatState.actionEconomy.movement} feet of movement remaining.`, 'system');
                    updateBattleMap();
                    updateActionEconomy();
                } else {
                    // Invalid move - not enough movement
                    addCombatMessage(`${combatant.name} doesn't have enough movement! Distance: ${feetMoved} ft, Available: ${combatState.actionEconomy.movement} ft.`, 'system');
                    updateBattleMap(); // Reset position
                }
            });
        }

        // Update battle map (refresh token positions and states)
        function updateBattleMap() {
            initializeBattleMap();
        }

        // Add message to combat log
        function addCombatMessage(message, type = 'system') {
            const messagesContainer = document.getElementById('combat-messages');
            if (!messagesContainer) return;
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `combat-message ${type}`;
            
            const timestamp = new Date().toLocaleTimeString();
            messageDiv.innerHTML = `
                ${message}
                <span class="timestamp">${timestamp}</span>
            `;
            
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        // Map controls
        function zoomMap(direction) {
            const map = document.getElementById('battle-map');
            if (!map) return;
            
            if (direction === 'in') {
                combatState.mapZoom = Math.min(2, combatState.mapZoom + 0.2);
            } else {
                combatState.mapZoom = Math.max(0.5, combatState.mapZoom - 0.2);
            }
            
            map.style.transform = `scale(${combatState.mapZoom})`;
        }

        function centerMap() {
            const map = document.getElementById('battle-map');
            if (!map) return;
            
            combatState.mapZoom = 1;
            map.style.transform = 'scale(1)';
            map.scrollLeft = 0;
            map.scrollTop = 0;
        }

        // End combat
        function endCombat() {
            combatState.active = false;
            combatState.combatants = [];
            combatState.currentTurn = 0;
            combatState.round = 1;
            
            addCombatMessage('Combat has ended!', 'system');
            
            // Return to game screen
            switchScreen('game');
        }
    </script>

    <!-- Game Settings Modal -->
    <div id="game-settings-modal" class="modal" style="display: none;">
        <div class="modal-content large-modal">
            <div class="modal-header">
                <h3>‚öôÔ∏è Game Settings</h3>
                <button class="modal-close" onclick="this.closest('.modal').style.display='none'">‚úï</button>
            </div>
            <div class="modal-body">
                <div class="settings-tabs">
                    <button class="tab-button active" onclick="showSettingsTab('ai-settings')">ü§ñ AI Dungeon Master</button>
                    <button class="tab-button" onclick="showSettingsTab('voice-settings')">üé§ Voice & Audio</button>
                    <button class="tab-button" onclick="showSettingsTab('game-preferences')">üéÆ Preferences</button>
                </div>
                
                <div class="settings-content">
                    <!-- AI DM Settings Tab -->
                    <div id="ai-settings-tab" class="settings-tab active">
                        <div class="ai-engine-selection">
                            <h4>AI Engine</h4>
                            <div class="radio-group">
                                <label>
                                    <input type="radio" name="gameAiEngine" value="template" checked>
                                    Template Responses (Free, Basic)
                                </label>
                                <label>
                                    <input type="radio" name="gameAiEngine" value="openai">
                                    OpenAI (Premium, Advanced)
                                </label>
                            </div>
                        </div>

                        <div id="game-openai-settings" class="openai-settings" style="display: none;">
                            <h4>OpenAI Configuration</h4>
                            <div class="form-group">
                                <label for="game-openai-api-key">API Key:</label>
                                <div class="form-row">
                                    <input type="password" id="game-openai-api-key" placeholder="sk-..." 
                                           value="" class="api-key-input">
                                    <button type="button" onclick="testOpenAIInSettings()" class="test-button">Test</button>
                                </div>
                                <div id="game-openai-test-result" class="test-result"></div>
                            </div>
                            
                            <div class="form-group">
                                <label for="game-ai-model">Model:</label>
                                <select id="game-ai-model">
                                    <option value="gpt-3.5-turbo">GPT-3.5 Turbo (Faster, Cheaper)</option>
                                    <option value="gpt-4">GPT-4 (Smarter, More Expensive)</option>
                                    <option value="gpt-4-turbo-preview">GPT-4 Turbo (Latest)</option>
                                </select>
                            </div>
                            
                            <div class="form-group">
                                <label for="game-ai-creativity">Creativity: <span id="game-ai-creativity-display">70%</span></label>
                                <input type="range" id="game-ai-creativity" min="0" max="100" value="70" step="10">
                                <small>Lower = More predictable, Higher = More creative</small>
                            </div>
                            
                            <div class="form-group">
                                <label for="game-ai-response-length">Response Length:</label>
                                <select id="game-ai-response-length">
                                    <option value="short">Short (50-100 words)</option>
                                    <option value="normal" selected>Normal (100-200 words)</option>
                                    <option value="long">Long (200-300 words)</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Voice Settings Tab -->
                    <div id="voice-settings-tab" class="settings-tab">
                        <div class="voice-engine-selection">
                            <h4>Voice Engine</h4>
                            <div class="radio-group">
                                <label>
                                    <input type="radio" name="gameVoiceEngine" value="browser" checked>
                                    Browser Text-to-Speech (Free, Basic)
                                </label>
                                <label>
                                    <input type="radio" name="gameVoiceEngine" value="elevenlabs">
                                    ElevenLabs (Premium, High Quality)
                                </label>
                            </div>
                        </div>

                        <div id="game-elevenlabs-settings" class="elevenlabs-settings" style="display: none;">
                            <h4>ElevenLabs Configuration</h4>
                            <div class="form-group">
                                <label for="game-elevenlabs-api-key">API Key:</label>
                                <div class="form-row">
                                    <input type="password" id="game-elevenlabs-api-key" placeholder="Enter your ElevenLabs API key" 
                                           value="" class="api-key-input">
                                    <button type="button" onclick="testElevenLabsInSettings()" class="test-button">Test</button>
                                </div>
                                <div id="game-elevenlabs-test-result" class="test-result"></div>
                            </div>
                            
                            <div class="form-group">
                                <label for="game-elevenlabs-voice-id">DM Voice:</label>
                                <select id="game-elevenlabs-voice-id">
                                    <option value="">Loading voices...</option>
                                </select>
                                <button type="button" onclick="loadElevenLabsVoicesInSettings()" class="secondary-button">Refresh Voices</button>
                            </div>
                            
                            <div class="form-group">
                                <label for="game-voice-stability">Stability: <span id="game-voice-stability-display">50%</span></label>
                                <input type="range" id="game-voice-stability" min="0" max="100" value="50" step="5">
                                <small>Lower = More variable, Higher = More stable</small>
                            </div>
                            
                            <div class="form-group">
                                <label for="game-voice-clarity">Clarity: <span id="game-voice-clarity-display">75%</span></label>
                                <input type="range" id="game-voice-clarity" min="0" max="100" value="75" step="5">
                                <small>Lower = More similar to original, Higher = Enhanced clarity</small>
                            </div>
                            
                            <div class="form-group">
                                <button type="button" onclick="testElevenLabsVoiceInSettings()" class="primary-button">Test Voice</button>
                            </div>
                        </div>

                        <!-- Browser TTS Settings -->
                        <div id="game-browser-tts-settings" class="browser-tts-settings">
                            <h4>Browser Text-to-Speech</h4>
                            <div class="form-group">
                                <label for="game-browser-voice">Voice:</label>
                                <select id="game-browser-voice">
                                    <option value="">Default System Voice</option>
                                </select>
                            </div>
                            
                            <div class="form-group">
                                <label for="game-voice-rate">Speech Rate: <span id="game-voice-rate-display">1.0x</span></label>
                                <input type="range" id="game-voice-rate" min="0.5" max="2" value="1" step="0.1">
                            </div>
                            
                            <div class="form-group">
                                <label for="game-voice-pitch">Pitch: <span id="game-voice-pitch-display">1.0x</span></label>
                                <input type="range" id="game-voice-pitch" min="0.5" max="2" value="1" step="0.1">
                            </div>
                        </div>
                    </div>

                    <!-- Game Preferences Tab -->
                    <div id="game-preferences-tab" class="settings-tab">
                        <h4>Auto-Save</h4>
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="game-auto-save-enabled" checked>
                                Enable auto-save every 5 minutes
                            </label>
                        </div>
                        
                        <h4>Campaign Preferences</h4>
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="game-use-campaign-context" checked>
                                Include campaign context in AI responses
                            </label>
                        </div>
                        
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="game-use-reference-data" checked>
                                Use D&D reference data for AI responses
                            </label>
                        </div>
                        
                        <h4>Interface</h4>
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="game-show-timestamps" checked>
                                Show timestamps on messages
                            </label>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="secondary-button" onclick="this.closest('.modal').style.display='none'">Cancel</button>
                <button class="primary-button" onclick="saveGameSettings()">Save Settings</button>
            </div>
        </div>
    </div>

    <!-- Initialize Application -->
    <script type="module">
        // Check browser compatibility first
        const isModuleSupported = 'noModule' in HTMLScriptElement.prototype;
        const isFileProtocol = window.location.protocol === 'file:';
        
        if (isFileProtocol) {
            console.warn('‚ö†Ô∏è Running from file:// protocol. ES modules may not work properly.');
            console.log('üí° For full functionality, serve this app from a web server (e.g., python -m http.server)');
        }
        
        // Import the core module
        import './js/core.js';
        
        // Application initialization
        document.addEventListener('DOMContentLoaded', async () => {
            const loadingScreen = document.getElementById('loading-screen');
            const loadingProgress = document.getElementById('loading-progress');
            const loadingText = document.getElementById('loading-text');
            const app = document.getElementById('app');
            
            function updateProgress(progress, text) {
                loadingProgress.style.width = progress + '%';
                loadingText.textContent = text;
                console.log(`üìä ${progress}%: ${text}`);
            }
            
            try {
                updateProgress(10, 'Loading ancient scrolls...');
                await new Promise(resolve => setTimeout(resolve, 100));
                
                updateProgress(20, 'Checking browser compatibility...');
                // Browser checks
                if (window.location.protocol === 'file:') {
                    console.warn('üö® File protocol detected - this may cause issues');
                }
                
                updateProgress(30, 'Loading core modules...');
                console.log('üîß Loading full application with core modules');
                
                // Initialize DNDCore
                if (window.DNDCore) {
                    await window.DNDCore.init();
                    console.log('‚úÖ DNDCore initialized successfully');
                } else {
                    throw new Error('DNDCore not available');
                }
                
                updateProgress(95, 'Finalizing setup...');
                await new Promise(resolve => setTimeout(resolve, 200));
                
                updateProgress(100, 'Welcome, adventurer!');
                console.log('üéâ Application initialized successfully');
                
                // Hide loading screen and show app
                setTimeout(() => {
                    console.log('üé¨ Hiding loading screen');
                    loadingScreen.classList.add('fade-out');
                    setTimeout(() => {
                        loadingScreen.style.display = 'none';
                        app.style.opacity = '1';
                        console.log('‚úÖ Application fully loaded and visible');
                    }, 500);
                }, 300);
                
            } catch (error) {
                loadingText.textContent = `Error: ${error.message}`;
                console.error('Application initialization failed:', error);
                
                // Show detailed error in the error container
                const errorContainer = document.getElementById('error-container');
                if (errorContainer) {
                    errorContainer.style.display = 'block';
                    
                    let helpText = '';
                    if (window.location.protocol === 'file:') {
                        helpText = `
                            <div class="error-help">
                                <h3>üí° Quick Fix</h3>
                                <p>You're running this from a file:// URL, which causes security restrictions.</p>
                                <p><strong>Solution:</strong> Run a local server:</p>
                                <ol>
                                    <li>Open terminal/command prompt in this folder</li>
                                    <li>Run: <code>python -m http.server 8000</code></li>
                                    <li>Open: <a href="http://localhost:8000" target="_blank">http://localhost:8000</a></li>
                                </ol>
                                <p>Or use the provided <code>start-server.py</code> script.</p>
                            </div>
                        `;
                    }
                    
                    errorContainer.innerHTML = `
                        <div class="critical-error">
                            <h2>‚ö†Ô∏è Initialization Error</h2>
                            <p>Taylor's Epic D&D Time failed to initialize.</p>
                            ${helpText}
                            <details>
                                <summary>Technical Details</summary>
                                <pre>${error.stack || error.message}</pre>
                            </details>
                            <div class="error-actions">
                                <button onclick="location.reload()">üîÑ Reload</button>
                                <button onclick="window.open('README-SERVER.md', '_blank')">üìñ Help Guide</button>
                            </div>
                        </div>
                    `;
                }
                
                // Hide loading screen after showing error
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                }, 1000);
            }
        });
        
        // Service Worker Registration for PWA support (disabled - sw.js not present)
        // if ('serviceWorker' in navigator) {
        //     window.addEventListener('load', () => {
        //         navigator.serviceWorker.register('./sw.js')
        //             .then(registration => console.log('SW registered'))
        //             .catch(error => console.log('SW registration failed'));
        //     });
        // }
        
        // Global error handler
        window.addEventListener('error', (event) => {
            console.error('Global error:', event.error);
            if (window.DNDCore) {
                window.DNDCore.handleCriticalError(event.error);
            }
        });
        
        // Prevent default drag and drop to avoid accidental navigation
        document.addEventListener('dragover', e => e.preventDefault());
        document.addEventListener('drop', e => e.preventDefault());

        // Initialize AI DM settings after DOM loads
        document.addEventListener('DOMContentLoaded', function() {
            // Load OpenAI config from localStorage
            const enabled = localStorage.getItem('openai_enabled') === 'true';
            if (enabled) {
                openAIConfig.enabled = true;
            }

            // Add event listeners for AI engine radio buttons
            const aiRadioButtons = document.querySelectorAll('input[name="aiEngine"]');
            aiRadioButtons.forEach(radio => {
                radio.addEventListener('change', function() {
                    // Toggle OpenAI settings visibility
                    const openaiRadio = document.querySelector('input[value="openai"]:checked');
                    const openaiSettings = document.getElementById('openai-settings');
                    
                    if (openaiSettings) {
                        if (openaiRadio) {
                            openaiSettings.style.display = 'block';
                        } else {
                            openaiSettings.style.display = 'none';
                        }
                    }
                });
            });

            // Add event listener for creativity slider
            const creativitySlider = document.getElementById('ai-creativity');
            if (creativitySlider) {
                creativitySlider.addEventListener('input', function() {
                    document.getElementById('ai-creativity-display').textContent = this.value + '%';
                });
            }
        });
    </script>
</body>
</html>